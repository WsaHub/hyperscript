{"version":3,"file":"_hyperscript.js","sources":["../src/_hyperscript.ts"],"sourcesContent":["/**\n * @typedef {Object} Hyperscript\n */\n\n (function (self, factory) {\n  const _hyperscript = factory(self)\n\n  if (typeof exports === 'object' && typeof exports['nodeName'] !== 'string') {\n      module.exports = _hyperscript\n  } else {\n      self['_hyperscript'] = _hyperscript\n      if ('document' in self) self['_hyperscript'].browserInit()\n  }\n})(typeof self !== 'undefined' ? self : undefined, (globalScope) => {\n\n  'use strict';\n\n  /**\n   * @type {Object}\n   * @property {DynamicConverter[]} dynamicResolvers\n   * \n   * @callback DynamicConverter\n   * @param {String} str\n   * @param {*} value\n   * @returns {*}\n   */\n  const conversions = {\n      dynamicResolvers: [\n          function (str:string, value:any):any {\n              if (str === \"Fixed\") {\n                  return Number(value).toFixed();\n              } else if (str.indexOf(\"Fixed:\") === 0) {\n                  let num = str.split(\":\")[1];\n                  return Number(value).toFixed(parseInt(num));\n              }\n          }\n      ],\n      String: function (val:any):string {\n          if (val.toString) {\n              return val.toString();\n          } else {\n              return \"\" + val;\n          }\n      },\n      Int: function (val:any):number {\n          return parseInt(val);\n      },\n      Float: function (val:any):number {\n          return parseFloat(val);\n      },\n      Number: function (val:any):number {\n          return Number(val);\n      },\n      Date: function (val:any):Date {\n          return new Date(val);\n      },\n      Array: function (val:any):any[] {\n          return Array.from(val);\n      },\n      JSON: function (val:any):string {\n          return JSON.stringify(val);\n      },\n      Object: function (val:any):any {\n          if (val instanceof String) {\n              val = val.toString();\n          }\n          if (typeof val === \"string\") {\n              return JSON.parse(val);\n          } else {\n              return Object.assign({}, val);\n          }\n      },\n  }\n\n  const config = {\n      attributes: \"_, script, data-script\",\n      hideShowStrategies: undefined,\n      defaultHideShowStrategy: undefined,\n      defaultTransition: \"all 500ms ease-in\",\n      disableSelector: \"[disable-scripting], [data-disable-scripting]\",\n      conversions,\n  }\n\n  /**\n   * @typedef {Object} Token\n   * @property {string} [type]\n   * @property {string} value\n   * @property {number} [start]\n   * @property {number} [end]\n   * @property {number} [column]\n   * @property {number} [line]\n   * @property {boolean} [op] `true` if this token represents an operator\n   * @property {boolean} [template] `true` if this token is a template, for class refs, id refs, strings\n   */\n\n  type Token = {\n    type?:string, value:string,\n    start?:number, end?:number, column?:number, line?:number,\n    op?:boolean, template?:boolean,\n  }\n\n  class Lexer {\n      static OP_TABLE = {\n          \"+\": \"PLUS\",\n          \"-\": \"MINUS\",\n          \"*\": \"MULTIPLY\",\n          \"/\": \"DIVIDE\",\n          \".\": \"PERIOD\",\n          \"..\": \"ELLIPSIS\",\n          \"\\\\\": \"BACKSLASH\",\n          \":\": \"COLON\",\n          \"%\": \"PERCENT\",\n          \"|\": \"PIPE\",\n          \"!\": \"EXCLAMATION\",\n          \"?\": \"QUESTION\",\n          \"#\": \"POUND\",\n          \"&\": \"AMPERSAND\",\n          $: \"DOLLAR\",\n          \";\": \"SEMI\",\n          \",\": \"COMMA\",\n          \"(\": \"L_PAREN\",\n          \")\": \"R_PAREN\",\n          \"<\": \"L_ANG\",\n          \">\": \"R_ANG\",\n          \"<=\": \"LTE_ANG\",\n          \">=\": \"GTE_ANG\",\n          \"==\": \"EQ\",\n          \"===\": \"EQQ\",\n          \"!=\": \"NEQ\",\n          \"!==\": \"NEQQ\",\n          \"{\": \"L_BRACE\",\n          \"}\": \"R_BRACE\",\n          \"[\": \"L_BRACKET\",\n          \"]\": \"R_BRACKET\",\n          \"=\": \"EQUALS\",\n      };\n  \n      /**\n       * isValidCSSClassChar returns `true` if the provided character is valid in a CSS class.\n       * @param {string} c\n       * @returns boolean\n       */\n      static isValidCSSClassChar(c:string):boolean {\n          return Lexer.isAlpha(c) || Lexer.isNumeric(c) || c === \"-\" || c === \"_\" || c === \":\";\n      }\n  \n      /**\n       * isValidCSSIDChar returns `true` if the provided character is valid in a CSS ID\n       * @param {string} c\n       * @returns boolean\n       */\n      static isValidCSSIDChar(c:string):boolean {\n          return Lexer.isAlpha(c) || Lexer.isNumeric(c) || c === \"-\" || c === \"_\" || c === \":\";\n      }\n  \n      /**\n       * isWhitespace returns `true` if the provided character is whitespace.\n       * @param {string} c\n       * @returns boolean\n       */\n      static isWhitespace(c:string):boolean {\n          return c === \" \" || c === \"\\t\" || Lexer.isNewline(c);\n      }\n  \n      /**\n       * positionString returns a string representation of a Token's line and column details.\n       * @param {Token} token\n       * @returns string\n       */\n      static positionString(token:Token):string {\n          return \"[Line: \" + token.line + \", Column: \" + token.column + \"]\";\n      }\n  \n      /**\n       * isNewline returns `true` if the provided character is a carrage return or newline\n       * @param {string} c\n       * @returns boolean\n       */\n      static isNewline(c:string):boolean {\n          return c === \"\\r\" || c === \"\\n\";\n      }\n  \n      /**\n       * isNumeric returns `true` if the provided character is a number (0-9)\n       * @param {string} c\n       * @returns boolean\n       */\n      static isNumeric(c:string):boolean {\n          return c >= \"0\" && c <= \"9\";\n      }\n  \n      /**\n       * isAlpha returns `true` if the provided character is a letter in the alphabet\n       * @param {string} c\n       * @returns boolean\n       */\n      static isAlpha(c:string):boolean {\n          return (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\");\n      }\n  \n      /**\n       * @param {string} c\n       * @returns boolean\n       */\n      static isIdentifierChar(c:string):boolean {\n          return c === \"_\" || c === \"$\";\n      }\n  \n      /**\n       * @param {string} c\n       * @returns boolean\n       */\n      static isReservedChar(c:string):boolean {\n          return c === \"`\" || c === \"^\";\n      }\n  \n      /**\n       * @param {Token[]} tokens\n       * @returns {boolean}\n       */\n      static isValidSingleQuoteStringStart(tokens:Token[]):boolean {\n          if (tokens.length > 0) {\n              var previousToken = tokens[tokens.length - 1];\n              if (\n                  previousToken.type === \"IDENTIFIER\" ||\n                  previousToken.type === \"CLASS_REF\" ||\n                  previousToken.type === \"ID_REF\"\n              ) {\n                  return false;\n              }\n              if (previousToken.op && (previousToken.value === \">\" || previousToken.value === \")\")) {\n                  return false;\n              }\n          }\n          return true;\n      }\n  \n      /**\n       * @param {string} string\n       * @param {boolean} [template]\n       * @returns {Tokens}\n       */\n      static tokenize(string:string, template?:boolean):Tokens {\n          var tokens = /** @type {Token[]}*/ [];\n          var source = string;\n          var position = 0;\n          var column = 0;\n          var line = 1;\n          var lastToken = \"<START>\";\n          var templateBraceCount = 0;\n  \n          function inTemplate ():boolean {\n              return template && templateBraceCount === 0;\n          }\n  \n          while (position < source.length) {\n              if ((currentChar() === \"-\" && nextChar() === \"-\" && (Lexer.isWhitespace(nextCharAt(2)) || nextCharAt(2) === \"\" || nextCharAt(2) === \"-\"))\n                  || (currentChar() === \"/\" && nextChar() === \"/\")) {\n                  consumeComment();\n              } else if (currentChar() === \"/\" && nextChar() === \"*\") {\n                  consumeCommentMultiline();\n              } else {\n                  if (Lexer.isWhitespace(currentChar())) {\n                      tokens.push(consumeWhitespace());\n                  } else if (\n                      !possiblePrecedingSymbol() &&\n                      currentChar() === \".\" &&\n                      (Lexer.isAlpha(nextChar()) || nextChar() === \"{\")\n                  ) {\n                      tokens.push(consumeClassReference());\n                  } else if (\n                      !possiblePrecedingSymbol() &&\n                      currentChar() === \"#\" &&\n                      (Lexer.isAlpha(nextChar()) || nextChar() === \"{\")\n                  ) {\n                      tokens.push(consumeIdReference());\n                  } else if (currentChar() === \"[\" && nextChar() === \"@\") {\n                      tokens.push(consumeAttributeReference());\n                  } else if (currentChar() === \"@\") {\n                      tokens.push(consumeShortAttributeReference());\n                  } else if (currentChar() === \"*\" && Lexer.isAlpha(nextChar())) {\n                      tokens.push(consumeStyleReference());\n                  } else if (Lexer.isAlpha(currentChar()) || (!inTemplate() && Lexer.isIdentifierChar(currentChar()))) {\n                      tokens.push(consumeIdentifier());\n                  } else if (Lexer.isNumeric(currentChar())) {\n                      tokens.push(consumeNumber());\n                  } else if (!inTemplate() && (currentChar() === '\"' || currentChar() === \"`\")) {\n                      tokens.push(consumeString());\n                  } else if (!inTemplate() && currentChar() === \"'\") {\n                      if (Lexer.isValidSingleQuoteStringStart(tokens)) {\n                          tokens.push(consumeString());\n                      } else {\n                          tokens.push(consumeOp());\n                      }\n                  } else if (Lexer.OP_TABLE[currentChar()]) {\n                      if (lastToken === \"$\" && currentChar() === \"{\") {\n                          templateBraceCount++;\n                      }\n                      if (currentChar() === \"}\") {\n                          templateBraceCount--;\n                      }\n                      tokens.push(consumeOp());\n                  } else if (inTemplate() || Lexer.isReservedChar(currentChar())) {\n                      tokens.push(makeToken(\"RESERVED\", consumeChar()));\n                  } else {\n                      if (position < source.length) {\n                          throw Error(\"Unknown token: \" + currentChar() + \" \");\n                      }\n                  }\n              }\n          }\n\n          return new Tokens(tokens, [], source);\n\n          /**\n           * @param {string} [type]\n           * @param {string} [value]\n           * @returns {Token}\n           */\n          function makeOpToken(type?:string, value?:string):Token {\n              var token = makeToken(type, value);\n              token.op = true;\n              return token;\n          }\n\n          /**\n           * @param {string} [type]\n           * @param {string} [value]\n           * @returns {Token}\n           */\n          function makeToken(type:string, value?:string):Token {\n              return {\n                  type: type,\n                  value: value || \"\",\n                  start: position,\n                  end: position + 1,\n                  column: column,\n                  line: line,\n              };\n          }\n\n          function consumeComment ():void {\n              while (currentChar() && !Lexer.isNewline(currentChar())) {\n                  consumeChar();\n              }\n              consumeChar(); // Consume newline\n          }\n\n          function consumeCommentMultiline ():void {\n              while (currentChar() && !(currentChar() === '*' && nextChar() === '/')) {\n                  consumeChar();\n              }\n              consumeChar(); // Consume \"*/\"\n              consumeChar();\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeClassReference ():Token {\n              var classRef = makeToken(\"CLASS_REF\");\n              var value = consumeChar();\n              if (currentChar() === \"{\") {\n                  classRef.template = true;\n                  value += consumeChar();\n                  while (currentChar() && currentChar() !== \"}\") {\n                      value += consumeChar();\n                  }\n                  if (currentChar() !== \"}\") {\n                      throw Error(\"Unterminated class reference\");\n                  } else {\n                      value += consumeChar(); // consume final curly\n                  }\n              } else {\n                  while (Lexer.isValidCSSClassChar(currentChar())) {\n                      value += consumeChar();\n                  }\n              }\n              classRef.value = value;\n              classRef.end = position;\n              return classRef;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeAttributeReference ():Token {\n              var attributeRef = makeToken(\"ATTRIBUTE_REF\");\n              var value = consumeChar();\n              while (position < source.length && currentChar() !== \"]\") {\n                  value += consumeChar();\n              }\n              if (currentChar() === \"]\") {\n                  value += consumeChar();\n              }\n              attributeRef.value = value;\n              attributeRef.end = position;\n              return attributeRef;\n          }\n\n          function consumeShortAttributeReference ():Token {\n              var attributeRef = makeToken(\"ATTRIBUTE_REF\");\n              var value = consumeChar();\n              while (Lexer.isValidCSSIDChar(currentChar())) {\n                  value += consumeChar();\n              }\n              attributeRef.value = value;\n              attributeRef.end = position;\n              return attributeRef;\n          }\n\n          function consumeStyleReference ():Token {\n              var styleRef = makeToken(\"STYLE_REF\");\n              var value = consumeChar();\n              while (Lexer.isAlpha(currentChar()) || currentChar() === \"-\") {\n                  value += consumeChar();\n              }\n              styleRef.value = value;\n              styleRef.end = position;\n              return styleRef;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeIdReference ():Token {\n              var idRef = makeToken(\"ID_REF\");\n              var value = consumeChar();\n              if (currentChar() === \"{\") {\n                  idRef.template = true;\n                  value += consumeChar();\n                  while (currentChar() && currentChar() !== \"}\") {\n                      value += consumeChar();\n                  }\n                  if (currentChar() !== \"}\") {\n                      throw Error(\"Unterminated id reference\");\n                  } else {\n                      consumeChar(); // consume final quote\n                  }\n              } else {\n                  while (Lexer.isValidCSSIDChar(currentChar())) {\n                      value += consumeChar();\n                  }\n              }\n              idRef.value = value;\n              idRef.end = position;\n              return idRef;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeIdentifier ():Token {\n              var identifier = makeToken(\"IDENTIFIER\");\n              var value = consumeChar();\n              while (Lexer.isAlpha(currentChar()) ||\n                     Lexer.isNumeric(currentChar()) ||\n                     Lexer.isIdentifierChar(currentChar())) {\n                  value += consumeChar();\n              }\n              if (currentChar() === \"!\" && value === \"beep\") {\n                  value += consumeChar();\n              }\n              identifier.value = value;\n              identifier.end = position;\n              return identifier;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeNumber ():Token {\n              var number = makeToken(\"NUMBER\");\n              var value = consumeChar();\n              while (Lexer.isNumeric(currentChar())) {\n                  value += consumeChar();\n              }\n              if (currentChar() === \".\" && Lexer.isNumeric(nextChar())) {\n                  value += consumeChar();\n              }\n              while (Lexer.isNumeric(currentChar())) {\n                  value += consumeChar();\n              }\n              number.value = value;\n              number.end = position;\n              return number;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeOp ():Token {\n              var op = makeOpToken();\n              var value = consumeChar(); // consume leading char\n              while (currentChar() && Lexer.OP_TABLE[value + currentChar()]) {\n                  value += consumeChar();\n              }\n              op.type = Lexer.OP_TABLE[value];\n              op.value = value;\n              op.end = position;\n              return op;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeString ():Token {\n              var string = makeToken(\"STRING\");\n              var startChar = consumeChar(); // consume leading quote\n              var value = \"\";\n              while (currentChar() && currentChar() !== startChar) {\n                  if (currentChar() === \"\\\\\") {\n                      consumeChar(); // consume escape char and get the next one\n                      let nextChar = consumeChar();\n                      if (nextChar === \"b\") {\n                          value += \"\\b\";\n                      } else if (nextChar === \"f\") {\n                          value += \"\\f\";\n                      } else if (nextChar === \"n\") {\n                          value += \"\\n\";\n                      } else if (nextChar === \"r\") {\n                          value += \"\\r\";\n                      } else if (nextChar === \"t\") {\n                          value += \"\\t\";\n                      } else if (nextChar === \"v\") {\n                          value += \"\\v\";\n                      } else {\n                          value += nextChar;\n                      }\n                  } else {\n                      value += consumeChar();\n                  }\n              }\n              if (currentChar() !== startChar) {\n                  throw Error(\"Unterminated string at \" + Lexer.positionString(string));\n              } else {\n                  consumeChar(); // consume final quote\n              }\n              string.value = value;\n              string.end = position;\n              string.template = startChar === \"`\";\n              return string;\n          }\n\n          /**\n           * @returns string\n           */\n          function currentChar ():string {\n              return source.charAt(position);\n          }\n\n          /**\n           * @returns string\n           */\n          function nextChar ():string {\n              return source.charAt(position + 1);\n          }\n\n          function nextCharAt (number:number = 1) {\n              return source.charAt(position + number);\n          }\n\n          /**\n           * @returns string\n           */\n          function consumeChar ():string {\n              lastToken = currentChar();\n              position++;\n              column++;\n              return lastToken;\n          }\n\n          /**\n           * @returns boolean\n           */\n          function possiblePrecedingSymbol ():boolean {\n              return (\n                  Lexer.isAlpha(lastToken) ||\n                  Lexer.isNumeric(lastToken) ||\n                  lastToken === \")\" ||\n                  lastToken === \"\\\"\" ||\n                  lastToken === \"'\" ||\n                  lastToken === \"`\" ||\n                  lastToken === \"}\" ||\n                  lastToken === \"]\"\n              );\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeWhitespace ():Token {\n              var whitespace = makeToken(\"WHITESPACE\");\n              var value = \"\";\n              while (currentChar() && Lexer.isWhitespace(currentChar())) {\n                  if (Lexer.isNewline(currentChar())) {\n                      column = 0;\n                      line++;\n                  }\n                  value += consumeChar();\n              }\n              whitespace.value = value;\n              whitespace.end = position;\n              return whitespace;\n          }\n      }\n\n      /**\n       * @param {string} string\n       * @param {boolean} [template]\n       * @returns {Tokens}\n       */\n      tokenize (string:string, template?:boolean):Tokens {\n          return Lexer.tokenize(string, template)\n      }\n  }\n\n  class Tokens {\n    public tokens:Token[]\n    public consumed:any[]\n    public source:any\n\n      constructor(tokens, consumed, source) {\n          this.tokens = tokens\n          this.consumed = consumed\n          this.source = source\n\n          this.consumeWhitespace (); // consume initial whitespace\n      }\n\n      get list () {\n          return this.tokens\n      }\n\n      /** @type Token | null */\n      _lastConsumed:Token | null = null;\n\n      consumeWhitespace ():void {\n          while (this.token(0, true).type === \"WHITESPACE\") {\n              this.consumed.push(this.tokens.shift());\n          }\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @param {*} error\n       * @returns {never}\n       */\n      raiseError (tokens:Tokens, error:any):void {\n          Parser.raiseParseError(tokens, error);\n      }\n\n      /**\n       * @param {string} value\n       * @returns {Token}\n       */\n      requireOpToken (value:string):Token {\n          var token = this.matchOpToken(value);\n          if (token) {\n              return token;\n          } else {\n              this.raiseError(this, \"Expected '\" + value + \"' but found '\" + this.currentToken().value + \"'\");\n          }\n      }\n\n      /**\n       * @param {string} op1\n       * @param {string} [op2]\n       * @param {string} [op3]\n       * @returns {Token | void}\n       */\n      matchAnyOpToken (/* op1:string, op2:string, op3:string */):Token|undefined {\n          for (var i = 0; i < arguments.length; i++) {\n              var opToken = arguments[i];\n              var match = this.matchOpToken(opToken);\n              if (match) {\n                  return match;\n              }\n          }\n      }\n\n      /**\n       * @param {string} op1\n       * @param {string} [op2]\n       * @param {string} [op3]\n       * @returns {Token | void}\n       */\n      matchAnyToken (/* op1:string, op2:string, op3:string */):Token|undefined {\n          for (var i = 0; i < arguments.length; i++) {\n              var opToken = arguments[i];\n              var match = this.matchToken(opToken);\n              if (match) {\n                  return match;\n              }\n          }\n      }\n\n      /**\n       * @param {string} value\n       * @returns {Token | void}\n       */\n      matchOpToken (value:string):Token|undefined {\n          if (this.currentToken() && this.currentToken().op && this.currentToken().value === value) {\n              return this.consumeToken();\n          }\n      }\n\n      /**\n       * @param {string} type1\n       * @param {string} [type2]\n       * @param {string} [type3]\n       * @param {string} [type4]\n       * @returns {Token}\n       */\n      requireTokenType (type1:string, type2:string, type3:string, type4:string):Token {\n          var token = this.matchTokenType(type1, type2, type3, type4);\n          if (token) {\n              return token;\n          } else {\n              this.raiseError(this, \"Expected one of \" + JSON.stringify([type1, type2, type3]));\n          }\n      }\n\n      /**\n       * @param {string} type1\n       * @param {string} [type2]\n       * @param {string} [type3]\n       * @param {string} [type4]\n       * @returns {Token | void}\n       */\n      matchTokenType (type1:string, type2:string, type3:string, type4:string):Token {\n          if (\n              this.currentToken() &&\n              this.currentToken().type &&\n              [type1, type2, type3, type4].indexOf(this.currentToken().type) >= 0\n          ) {\n              return this.consumeToken();\n          }\n      }\n\n      /**\n       * @param {string} value\n       * @param {string} [type]\n       * @returns {Token}\n       */\n      requireToken(value:string, type:string):Token {\n          var token = this.matchToken(value, type);\n          if (token) {\n              return token;\n          } else {\n              this.raiseError(this, \"Expected '\" + value + \"' but found '\" + this.currentToken().value + \"'\");\n          }\n      }\n\n      peekToken (value:string, peek:string, type:string):boolean {\n          return this.tokens[peek] && this.tokens[peek].value === value && this.tokens[peek].type === type\n      }\n\n      /**\n       * @param {string} value\n       * @param {string} [type]\n       * @returns {Token | void}\n       */\n      matchToken(value:string, type:string = 'IDENTIFIER'):Token | undefined {\n          if (this.follows.indexOf(value) !== -1) {\n              return; // disallowed token here\n          }\n          type = type || \"IDENTIFIER\";\n          if (this.currentToken() && this.currentToken().value === value && this.currentToken().type === type) {\n              return this.consumeToken();\n          }\n      }\n\n      /**\n       * @returns {Token}\n       */\n      consumeToken ():Token {\n          var match = this.tokens.shift();\n          this.consumed.push(match);\n          this._lastConsumed = match;\n          this.consumeWhitespace(); // consume any whitespace\n          return match;\n      }\n\n      /**\n       * @param {string | null} value\n       * @param {string | null} [type]\n       * @returns {Token[]}\n       */\n      consumeUntil (value:string | null, type:string | null):Token[] {\n          /** @type Token[] */\n          var tokenList = [];\n          var currentToken = this.token(0, true);\n\n          while (\n              (type == null || currentToken.type !== type) &&\n              (value == null || currentToken.value !== value) &&\n              currentToken.type !== \"EOF\"\n          ) {\n              var match = this.tokens.shift();\n              this.consumed.push(match);\n              tokenList.push(currentToken);\n              currentToken = this.token(0, true);\n          }\n          this.consumeWhitespace(); // consume any whitespace\n          return tokenList;\n      }\n\n      /**\n       * @returns {string}\n       */\n      lastWhitespace ():string {\n          if (this.consumed[this.consumed.length - 1] && this.consumed[this.consumed.length - 1].type === \"WHITESPACE\") {\n              return this.consumed[this.consumed.length - 1].value;\n          } else {\n              return \"\";\n          }\n      }\n\n      consumeUntilWhitespace ():Token[] {\n          return this.consumeUntil(null, \"WHITESPACE\");\n      }\n\n      /**\n       * @returns {boolean}\n       */\n      hasMore ():boolean {\n          return this.tokens.length > 0;\n      }\n\n      /**\n       * @param {number} n\n       * @param {boolean} [dontIgnoreWhitespace]\n       * @returns {Token}\n       */\n      token(n:number, dontIgnoreWhitespace:boolean = false):Token {\n          var /**@type {Token}*/ token;\n          var i = 0;\n          do {\n              if (!dontIgnoreWhitespace) {\n                  while (this.tokens[i] && this.tokens[i].type === \"WHITESPACE\") {\n                      i++;\n                  }\n              }\n              token = this.tokens[i];\n              n--;\n              i++;\n          } while (n > -1);\n          if (token) {\n              return token;\n          } else {\n              return {\n                  type: \"EOF\",\n                  value: \"<<<EOF>>>\",\n              } as Token;\n          }\n      }\n\n      /**\n       * @returns {Token}\n       */\n      currentToken ():Token {\n          return this.token(0);\n      }\n\n      /**\n       * @returns {Token | null}\n       */\n      lastMatch ():Token | null {\n          return this._lastConsumed;\n      }\n\n      /**\n       * @returns {string}\n       */\n      static sourceFor = function ():string {\n          return this.programSource.substring(this.startToken.start, this.endToken.end);\n      }\n\n      /**\n       * @returns {string}\n       */\n      static lineFor = function ():string {\n          return this.programSource.split(\"\\n\")[this.startToken.line - 1];\n      }\n\n      follows = [];\n\n      pushFollow (str):void {\n          this.follows.push(str);\n      }\n\n      popFollow ():void {\n          this.follows.pop();\n      }\n\n      clearFollows ():any[] {\n          var tmp = this.follows;\n          this.follows = [];\n          return tmp;\n      }\n\n      restoreFollows (f:any[]):void {\n          this.follows = f;\n      }\n  }\n\n  /**\n   * @callback ParseRule\n   * @param {Parser} parser\n   * @param {Runtime} runtime\n   * @param {Tokens} tokens\n   * @param {*} [root]\n   * @returns {ASTNode | undefined}\n   */\n\n  type ParseRule = (parser:Parser, runtime:Runtime, tokens:Tokens, root?:any) => ASTNode | undefined\n\n  /**\n   * @typedef {Object} ASTNode\n   * @member {boolean} isFeature\n   * @member {string} type\n   * @member {any[]} args\n   * @member {(this: ASTNode, ctx:Context, root:any, ...args:any) => any} op\n   * @member {(this: ASTNode, context?:Context) => any} evaluate\n   * @member {ASTNode} parent\n   * @member {Set<ASTNode>} children\n   * @member {ASTNode} root\n   * @member {String} keyword\n   * @member {Token} endToken\n   * @member {ASTNode} next\n   * @member {(context:Context) => ASTNode} resolveNext\n   * @member {EventSource} eventSource\n   * @member {(this: ASTNode) => void} install\n   * @member {(this: ASTNode, context:Context) => void} execute\n   * @member {(this: ASTNode, target: object, source: object, args?: Object) => void} apply\n   */\n\n  type ASTNode = {\n    isFeature?:boolean,\n    type?:string, args?:any[],\n    op:(this: ASTNode, ctx:Context, root:any, ...args:any) => any,\n    evaluate?:(this:ASTNode, context?:Context) => any,\n    parent?:ASTNode, children?:Set<ASTNode>, root?:ASTNode,\n    keyword?:string, endToken?:Token,\n    next?:ASTNode, resolveNext?:(context:Context) => ASTNode,\n    eventSource?:EventSource,\n    install?:(this:ASTNode) => void,\n    execute?:(this:ASTNode, context:Context) => void,\n    apply?:(this:ASTNode, target:object, source:object, args?:Object) => void\n  }\n\n  class Parser {\n    public parser:Parser\n    public runtime:Runtime\n    public possessivesDisabled:boolean\n\n      /**\n       *\n       * @param {Runtime} runtime\n       */\n      constructor (runtime:Runtime) {\n          this.runtime = runtime\n\n          this.possessivesDisabled = false\n\n          /* ============================================================================================ */\n          /* Core hyperscript Grammar Elements                                                            */\n          /* ============================================================================================ */\n          this.addGrammarElement(\"feature\", function (parser:Parser, runtime:Runtime, tokens:Tokens):ASTNode {\n              if (tokens.matchOpToken(\"(\")) {\n                  var featureElement = parser.requireElement(\"feature\", tokens);\n                  tokens.requireOpToken(\")\");\n                  return featureElement;\n              }\n\n              var featureDefinition = parser.FEATURES[tokens.currentToken().value || \"\"];\n              if (featureDefinition) {\n                  return featureDefinition(parser, runtime, tokens);\n              }\n          });\n\n          this.addGrammarElement(\"command\", function (parser:Parser, runtime:Runtime, tokens:Tokens):ASTNode {\n              if (tokens.matchOpToken(\"(\")) {\n                  const commandElement = parser.requireElement(\"command\", tokens);\n                  tokens.requireOpToken(\")\");\n                  return commandElement;\n              }\n\n              var commandDefinition = parser.COMMANDS[tokens.currentToken().value || \"\"];\n              let commandElement;\n              if (commandDefinition) {\n                  commandElement = commandDefinition(parser, runtime, tokens);\n              } else if (tokens.currentToken().type === \"IDENTIFIER\") {\n                  commandElement = parser.parseElement(\"pseudoCommand\", tokens);\n              }\n              if (commandElement) {\n                  return parser.parseElement(\"indirectStatement\", tokens, commandElement);\n              }\n\n              return commandElement;\n          });\n\n          this.addGrammarElement(\"commandList\", function (parser:Parser, runtime:Runtime, tokens:Tokens):ASTNode {\n              var cmd = parser.parseElement(\"command\", tokens);\n              if (cmd) {\n                  tokens.matchToken(\"then\");\n                  const next = parser.parseElement(\"commandList\", tokens);\n                  if (next) cmd.next = next;\n                  return cmd;\n              }\n          });\n\n          this.addGrammarElement(\"leaf\", function (parser:Parser, runtime:Runtime, tokens:Tokens):ASTNode {\n              var result = parser.parseAnyOf(parser.LEAF_EXPRESSIONS, tokens);\n              // symbol is last so it doesn't consume any constants\n              if (result == null) {\n                  return parser.parseElement(\"symbol\", tokens);\n              }\n\n              return result;\n          });\n\n          this.addGrammarElement(\"indirectExpression\", function (parser:Parser, runtime:Runtime, tokens:Tokens, root:ASTNode):ASTNode {\n              for (var i = 0; i < parser.INDIRECT_EXPRESSIONS.length; i++) {\n                  var indirect = parser.INDIRECT_EXPRESSIONS[i];\n                  root.endToken = tokens.lastMatch();\n                  var result = parser.parseElement(indirect, tokens, root);\n                  if (result) {\n                      return result;\n                  }\n              }\n              return root;\n          });\n\n          this.addGrammarElement(\"indirectStatement\", function (parser:Parser, runtime:Runtime, tokens:Tokens, root:ASTNode):ASTNode {\n              if (tokens.matchToken(\"unless\")) {\n                  root.endToken = tokens.lastMatch();\n                  var conditional = parser.requireElement(\"expression\", tokens);\n                  var unless = {\n                      type: \"unlessStatementModifier\",\n                      args: [conditional],\n                      op: function (context, conditional) {\n                          if (conditional) {\n                              return this.next;\n                          } else {\n                              return root;\n                          }\n                      },\n                      execute: function (context) {\n                          return runtime.unifiedExec(this, context);\n                      },\n                  };\n                  root.parent = unless;\n                  return unless;\n              }\n              return root;\n          });\n\n          this.addGrammarElement(\"primaryExpression\", function (parser:Parser, runtime:Runtime, tokens:Tokens):ASTNode {\n              var leaf = parser.parseElement(\"leaf\", tokens);\n              if (leaf) {\n                  return parser.parseElement(\"indirectExpression\", tokens, leaf);\n              }\n              parser.raiseParseError(tokens, \"Unexpected value: \" + tokens.currentToken().value);\n          });\n      }\n\n      use (plugin):this {\n          plugin(this)\n          return this\n      }\n\n      /** @type {Object<string,ParseRule>} */\n      GRAMMAR:{ [Key:string]:ParseRule } = {};\n\n      /** @type {Object<string,ParseRule>} */\n      COMMANDS:{ [Key:string]:ParseRule } = {};\n\n      /** @type {Object<string,ParseRule>} */\n      FEATURES:{ [Key:string]:ParseRule } = {};\n\n      /** @type {string[]} */\n      LEAF_EXPRESSIONS:string[] = [];\n      /** @type {string[]} */\n      INDIRECT_EXPRESSIONS:string[] = [];\n\n      /**\n       * @param {*} parseElement\n       * @param {*} start\n       * @param {Tokens} tokens\n       */\n      initElt (parseElement:any, start:any, tokens:Tokens):void {\n          parseElement.startToken = start;\n          parseElement.sourceFor = Tokens.sourceFor;\n          parseElement.lineFor = Tokens.lineFor;\n          parseElement.programSource = tokens.source;\n      }\n\n      /**\n       * @param {string} type\n       * @param {Tokens} tokens\n       * @param {ASTNode?} root\n       * @returns {ASTNode}\n       */\n      parseElement (type:string, tokens:Tokens, root?:ASTNode):ASTNode {\n          var elementDefinition = this.GRAMMAR[type];\n          if (elementDefinition) {\n              var start = tokens.currentToken();\n              var parseElement = elementDefinition(this, this.runtime, tokens, root);\n              if (parseElement) {\n                  this.initElt(parseElement, start, tokens);\n                  parseElement.endToken = parseElement.endToken || tokens.lastMatch();\n                  var root = parseElement.root;\n                  while (root != null) {\n                      this.initElt(root, start, tokens);\n                      root = root.root;\n                  }\n              }\n              return parseElement;\n          }\n      }\n\n      /**\n       * @param {string} type\n       * @param {Tokens} tokens\n       * @param {string} [message]\n       * @param {*} [root]\n       * @returns {ASTNode}\n       */\n      requireElement (type:string, tokens:Tokens, message?:string, root?:any):ASTNode {\n          var result = this.parseElement(type, tokens, root);\n          if (!result) Parser.raiseParseError(tokens, message || \"Expected \" + type);\n          // @ts-ignore\n          return result;\n      }\n\n      /**\n       * @param {string[]} types\n       * @param {Tokens} tokens\n       * @returns {ASTNode}\n       */\n      parseAnyOf (types:string[], tokens:Tokens):ASTNode {\n          for (var i = 0; i < types.length; i++) {\n              var type = types[i];\n              var expression = this.parseElement(type, tokens);\n              if (expression) {\n                  return expression;\n              }\n          }\n      }\n\n      /**\n       * @param {string} name\n       * @param {ParseRule} definition\n       */\n      addGrammarElement (name:string, definition:ParseRule):void {\n          this.GRAMMAR[name] = definition;\n      }\n\n      /**\n       * @param {string} keyword\n       * @param {ParseRule} definition\n       */\n      addCommand (keyword:string, definition:ParseRule):void {\n          var commandGrammarType = keyword + \"Command\";\n          var commandDefinitionWrapper = function (parser, runtime, tokens) {\n              const commandElement = definition(parser, runtime, tokens);\n              if (commandElement) {\n                  commandElement.type = commandGrammarType;\n                  commandElement.execute = function (context) {\n                      context.meta.command = commandElement;\n                      return runtime.unifiedExec(this, context);\n                  };\n                  return commandElement;\n              }\n          };\n          this.GRAMMAR[commandGrammarType] = commandDefinitionWrapper;\n          this.COMMANDS[keyword] = commandDefinitionWrapper;\n      }\n\n      /**\n       * @param {string} keyword\n       * @param {ParseRule} definition\n       */\n      addFeature (keyword:string, definition:ParseRule):void {\n          var featureGrammarType = keyword + \"Feature\";\n\n          /** @type {ParseRule} */\n          var featureDefinitionWrapper = function (parser, runtime, tokens) {\n              var featureElement = definition(parser, runtime, tokens);\n              if (featureElement) {\n                  featureElement.isFeature = true;\n                  featureElement.keyword = keyword;\n                  featureElement.type = featureGrammarType;\n                  return featureElement;\n              }\n          };\n          this.GRAMMAR[featureGrammarType] = featureDefinitionWrapper;\n          this.FEATURES[keyword] = featureDefinitionWrapper;\n      }\n\n      /**\n       * @param {string} name\n       * @param {ParseRule} definition\n       */\n      addLeafExpression (name:string, definition:ParseRule):void {\n          this.LEAF_EXPRESSIONS.push(name);\n          this.addGrammarElement(name, definition);\n      }\n\n      /**\n       * @param {string} name\n       * @param {ParseRule} definition\n       */\n      addIndirectExpression (name:string, definition:ParseRule):void {\n          this.INDIRECT_EXPRESSIONS.push(name);\n          this.addGrammarElement(name, definition);\n      }\n\n      /**\n       *\n       * @param {Tokens} tokens\n       * @returns string\n       */\n      static createParserContext (tokens:Tokens):string {\n          var currentToken = tokens.currentToken();\n          var source = tokens.source;\n          var lines = source.split(\"\\n\");\n          var line = currentToken && currentToken.line ? currentToken.line - 1 : lines.length - 1;\n          var contextLine = lines[line];\n          var offset = /** @type {number} */ (\n              currentToken && currentToken.line ? currentToken.column : contextLine.length - 1);\n          return contextLine + \"\\n\" + \" \".repeat(offset) + \"^^\\n\\n\";\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @param {string} [message]\n       * @returns {never}\n       */\n      static raiseParseError (tokens:Tokens, message?:string):never {\n          message =\n              (message || \"Unexpected Token : \" + tokens.currentToken().value) + \"\\n\\n\" + Parser.createParserContext(tokens);\n          var error = new Error(message);\n          error[\"tokens\"] = tokens;\n          throw error;\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @param {string} [message]\n       */\n      raiseParseError (tokens:Tokens, message?:string):void {\n          Parser.raiseParseError(tokens, message)\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @returns {ASTNode}\n       */\n      parseHyperScript (tokens:Tokens):ASTNode {\n          var result = this.parseElement(\"hyperscript\", tokens);\n          if (tokens.hasMore()) this.raiseParseError(tokens);\n          if (result) return result;\n      }\n\n      /**\n       * @param {ASTNode | undefined} elt\n       * @param {ASTNode} parent\n       */\n      setParent (elt:ASTNode | undefined, parent:ASTNode):void {\n          if (typeof elt === 'object') {\n              elt.parent = parent;\n              if (typeof parent === 'object') {\n                  parent.children = (parent.children || new Set());\n                  parent.children.add(elt)\n              }\n              this.setParent(elt.next, parent);\n          }\n      }\n\n      /**\n       * @param {Token} token\n       * @returns {ParseRule}\n       */\n      commandStart (token:Token):ParseRule {\n          return this.COMMANDS[token.value || \"\"];\n      }\n\n      /**\n       * @param {Token} token\n       * @returns {ParseRule}\n       */\n      featureStart (token:Token):ParseRule {\n          return this.FEATURES[token.value || \"\"];\n      }\n\n      /**\n       * @param {Token} token\n       * @returns {boolean}\n       */\n      commandBoundary (token:Token):boolean {\n          if (\n              token.value == \"end\" ||\n              token.value == \"then\" ||\n              token.value == \"else\" ||\n              token.value == \"otherwise\" ||\n              token.value == \")\" ||\n              this.commandStart(token) ||\n              this.featureStart(token) ||\n              token.type == \"EOF\"\n          ) {\n              return true;\n          }\n          return false;\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @returns {(string | ASTNode)[]}\n       */\n      parseStringTemplate (tokens:Tokens):(string|ASTNode)[] {\n          /** @type {(string | ASTNode)[]} */\n          var returnArr:(string | ASTNode)[] = [\"\"];\n          do {\n              returnArr.push(tokens.lastWhitespace());\n              if (tokens.currentToken().value === \"$\") {\n                  tokens.consumeToken();\n                  var startingBrace = tokens.matchOpToken(\"{\");\n                  returnArr.push(this.requireElement(\"expression\", tokens));\n                  if (startingBrace) {\n                      tokens.requireOpToken(\"}\");\n                  }\n                  returnArr.push(\"\");\n              } else if (tokens.currentToken().value === \"\\\\\") {\n                  tokens.consumeToken(); // skip next\n                  tokens.consumeToken();\n              } else {\n                  var token = tokens.consumeToken();\n                  returnArr[returnArr.length - 1] += token ? token.value : \"\";\n              }\n          } while (tokens.hasMore());\n          returnArr.push(tokens.lastWhitespace());\n          return returnArr;\n      }\n\n      /**\n       * @param {ASTNode} commandList\n       */\n      ensureTerminated (commandList:ASTNode):void {\n          const runtime = this.runtime\n          var implicitReturn = {\n              type: \"implicitReturn\",\n              op: function (context) {\n                  context.meta.returned = true;\n                  if (context.meta.resolve) {\n                      context.meta.resolve();\n                  }\n                  return runtime.HALT;\n              },\n              execute: function (ctx) {\n                  // do nothing\n              },\n          };\n\n          var end = commandList;\n          while (end.next) {\n              end = end.next;\n          }\n          end.next = implicitReturn;\n      }\n  }\n\n  class Runtime {\n    public lexer:Lexer\n    public parser:Parser\n\n      /**\n       *\n       * @param {Lexer} [lexer]\n       * @param {Parser} [parser]\n       */\n      constructor(lexer?:Lexer, parser?:Parser) {\n          this.lexer = lexer ?? new Lexer;\n          this.parser = parser ?? new Parser(this)\n              .use(hyperscriptCoreGrammar)\n              .use(hyperscriptWebGrammar);\n          this.parser.runtime = this\n      }\n\n      /**\n       * @param {HTMLElement} elt\n       * @param {string} selector\n       * @returns boolean\n       */\n      matchesSelector(elt:HTMLElement, selector:string):boolean {\n          // noinspection JSUnresolvedVariable\n          var matchesFunction =\n              // @ts-ignore\n              elt.matches || elt.matchesSelector || elt.msMatchesSelector || elt.mozMatchesSelector || elt.webkitMatchesSelector || elt.oMatchesSelector;\n          return matchesFunction && matchesFunction.call(elt, selector);\n      }\n\n      /**\n       * @param {string} eventName\n       * @param {Object} [detail]\n       * @returns {Event}\n       */\n      makeEvent(eventName:string, detail?:object):Event {\n          var evt;\n          if (globalScope.Event && typeof globalScope.Event === \"function\") {\n              evt = new Event(eventName, {\n                  bubbles: true,\n                  cancelable: true,\n              });\n              evt['detail'] = detail;\n          } else {\n              evt = document.createEvent(\"CustomEvent\");\n              evt.initCustomEvent(eventName, true, true, detail);\n          }\n          return evt;\n      }\n\n      /**\n       * @param {Element} elt\n       * @param {string} eventName\n       * @param {Object} [detail]\n       * @param {Element} [sender]\n       * @returns {boolean}\n       */\n      triggerEvent(elt:Element, eventName:string, detail?:object, sender?:Element):boolean {\n          detail = detail || {};\n          detail[\"sender\"] = sender;\n          var event = this.makeEvent(eventName, detail);\n          var eventResult = elt.dispatchEvent(event);\n          return eventResult;\n      }\n\n      /**\n       * isArrayLike returns `true` if the provided value is an array or\n       * a NodeList (which is close enough to being an array for our purposes).\n       *\n       * @param {any} value\n       * @returns {value is Array | NodeList}\n       */\n      isArrayLike (value:any):boolean {\n          return Array.isArray(value) ||\n              (typeof NodeList !== 'undefined' && (value instanceof NodeList || value instanceof HTMLCollection));\n      }\n\n      /**\n       * isIterable returns `true` if the provided value supports the\n       * iterator protocol.\n       *\n       * @param {any} value\n       * @returns {value is Iterable}\n       */\n      isIterable (value:any):boolean {\n          return typeof value === 'object'\n              && Symbol.iterator in value\n              && typeof value[Symbol.iterator] === 'function';\n      }\n\n      /**\n       * shouldAutoIterate returns `true` if the provided value\n       * should be implicitly iterated over when accessing properties,\n       * and as the target of some commands.\n       *\n       * Currently, this is when the value is an {ElementCollection}\n       * or {isArrayLike} returns true.\n       *\n       * @param {any} value\n       * @returns {value is (any[] | ElementCollection)}\n       */\n      shouldAutoIterate (value:any):boolean {\n          return value != null && value[shouldAutoIterateSymbol] ||\n              this.isArrayLike(value);\n      }\n\n      /**\n       * forEach executes the provided `func` on every item in the `value` array.\n       * if `value` is a single item (and not an array) then `func` is simply called\n       * once.  If `value` is null, then no further actions are taken.\n       *\n       * @template T\n       * @param {T | Iterable<T>} value\n       * @param {(item: T) => void} func\n       */\n      forEach (value:any, func:any):void {\n          if (value == null) {\n              // do nothing\n          } else if (this.isIterable(value)) {\n              for (const nth of value) {\n                  func(nth);\n              }\n          } else if (this.isArrayLike(value)) {\n              for (var i = 0; i < value.length; i++) {\n                  func(value[i]);\n              }\n          } else {\n              func(value);\n          }\n      }\n\n      /**\n       * implicitLoop executes the provided `func` on:\n       * - every item of {value}, if {value} should be auto-iterated\n       *   (see {shouldAutoIterate})\n       * - {value} otherwise\n       *\n       * @template T\n       * @param {ElementCollection | T | T[]} value\n       * @param {(item: T) => void} func\n       */\n      implicitLoop (value:any, func:any):void {\n          if (this.shouldAutoIterate(value)) {\n              for (const x of value) func(x);\n          } else {\n              func(value);\n          }\n      }\n\n      wrapArrays (args:any[]):any[] {\n          var arr = [];\n          for (var i = 0; i < args.length; i++) {\n              var arg = args[i];\n              if (Array.isArray(arg)) {\n                  arr.push(Promise.all(arg));\n              } else {\n                  arr.push(arg);\n              }\n          }\n          return arr;\n      }\n\n      unwrapAsyncs (values:any[]):void {\n          for (var i = 0; i < values.length; i++) {\n              var value = values[i];\n              if (value.asyncWrapper) {\n                  values[i] = value.value;\n              }\n              if (Array.isArray(value)) {\n                  for (var j = 0; j < value.length; j++) {\n                      var valueElement = value[j];\n                      if (valueElement.asyncWrapper) {\n                          value[j] = valueElement.value;\n                      }\n                  }\n              }\n          }\n      }\n\n      static HALT:{} = {};\n      HALT = Runtime.HALT;\n\n      /**\n       * @param {ASTNode} command\n       * @param {Context} ctx\n       */\n      unifiedExec (command:ASTNode, ctx:Context):void {\n          while (true) {\n              try {\n                  var next = this.unifiedEval(command, ctx);\n              } catch (e) {\n                  if (ctx.meta.handlingFinally) {\n                      console.error(\" Exception in finally block: \", e);\n                      next = Runtime.HALT;\n                  } else {\n                      this.registerHyperTrace(ctx, e);\n                      if (ctx.meta.errorHandler && !ctx.meta.handlingError) {\n                          ctx.meta.handlingError = true;\n                          ctx.locals[ctx.meta.errorSymbol] = e;\n                          command = ctx.meta.errorHandler;\n                          continue;\n                      } else  {\n                          ctx.meta.currentException = e;\n                          next = Runtime.HALT;\n                      }\n                  }\n              }\n              if (next == null) {\n                  console.error(command, \" did not return a next element to execute! context: \", ctx);\n                  return;\n              } else if (next.then) {\n                  next.then(resolvedNext => {\n                      this.unifiedExec(resolvedNext, ctx);\n                  }).catch(reason => {\n                      this.unifiedExec({ // Anonymous command to simply throw the exception\n                          op: function(){\n                              throw reason;\n                          }\n                      }, ctx);\n                  });\n                  return;\n              } else if (next === Runtime.HALT) {\n                  if (ctx.meta.finallyHandler && !ctx.meta.handlingFinally) {\n                      ctx.meta.handlingFinally = true;\n                      command = ctx.meta.finallyHandler;\n                  } else {\n                      if (ctx.meta.onHalt) {\n                          ctx.meta.onHalt();\n                      }\n                      if (ctx.meta.currentException) {\n                          if (ctx.meta.reject) {\n                              ctx.meta.reject(ctx.meta.currentException);\n                              return;\n                          } else {\n                              throw ctx.meta.currentException;\n                          }\n                      } else {\n                          return;\n                      }\n                  }\n              } else {\n                  command = next; // move to the next command\n              }\n          }\n      }\n\n      /**\n      * @param {*} parseElement\n      * @param {Context} ctx\n      * @returns {*}\n      */\n      unifiedEval(parseElement:any, ctx:Context):any {\n          /** @type any[] */\n          var args:any[] = [ctx];\n          var async:boolean = false;\n          var wrappedAsyncs:boolean = false;\n\n          if (parseElement.args) {\n              for (var i = 0; i < parseElement.args.length; i++) {\n                  var argument = parseElement.args[i];\n                  if (argument == null) {\n                      args.push(null);\n                  } else if (Array.isArray(argument)) {\n                      var arr = [];\n                      for (var j = 0; j < argument.length; j++) {\n                          var element = argument[j];\n                          var value = element ? element.evaluate(ctx) : null; // OK\n                          if (value) {\n                              if (value.then) {\n                                  async = true;\n                              } else if (value.asyncWrapper) {\n                                  wrappedAsyncs = true;\n                              }\n                          }\n                          arr.push(value);\n                      }\n                      args.push(arr);\n                  } else if (argument.evaluate) {\n                      var value = argument.evaluate(ctx); // OK\n                      if (value) {\n                          if (value.then) {\n                              async = true;\n                          } else if (value.asyncWrapper) {\n                              wrappedAsyncs = true;\n                          }\n                      }\n                      args.push(value);\n                  } else {\n                      args.push(argument);\n                  }\n              }\n          }\n          if (async) {\n              return new Promise((resolve, reject) => {\n                  args = this.wrapArrays(args);\n                  Promise.all(args)\n                      .then(function (values) {\n                          if (wrappedAsyncs) {\n                              this.unwrapAsyncs(values);\n                          }\n                          try {\n                              var apply = parseElement.op.apply(parseElement, values);\n                              resolve(apply);\n                          } catch (e) {\n                              reject(e);\n                          }\n                      })\n                      .catch(function (reason) {\n                          reject(reason);\n                      });\n              });\n          } else {\n              if (wrappedAsyncs) {\n                  this.unwrapAsyncs(args);\n              }\n              return parseElement.op.apply(parseElement, args);\n          }\n      }\n\n      /**\n       * @type {string[] | null}\n       */\n      _scriptAttrs:string[] | null = null;\n\n      /**\n      * getAttributes returns the attribute name(s) to use when\n      * locating hyperscript scripts in a DOM element.  If no value\n      * has been configured, it defaults to config.attributes\n      * @returns string[]\n      */\n      getScriptAttributes ():string[] {\n          if (this._scriptAttrs == null) {\n              this._scriptAttrs = config.attributes.replace(/ /g, \"\").split(\",\");\n          }\n          return this._scriptAttrs;\n      }\n\n      /**\n      * @param {Element} elt\n      * @returns {string | null}\n      */\n      getScript (elt:Element):string | null {\n          for (var i = 0; i < this.getScriptAttributes().length; i++) {\n              var scriptAttribute = this.getScriptAttributes()[i];\n              if (elt.hasAttribute && elt.hasAttribute(scriptAttribute)) {\n                  return elt.getAttribute(scriptAttribute);\n              }\n          }\n          if (elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\") {\n              return elt.innerText;\n          }\n          return null;\n      }\n\n      hyperscriptFeaturesMap = new WeakMap\n\n      /**\n      * @param {*} elt\n      * @returns {Object}\n      */\n      getHyperscriptFeatures (elt:any):Object {\n          var hyperscriptFeatures = this.hyperscriptFeaturesMap.get(elt);\n          if (typeof hyperscriptFeatures === 'undefined') {\n              if (elt) {\n                  // in some rare cases, elt is null and this line crashes\n                  this.hyperscriptFeaturesMap.set(elt, hyperscriptFeatures = {});\n              }\n          }\n          return hyperscriptFeatures;\n      }\n\n      /**\n      * @param {Element} owner\n      * @param {Context} ctx\n      */\n      addFeatures(owner:Element, ctx:Context):void {\n          if (owner) {\n              Object.assign(ctx.locals, this.getHyperscriptFeatures(owner));\n              this.addFeatures(owner.parentElement, ctx);\n          }\n      }\n\n      /**\n      * @param {*} owner\n      * @param {*} feature\n      * @param {*} hyperscriptTarget\n      * @param {*} event\n      * @returns {Context}\n      */\n      makeContext (owner:any, feature:any, hyperscriptTarget:any, event:any):Context {\n          return new Context(owner, feature, hyperscriptTarget, event, this)\n      }\n\n      /**\n      * @returns string\n      */\n      getScriptSelector ():string {\n          return this.getScriptAttributes()\n              .map(function (attribute) {\n                  return \"[\" + attribute + \"]\";\n              })\n              .join(\", \");\n      }\n\n      /**\n      * @param {any} value\n      * @param {string} type\n      * @returns {any}\n      */\n      convertValue (value:any, type:string):any {\n          var dynamicResolvers = conversions.dynamicResolvers;\n          for (var i = 0; i < dynamicResolvers.length; i++) {\n              var dynamicResolver = dynamicResolvers[i];\n              var converted = dynamicResolver(type, value);\n              if (converted !== undefined) {\n                  return converted;\n              }\n          }\n\n          if (value == null) {\n              return null;\n          }\n          var converter = conversions[type];\n          if (converter) {\n              return converter(value);\n          }\n\n          throw \"Unknown conversion : \" + type;\n      }\n\n      /**\n      * @param {string} src\n      * @returns {ASTNode}\n      */\n      parse (src:string):ASTNode {\n          const lexer = this.lexer, parser = this.parser\n          var tokens = lexer.tokenize(src);\n          if (this.parser.commandStart(tokens.currentToken())) {\n              var commandList = parser.requireElement(\"commandList\", tokens);\n              if (tokens.hasMore()) parser.raiseParseError(tokens);\n              parser.ensureTerminated(commandList);\n              return commandList;\n          } else if (parser.featureStart(tokens.currentToken())) {\n              var hyperscript = parser.requireElement(\"hyperscript\", tokens);\n              if (tokens.hasMore()) parser.raiseParseError(tokens);\n              return hyperscript;\n          } else {\n              var expression = parser.requireElement(\"expression\", tokens);\n              if (tokens.hasMore()) parser.raiseParseError(tokens);\n              return expression;\n          }\n      }\n\n      /**\n       *\n       * @param {ASTNode} elt\n       * @param {Context} ctx\n       * @returns {any}\n       */\n      evaluateNoPromise (elt:ASTNode, ctx:Context):any {\n          let result = elt.evaluate(ctx);\n          if (result.next) {\n              throw new Error(Tokens.sourceFor.call(elt) + \" returned a Promise in a context that they are not allowed.\");\n          }\n          return result;\n      }\n\n      /**\n      * @param {string} src\n      * @param {Partial<Context>} [ctx]\n      * @param {Object} [args]\n      * @returns {any}\n      */\n      evaluate (src:string, ctx?:Context, args?:any):any {\n          class HyperscriptModule extends EventTarget {\n            public module:any \n\n              constructor (mod) {\n                  super();\n                  this.module = mod;\n              }\n              toString ():string {\n                  return this.module.id;\n              }\n          }\n\n          var body = 'document' in globalScope\n              ? globalScope.document.body\n              : new HyperscriptModule(args && args.module);\n          ctx = Object.assign(this.makeContext(body, null, body, null), ctx || {});\n          var element = this.parse(src);\n          if (element.execute) {\n              element.execute(ctx);\n              return ctx.result;\n          } else if (element.apply) {\n              element.apply(body, body, args);\n              return this.getHyperscriptFeatures(body);\n          } else {\n              return element.evaluate(ctx);\n          }\n      }\n\n      /**\n      * @param {HTMLElement} elt\n      */\n      processNode (elt:HTMLElement):void {\n          var selector = this.getScriptSelector();\n          if (this.matchesSelector(elt, selector)) {\n              this.initElement(elt, elt);\n          }\n          if (elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\") {\n              this.initElement(elt, document.body);\n          }\n          if (elt.querySelectorAll) {\n              this.forEach(elt.querySelectorAll(selector + \", [type='text/hyperscript']\"), elt => {\n                  this.initElement(elt, elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\" ? document.body : elt);\n              });\n          }\n      }\n\n      /**\n      * @param {Element} elt\n      * @param {Element} [target]\n      */\n      initElement (elt:Element, target:Element):void {\n          if (elt.closest && elt.closest(config.disableSelector)) {\n              return;\n          }\n          var internalData = this.getInternalData(elt);\n          if (!internalData.initialized) {\n              var src = this.getScript(elt);\n              if (src) {\n                  try {\n                      internalData.initialized = true;\n                      internalData.script = src;\n                      const lexer = this.lexer, parser = this.parser\n                      var tokens = lexer.tokenize(src);\n                      var hyperScript = parser.parseHyperScript(tokens);\n                      if (!hyperScript) return;\n                      hyperScript.apply(target || elt, elt);\n                      setTimeout(() => {\n                          this.triggerEvent(target || elt, \"load\", {\n                              hyperscript: true,\n                          });\n                      }, 1);\n                  } catch (e) {\n                      this.triggerEvent(elt, \"exception\", {\n                          error: e,\n                      });\n                      console.error(\n                          \"hyperscript errors were found on the following element:\",\n                          elt,\n                          \"\\n\\n\",\n                          e.message,\n                          e.stack\n                      );\n                  }\n              }\n          }\n      }\n\n      internalDataMap = new WeakMap\n\n      /**\n      * @param {Element} elt\n      * @returns {Object}\n      */\n      getInternalData (elt:Element):any {\n          var internalData = this.internalDataMap.get(elt);\n          if (typeof internalData === 'undefined') {\n              this.internalDataMap.set(elt, internalData = {});\n          }\n          return internalData;\n      }\n\n      /**\n      * @param {any} value\n      * @param {string} typeString\n      * @param {boolean} [nullOk]\n      * @returns {boolean}\n      */\n      typeCheck (value:any, typeString:string, nullOk:boolean):boolean {\n          if (value == null && nullOk) {\n              return true;\n          }\n          var typeName = Object.prototype.toString.call(value).slice(8, -1);\n          return typeName === typeString;\n      }\n\n      getElementScope (context:Context):any {\n          var elt = context.meta && context.meta.owner;\n          if (elt) {\n              var internalData = this.getInternalData(elt);\n              var scopeName = \"elementScope\";\n              if (context.meta.feature && context.meta.feature.behavior) {\n                  scopeName = context.meta.feature.behavior + \"Scope\";\n              }\n              var elementScope = getOrInitObject(internalData, scopeName);\n              return elementScope;\n          } else {\n              return {}; // no element, return empty scope\n          }\n      }\n\n      /**\n      * @param {string} str\n      * @returns {boolean}\n      */\n      isReservedWord (str:string):boolean {\n          return [\"meta\", \"it\", \"result\", \"locals\", \"event\", \"target\", \"detail\", \"sender\", \"body\"].includes(str)\n      }\n\n      /**\n      * @param {any} context\n      * @returns {boolean}\n      */\n      isHyperscriptContext (context:any):boolean {\n          return context instanceof Context;\n      }\n\n      /**\n      * @param {string} str\n      * @param {Context} context\n      * @returns {any}\n      */\n      resolveSymbol (str:string, context:Context, type:string):any {\n          if (str === \"me\" || str === \"my\" || str === \"I\") {\n              return context.me;\n          }\n          if (str === \"it\" || str === \"its\" || str === \"result\") {\n              return context.result;\n          }\n          if (str === \"you\" || str === \"your\" || str === \"yourself\") {\n              return context.you;\n          } else {\n              if (type === \"global\") {\n                  return globalScope[str];\n              } else if (type === \"element\") {\n                  var elementScope = this.getElementScope(context);\n                  return elementScope[str];\n              } else if (type === \"local\") {\n                  return context.locals[str];\n              } else {\n                  // meta scope (used for event conditionals)\n                  if (context.meta && context.meta.context) {\n                      var fromMetaContext = context.meta.context[str];\n                      if (typeof fromMetaContext !== \"undefined\") {\n                          return fromMetaContext;\n                      }\n                  }\n                  if (this.isHyperscriptContext(context) && !this.isReservedWord(str)) {\n                      // local scope\n                      var fromContext = context.locals[str];\n                  } else {\n                      // direct get from normal JS object or top-level of context\n                      var fromContext = context[str];\n                  }\n                  if (typeof fromContext !== \"undefined\") {\n                      return fromContext;\n                  } else {\n                      // element scope\n                      var elementScope = this.getElementScope(context);\n                      fromContext = elementScope[str];\n                      if (typeof fromContext !== \"undefined\") {\n                          return fromContext;\n                      } else {\n                          // global scope\n                          return globalScope[str];\n                      }\n                  }\n              }\n          }\n      }\n\n      setSymbol (str:string, context:Context, type:string, value:any):void {\n          if (type === \"global\") {\n              globalScope[str] = value;\n          } else if (type === \"element\") {\n              var elementScope = this.getElementScope(context);\n              elementScope[str] = value;\n          } else if (type === \"local\") {\n              context.locals[str] = value;\n          } else {\n              if (this.isHyperscriptContext(context) && !this.isReservedWord(str) && typeof context.locals[str] !== \"undefined\") {\n                  // local scope\n                  context.locals[str] = value;\n              } else {\n                  // element scope\n                  var elementScope = this.getElementScope(context);\n                  var fromContext = elementScope[str];\n                  if (typeof fromContext !== \"undefined\") {\n                      elementScope[str] = value;\n                  } else {\n                      if (this.isHyperscriptContext(context) && !this.isReservedWord(str)) {\n                          // local scope\n                          context.locals[str] = value;\n                      } else {\n                          // direct set on normal JS object or top-level of context\n                          context[str] = value;\n                      }\n                  }\n              }\n          }\n      }\n\n      /**\n      * @param {ASTNode} command\n      * @param {Context} context\n      * @returns {undefined | ASTNode}\n      */\n      findNext (command:ASTNode, context:Context):undefined | ASTNode {\n          if (command) {\n              if (command.resolveNext) {\n                  return command.resolveNext(context);\n              } else if (command.next) {\n                  return command.next;\n              } else {\n                  return this.findNext(command.parent, context);\n              }\n          }\n      }\n\n      /**\n      * @param {Object<string,any>} root\n      * @param {string} property\n      * @param {Getter} getter\n      * @returns {any}\n      *\n      * @callback Getter\n      * @param {Object<string,any>} root\n      * @param {string} property\n      */\n      flatGet(root, property, getter) {\n          if (root != null) {\n              var val = getter(root, property);\n              if (typeof val !== \"undefined\") {\n                  return val;\n              }\n\n              if (this.shouldAutoIterate(root)) {\n                  // flat map\n                  var result = [];\n                  for (var component of root) {\n                      var componentValue = getter(component, property);\n                      result.push(componentValue);\n                  }\n                  return result;\n              }\n          }\n      }\n\n      resolveProperty(root, property) {\n          return this.flatGet(root, property, (root, property) => root[property] )\n      }\n\n      resolveAttribute(root, property) {\n          return this.flatGet(root, property, (root, property) => root.getAttribute && root.getAttribute(property) )\n      }\n\n      /**\n       *\n       * @param {Object<string, any>} root\n       * @param {string} property\n       * @returns {string}\n       */\n      resolveStyle(root, property) {\n          return this.flatGet(root, property, (root, property) => root.style && root.style[property] )\n      }\n\n      /**\n       *\n       * @param {Object<string, any>} root\n       * @param {string} property\n       * @returns {string}\n       */\n      resolveComputedStyle(root, property) {\n          return this.flatGet(root, property, (root, property) => getComputedStyle(\n              /** @type {Element} */ (root)).getPropertyValue(property) )\n      }\n\n      /**\n      * @param {Element} elt\n      * @param {string[]} nameSpace\n      * @param {string} name\n      * @param {any} value\n      */\n      assignToNamespace(elt, nameSpace, name, value) {\n          let root\n          if (typeof document !== \"undefined\" && elt === document.body) {\n              root = globalScope;\n          } else {\n              root = this.getHyperscriptFeatures(elt);\n          }\n          var propertyName;\n          while ((propertyName = nameSpace.shift()) !== undefined) {\n              var newRoot = root[propertyName];\n              if (newRoot == null) {\n                  newRoot = {};\n                  root[propertyName] = newRoot;\n              }\n              root = newRoot;\n          }\n\n          root[name] = value;\n      }\n\n      getHyperTrace(ctx, thrown) {\n          var trace = [];\n          var root = ctx;\n          while (root.meta.caller) {\n              root = root.meta.caller;\n          }\n          if (root.meta.traceMap) {\n              return root.meta.traceMap.get(thrown, trace);\n          }\n      }\n\n      registerHyperTrace(ctx, thrown) {\n          var trace = [];\n          var root = null;\n          while (ctx != null) {\n              trace.push(ctx);\n              root = ctx;\n              ctx = ctx.meta.caller;\n          }\n          if (root.meta.traceMap == null) {\n              root.meta.traceMap = new Map(); // TODO - WeakMap?\n          }\n          if (!root.meta.traceMap.get(thrown)) {\n              var traceEntry = {\n                  trace: trace,\n                  print: function (logger) {\n                      logger = logger || console.error;\n                      logger(\"hypertrace /// \");\n                      var maxLen = 0;\n                      for (var i = 0; i < trace.length; i++) {\n                          maxLen = Math.max(maxLen, trace[i].meta.feature.displayName.length);\n                      }\n                      for (var i = 0; i < trace.length; i++) {\n                          var traceElt = trace[i];\n                          logger(\n                              \"  ->\",\n                              traceElt.meta.feature.displayName.padEnd(maxLen + 2),\n                              \"-\",\n                              traceElt.meta.owner\n                          );\n                      }\n                  },\n              };\n              root.meta.traceMap.set(thrown, traceEntry);\n          }\n      }\n\n      /**\n      * @param {string} str\n      * @returns {string}\n      */\n      escapeSelector(str) {\n          return str.replace(/:/g, function (str) {\n              return \"\\\\\" + str;\n          });\n      }\n\n      /**\n      * @param {any} value\n      * @param {*} elt\n      */\n      nullCheck(value, elt) {\n          if (value == null) {\n              throw new Error(\"'\" + elt.sourceFor() + \"' is null\");\n          }\n      }\n\n      /**\n      * @param {any} value\n      * @returns {boolean}\n      */\n      isEmpty(value) {\n          return value == undefined || value.length === 0;\n      }\n\n      /**\n      * @param {any} value\n      * @returns {boolean}\n      */\n      doesExist(value) {\n          if(value == null){\n              return false;\n          }\n          if (this.shouldAutoIterate(value)) {\n              for (const elt of value) {\n                  return true;\n              }\n          }\n          return false;\n      }\n\n      /**\n      * @param {Node} node\n      * @returns {Document|ShadowRoot}\n      */\n      getRootNode(node) {\n          if (node && node instanceof Node) {\n              var rv = node.getRootNode();\n              if (rv instanceof Document || rv instanceof ShadowRoot) return rv;\n          }\n          return document;\n      }\n\n      /**\n       *\n       * @param {Element} elt\n       * @param {ASTNode} onFeature\n       * @returns {EventQueue}\n       *\n       * @typedef {{queue:Array, executing:boolean}} EventQueue\n       */\n      getEventQueueFor(elt, onFeature) {\n          let internalData = this.getInternalData(elt);\n          var eventQueuesForElt = internalData.eventQueues;\n          if (eventQueuesForElt == null) {\n              eventQueuesForElt = new Map();\n              internalData.eventQueues = eventQueuesForElt;\n          }\n          var eventQueueForFeature = eventQueuesForElt.get(onFeature);\n          if (eventQueueForFeature == null) {\n              eventQueueForFeature = {queue:[], executing:false};\n              eventQueuesForElt.set(onFeature, eventQueueForFeature);\n          }\n          return eventQueueForFeature;\n      }\n\n      /** @type string | null */\n      // @ts-ignore\n      hyperscriptUrl = \"document\" in globalScope ? document.currentScript.src : null;\n  }\n\n  class Context {\n    public meta:any\n    public locals:Object\n    public me:any\n    public you:any \n    public result:any \n    public event:any\n    public target:any\n    public detail:any\n    public sender:any\n    public body:any\n\n      /**\n      * @param {*} owner\n      * @param {*} feature\n      * @param {*} hyperscriptTarget\n      * @param {*} event\n      */\n      constructor(owner, feature, hyperscriptTarget, event, runtime) {\n          this.meta = {\n              parser: runtime.parser,\n              lexer: runtime.lexer,\n              runtime,\n              owner: owner,\n              feature: feature,\n              iterators: {},\n              ctx: this\n          }\n          this.locals = {};\n          this.me = hyperscriptTarget,\n          this.you = undefined\n          this.result = undefined\n          this.event = event;\n          this.target = event ? event.target : null;\n          this.detail = event ? event.detail : null;\n          this.sender = event ? event.detail ? event.detail.sender : null : null;\n          this.body = \"document\" in globalScope ? document.body : null;\n          runtime.addFeatures(owner, this);\n      }\n  }\n\n  class ElementCollection {\n    public _css:any\n    public relativeToElement:any\n    public escape:any\n\n      constructor(css, relativeToElement, escape = undefined) {\n          this._css = css;\n          this.relativeToElement = relativeToElement;\n          this.escape = escape;\n          this[shouldAutoIterateSymbol] = true;\n      }\n\n      get css() {\n          if (this.escape) {\n              return Runtime.prototype.escapeSelector(this._css);\n          } else {\n              return this._css;\n          }\n      }\n\n      get className() {\n          return this._css.substr(1);\n      }\n\n      get id() {\n          return this.className();\n      }\n\n      contains(elt) {\n          for (let element of this) {\n              if (element.contains(elt)) {\n                  return true;\n              }\n          }\n          return false;\n      }\n\n      get length() {\n          return this.selectMatches().length;\n      }\n\n      [Symbol.iterator]() {\n          let query = this.selectMatches();\n          return query [Symbol.iterator]();\n      }\n\n      selectMatches() {\n          let query = Runtime.prototype.getRootNode(this.relativeToElement).querySelectorAll(this.css);\n          return query;\n      }\n  }\n\n  const shouldAutoIterateSymbol = Symbol()\n\n  function getOrInitObject(root, prop) {\n      var value = root[prop];\n      if (value) {\n          return value;\n      } else {\n          var newObj = {};\n          root[prop] = newObj;\n          return newObj;\n      }\n  }\n\n  /**\n   * parseJSON parses a JSON string into a corresponding value.  If the\n   * value passed in is not valid JSON, then it logs an error and returns `null`.\n   *\n   * @param {string} jString\n   * @returns any\n   */\n  function parseJSON(jString) {\n      try {\n          return JSON.parse(jString);\n      } catch (error) {\n          logError(error);\n          return null;\n      }\n  }\n\n  /**\n   * logError writes an error message to the Javascript console.  It can take any\n   * value, but msg should commonly be a simple string.\n   * @param {*} msg\n   */\n  function logError(msg) {\n      if (console.error) {\n          console.error(msg);\n      } else if (console.log) {\n          console.log(\"ERROR: \", msg);\n      }\n  }\n\n  // TODO: JSDoc description of what's happening here\n  function varargConstructor(Cls, args) {\n      return new (Cls.bind.apply(Cls, [Cls].concat(args)))();\n  }\n\n  // Grammar\n\n  /**\n   * @param {Parser} parser\n   */\n  function hyperscriptCoreGrammar(parser) {\n      parser.addLeafExpression(\"parenthesized\", function (parser, _runtime, tokens) {\n          if (tokens.matchOpToken(\"(\")) {\n              var follows = tokens.clearFollows();\n              try {\n                  var expr = parser.requireElement(\"expression\", tokens);\n              } finally {\n                  tokens.restoreFollows(follows);\n              }\n              tokens.requireOpToken(\")\");\n              return expr;\n          }\n      });\n\n      parser.addLeafExpression(\"string\", function (parser, runtime, tokens) {\n          var stringToken = tokens.matchTokenType(\"STRING\");\n          if (!stringToken) return;\n          var rawValue = /** @type {string} */ (stringToken.value);\n          /** @type {any[]} */\n          var args;\n          if (stringToken.template) {\n              var innerTokens = Lexer.tokenize(rawValue, true);\n              args = parser.parseStringTemplate(innerTokens);\n          } else {\n              args = [];\n          }\n          return {\n              type: \"string\",\n              token: stringToken,\n              args: args,\n              op: function (context) {\n                  var returnStr = \"\";\n                  for (var i = 1; i < arguments.length; i++) {\n                      var val = arguments[i];\n                      if (val !== undefined) {\n                          returnStr += val;\n                      }\n                  }\n                  return returnStr;\n              },\n              evaluate: function (context) {\n                  if (args.length === 0) {\n                      return rawValue;\n                  } else {\n                      return runtime.unifiedEval(this, context);\n                  }\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"nakedString\", function (parser, runtime, tokens) {\n          if (tokens.hasMore()) {\n              var tokenArr = tokens.consumeUntilWhitespace();\n              tokens.matchTokenType(\"WHITESPACE\");\n              return {\n                  type: \"nakedString\",\n                  tokens: tokenArr,\n                  evaluate: function (context) {\n                      return tokenArr\n                          .map(function (t) {\n                              return t.value;\n                          })\n                          .join(\"\");\n                  },\n              };\n          }\n      });\n\n      parser.addLeafExpression(\"number\", function (parser, runtime, tokens) {\n          var number = tokens.matchTokenType(\"NUMBER\");\n          if (!number) return;\n          var numberToken = number;\n          var value = parseFloat(/** @type {string} */ (number.value));\n          return {\n              type: \"number\",\n              value: value,\n              numberToken: numberToken,\n              evaluate: function () {\n                  return value;\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"idRef\", function (parser, runtime, tokens) {\n          var elementId = tokens.matchTokenType(\"ID_REF\");\n          if (!elementId) return;\n          if (!elementId.value) return;\n          // TODO - unify these two expression types\n          if (elementId.template) {\n              var templateValue = elementId.value.substring(2);\n              var innerTokens = Lexer.tokenize(templateValue);\n              var innerExpression = parser.requireElement(\"expression\", innerTokens);\n              return {\n                  type: \"idRefTemplate\",\n                  args: [innerExpression],\n                  op: function (context, arg) {\n                      return runtime.getRootNode(context.me).getElementById(arg);\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              const value = elementId.value.substring(1);\n              return {\n                  type: \"idRef\",\n                  css: elementId.value,\n                  value: value,\n                  evaluate: function (context) {\n                      return (\n                          runtime.getRootNode(context.me).getElementById(value)\n                      );\n                  },\n              };\n          }\n      });\n\n      parser.addLeafExpression(\"classRef\", function (parser, runtime, tokens) {\n          var classRef = tokens.matchTokenType(\"CLASS_REF\");\n\n          if (!classRef) return;\n          if (!classRef.value) return;\n\n          // TODO - unify these two expression types\n          if (classRef.template) {\n              var templateValue = classRef.value.substring(2);\n              var innerTokens = Lexer.tokenize(templateValue);\n              var innerExpression = parser.requireElement(\"expression\", innerTokens);\n              return {\n                  type: \"classRefTemplate\",\n                  args: [innerExpression],\n                  op: function (context, arg) {\n                      return new ElementCollection(\".\" + arg, context.me, true)\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              const css = classRef.value;\n              return {\n                  type: \"classRef\",\n                  css: css,\n                  evaluate: function (context) {\n                      return new ElementCollection(css, context.me, true)\n                  },\n              };\n          }\n      });\n\n      class TemplatedQueryElementCollection extends ElementCollection {\n        public templateParts:any[]\n        public elements:any[]\n\n          constructor(css, relativeToElement, templateParts) {\n              super(css, relativeToElement);\n              this.templateParts = templateParts;\n              this.elements = templateParts.filter(elt => elt instanceof Element);\n          }\n\n          get css() {\n              let rv = \"\", i = 0\n              for (const val of this.templateParts) {\n                  if (val instanceof Element) {\n                      rv += \"[data-hs-query-id='\" + i++ + \"']\";\n                  } else rv += val;\n              }\n              return rv;\n          }\n\n          [Symbol.iterator]() {\n              this.elements.forEach((el, i) => el.dataset.hsQueryId = i);\n              const rv = super[Symbol.iterator]();\n              this.elements.forEach(el => el.removeAttribute('data-hs-query-id'));\n              return rv;\n          }\n      }\n\n      parser.addLeafExpression(\"queryRef\", function (parser, runtime, tokens) {\n          var queryStart = tokens.matchOpToken(\"<\");\n          if (!queryStart) return;\n          var queryTokens = tokens.consumeUntil(\"/\");\n          tokens.requireOpToken(\"/\");\n          tokens.requireOpToken(\">\");\n          var queryValue = queryTokens\n              .map(function (t) {\n                  if (t.type === \"STRING\") {\n                      return '\"' + t.value + '\"';\n                  } else {\n                      return t.value;\n                  }\n              })\n              .join(\"\");\n\n          var template, innerTokens, args;\n          if (queryValue.indexOf(\"$\") >= 0) {\n              template = true;\n              innerTokens = Lexer.tokenize(queryValue, true);\n              args = parser.parseStringTemplate(innerTokens);\n          }\n\n          return {\n              type: \"queryRef\",\n              css: queryValue,\n              args: args,\n              op: function (context, ...args) {\n                  if (template) {\n                      return new TemplatedQueryElementCollection(queryValue, context.me, args)\n                  } else {\n                      return new ElementCollection(queryValue, context.me)\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"attributeRef\", function (parser, runtime, tokens) {\n          var attributeRef = tokens.matchTokenType(\"ATTRIBUTE_REF\");\n          if (!attributeRef) return;\n          if (!attributeRef.value) return;\n          var outerVal = attributeRef.value;\n          if (outerVal.indexOf(\"[\") === 0) {\n              var innerValue = outerVal.substring(2, outerVal.length - 1);\n          } else {\n              var innerValue = outerVal.substring(1);\n          }\n          var css = \"[\" + innerValue + \"]\";\n          var split = innerValue.split(\"=\");\n          var name = split[0];\n          var value = split[1];\n          if (value) {\n              // strip quotes\n              if (value.indexOf('\"') === 0) {\n                  value = value.substring(1, value.length - 1);\n              }\n          }\n          return {\n              type: \"attributeRef\",\n              name: name,\n              css: css,\n              value: value,\n              op: function (context) {\n                  var target = context.you || context.me;\n                  if (target) {\n                      return target.getAttribute(name);\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"styleRef\", function (parser, runtime, tokens) {\n          var styleRef = tokens.matchTokenType(\"STYLE_REF\");\n          if (!styleRef) return;\n          if (!styleRef.value) return;\n          var styleProp = styleRef.value.substr(1);\n          if (styleProp.startsWith(\"computed-\")) {\n              styleProp = styleProp.substr(\"computed-\".length);\n              return {\n                  type: \"computedStyleRef\",\n                  name: styleProp,\n                  op: function (context) {\n                      var target = context.you || context.me;\n                      if (target) {\n                          return runtime.resolveComputedStyle(target, styleProp);\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              return {\n                  type: \"styleRef\",\n                  name: styleProp,\n                  op: function (context) {\n                      var target = context.you || context.me;\n                      if (target) {\n                          return runtime.resolveStyle(target, styleProp);\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n      });\n\n      parser.addGrammarElement(\"objectKey\", function (parser, runtime, tokens) {\n          var token;\n          if ((token = tokens.matchTokenType(\"STRING\"))) {\n              return {\n                  type: \"objectKey\",\n                  key: token.value,\n                  evaluate: function () {\n                      return token.value;\n                  },\n              };\n          } else if (tokens.matchOpToken(\"[\")) {\n              var expr = parser.parseElement(\"expression\", tokens);\n              tokens.requireOpToken(\"]\");\n              return {\n                  type: \"objectKey\",\n                  expr: expr,\n                  args: [expr],\n                  op: function (ctx, expr) {\n                      return expr;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              var key = \"\";\n              do {\n                  token = tokens.matchTokenType(\"IDENTIFIER\") || tokens.matchOpToken(\"-\");\n                  if (token) key += token.value;\n              } while (token);\n              return {\n                  type: \"objectKey\",\n                  key: key,\n                  evaluate: function () {\n                      return key;\n                  },\n              };\n          }\n      });\n\n      parser.addLeafExpression(\"objectLiteral\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"{\")) return;\n          var keyExpressions = [];\n          var valueExpressions = [];\n          if (!tokens.matchOpToken(\"}\")) {\n              do {\n                  var name = parser.requireElement(\"objectKey\", tokens);\n                  tokens.requireOpToken(\":\");\n                  var value = parser.requireElement(\"expression\", tokens);\n                  valueExpressions.push(value);\n                  keyExpressions.push(name);\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\"}\");\n          }\n          return {\n              type: \"objectLiteral\",\n              args: [keyExpressions, valueExpressions],\n              op: function (context, keys, values) {\n                  var returnVal = {};\n                  for (var i = 0; i < keys.length; i++) {\n                      returnVal[keys[i]] = values[i];\n                  }\n                  return returnVal;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"nakedNamedArgumentList\", function (parser, runtime, tokens) {\n          var fields = [];\n          var valueExpressions = [];\n          if (tokens.currentToken().type === \"IDENTIFIER\") {\n              do {\n                  var name = tokens.requireTokenType(\"IDENTIFIER\");\n                  tokens.requireOpToken(\":\");\n                  var value = parser.requireElement(\"expression\", tokens);\n                  valueExpressions.push(value);\n                  fields.push({ name: name, value: value });\n              } while (tokens.matchOpToken(\",\"));\n          }\n          return {\n              type: \"namedArgumentList\",\n              fields: fields,\n              args: [valueExpressions],\n              op: function (context, values) {\n                  var returnVal = { _namedArgList_: true };\n                  for (var i = 0; i < values.length; i++) {\n                      var field = fields[i];\n                      returnVal[field.name.value] = values[i];\n                  }\n                  return returnVal;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"namedArgumentList\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"(\")) return;\n          var elt = parser.requireElement(\"nakedNamedArgumentList\", tokens);\n          tokens.requireOpToken(\")\");\n          return elt;\n      });\n\n      parser.addGrammarElement(\"symbol\", function (parser, runtime, tokens) {\n          /** @scope {SymbolScope} */\n          var scope = \"default\";\n          if (tokens.matchToken(\"global\")) {\n              scope = \"global\";\n          } else if (tokens.matchToken(\"element\") || tokens.matchToken(\"module\")) {\n              scope = \"element\";\n              // optional possessive\n              if (tokens.matchOpToken(\"'\")) {\n                  tokens.requireToken(\"s\");\n              }\n          } else if (tokens.matchToken(\"local\")) {\n              scope = \"local\";\n          }\n\n          // TODO better look ahead here\n          let eltPrefix = tokens.matchOpToken(\":\");\n          let identifier = tokens.matchTokenType(\"IDENTIFIER\");\n          if (identifier && identifier.value) {\n              var name = identifier.value;\n              if (eltPrefix) {\n                  name = \":\" + name;\n              }\n              if (scope === \"default\") {\n                  if (name.indexOf(\"$\") === 0) {\n                      scope = \"global\";\n                  }\n                  if (name.indexOf(\":\") === 0) {\n                      scope = \"element\";\n                  }\n              }\n              return {\n                  type: \"symbol\",\n                  token: identifier,\n                  scope: scope,\n                  name: name,\n                  evaluate: function (context) {\n                      return runtime.resolveSymbol(name, context, scope);\n                  },\n              };\n          }\n      });\n\n      parser.addGrammarElement(\"implicitMeTarget\", function (parser, runtime, tokens) {\n          return {\n              type: \"implicitMeTarget\",\n              evaluate: function (context) {\n                  return context.you || context.me;\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"boolean\", function (parser, runtime, tokens) {\n          var booleanLiteral = tokens.matchToken(\"true\") || tokens.matchToken(\"false\");\n          if (!booleanLiteral) return;\n          const value = booleanLiteral.value === \"true\";\n          return {\n              type: \"boolean\",\n              evaluate: function (context) {\n                  return value;\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"null\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"null\")) {\n              return {\n                  type: \"null\",\n                  evaluate: function (context) {\n                      return null;\n                  },\n              };\n          }\n      });\n\n      parser.addLeafExpression(\"arrayLiteral\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"[\")) return;\n          var values = [];\n          if (!tokens.matchOpToken(\"]\")) {\n              do {\n                  var expr = parser.requireElement(\"expression\", tokens);\n                  values.push(expr);\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\"]\");\n          }\n          return {\n              type: \"arrayLiteral\",\n              values: values,\n              args: [values],\n              op: function (context, values) {\n                  return values;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"blockLiteral\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"\\\\\")) return;\n          var args = [];\n          var arg1 = tokens.matchTokenType(\"IDENTIFIER\");\n          if (arg1) {\n              args.push(arg1);\n              while (tokens.matchOpToken(\",\")) {\n                  args.push(tokens.requireTokenType(\"IDENTIFIER\"));\n              }\n          }\n          // TODO compound op token\n          tokens.requireOpToken(\"-\");\n          tokens.requireOpToken(\">\");\n          var expr = parser.requireElement(\"expression\", tokens);\n          return {\n              type: \"blockLiteral\",\n              args: args,\n              expr: expr,\n              evaluate: function (ctx) {\n                  var returnFunc = function () {\n                      //TODO - push scope\n                      for (var i = 0; i < args.length; i++) {\n                          ctx.locals[args[i].value] = arguments[i];\n                      }\n                      return expr.evaluate(ctx); //OK\n                  };\n                  return returnFunc;\n              },\n          };\n      });\n\n      parser.addIndirectExpression(\"propertyAccess\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchOpToken(\".\")) return;\n          var prop = tokens.requireTokenType(\"IDENTIFIER\");\n          var propertyAccess = {\n              type: \"propertyAccess\",\n              root: root,\n              prop: prop,\n              args: [root],\n              op: function (_context, rootVal) {\n                  var value = runtime.resolveProperty(rootVal, prop.value);\n                  return value;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n          return parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n      });\n\n      parser.addIndirectExpression(\"of\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchToken(\"of\")) return;\n          var newRoot = parser.requireElement(\"unaryExpression\", tokens);\n          // find the urroot\n          var childOfUrRoot = null;\n          var urRoot = root;\n          while (urRoot.root) {\n              childOfUrRoot = urRoot;\n              urRoot = urRoot.root;\n          }\n          if (urRoot.type !== \"symbol\" && urRoot.type !== \"attributeRef\" && urRoot.type !== \"styleRef\" && urRoot.type !== \"computedStyleRef\") {\n              parser.raiseParseError(tokens, \"Cannot take a property of a non-symbol: \" + urRoot.type);\n          }\n          var attribute = urRoot.type === \"attributeRef\";\n          var style = urRoot.type === \"styleRef\" || urRoot.type === \"computedStyleRef\";\n          if (attribute || style) {\n              var attributeElt = urRoot\n          }\n          var prop = urRoot.name;\n\n          var propertyAccess = {\n              type: \"ofExpression\",\n              prop: urRoot.token,\n              root: newRoot,\n              attribute: attributeElt,\n              expression: root,\n              args: [newRoot],\n              op: function (context, rootVal) {\n                  if (attribute) {\n                      return runtime.resolveAttribute(rootVal, prop);\n                  } else if (style) {\n                      if (urRoot.type === \"computedStyleRef\") {\n                          return runtime.resolveComputedStyle(rootVal, prop);\n                      } else {\n                          return runtime.resolveStyle(rootVal, prop);\n                      }\n                  } else {\n                      return runtime.resolveProperty(rootVal, prop);\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n\n          if (urRoot.type === \"attributeRef\") {\n              propertyAccess.attribute = urRoot;\n          }\n          if (childOfUrRoot) {\n              childOfUrRoot.root = propertyAccess;\n              childOfUrRoot.args = [propertyAccess];\n          } else {\n              root = propertyAccess;\n          }\n\n          return parser.parseElement(\"indirectExpression\", tokens, root);\n      });\n\n      parser.addIndirectExpression(\"possessive\", function (parser, runtime, tokens, root) {\n          if (parser.possessivesDisabled) {\n              return;\n          }\n          var apostrophe = tokens.matchOpToken(\"'\");\n          if (\n              apostrophe ||\n              (root.type === \"symbol\" &&\n                  (root.name === \"my\" || root.name === \"its\" || root.name === \"your\") &&\n                  (tokens.currentToken().type === \"IDENTIFIER\" || tokens.currentToken().type === \"ATTRIBUTE_REF\" || tokens.currentToken().type === \"STYLE_REF\"))\n          ) {\n              if (apostrophe) {\n                  tokens.requireToken(\"s\");\n              }\n\n              var attribute, style, prop;\n              attribute = parser.parseElement(\"attributeRef\", tokens);\n              if (attribute == null) {\n                  style = parser.parseElement(\"styleRef\", tokens);\n                  if (style == null) {\n                      prop = tokens.requireTokenType(\"IDENTIFIER\");\n                  }\n              }\n              var propertyAccess = {\n                  type: \"possessive\",\n                  root: root,\n                  attribute: attribute || style,\n                  prop: prop,\n                  args: [root],\n                  op: function (context, rootVal) {\n                      if (attribute) {\n                          // @ts-ignore\n                          var value = runtime.resolveAttribute(rootVal, attribute.name);\n                      } else if (style) {\n                          var value\n                          if (style.type === 'computedStyleRef') {\n                              value = runtime.resolveComputedStyle(rootVal, style['name']);\n                          } else {\n                              value = runtime.resolveStyle(rootVal, style['name']);\n                          }\n                      } else {\n                          var value = runtime.resolveProperty(rootVal, prop.value);\n                      }\n                      return value;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n              return parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n          }\n      });\n\n      parser.addIndirectExpression(\"inExpression\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchToken(\"in\")) return;\n          var target = parser.requireElement(\"unaryExpression\", tokens);\n          var propertyAccess = {\n              type: \"inExpression\",\n              root: root,\n              args: [root, target],\n              op: function (context, rootVal, target) {\n                  var returnArr = [];\n                  if (rootVal.css) {\n                      runtime.implicitLoop(target, function (targetElt) {\n                          var results = targetElt.querySelectorAll(rootVal.css);\n                          for (var i = 0; i < results.length; i++) {\n                              returnArr.push(results[i]);\n                          }\n                      });\n                  } else if (rootVal instanceof Element) {\n                      var within = false;\n                      runtime.implicitLoop(target, function (targetElt) {\n                          if (targetElt.contains(rootVal)) {\n                              within = true;\n                          }\n                      });\n                      if(within) {\n                          return rootVal;\n                      }\n                  } else {\n                      runtime.implicitLoop(rootVal, function (rootElt) {\n                          runtime.implicitLoop(target, function (targetElt) {\n                              if (rootElt === targetElt) {\n                                  returnArr.push(rootElt);\n                              }\n                          });\n                      });\n                  }\n                  return returnArr;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n          return parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n      });\n\n      parser.addIndirectExpression(\"asExpression\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchToken(\"as\")) return;\n          tokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n          var conversion = parser.requireElement(\"dotOrColonPath\", tokens).evaluate(); // OK No promise\n          var propertyAccess = {\n              type: \"asExpression\",\n              root: root,\n              args: [root],\n              op: function (context, rootVal) {\n                  return runtime.convertValue(rootVal, conversion);\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n          return parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n      });\n\n      parser.addIndirectExpression(\"functionCall\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchOpToken(\"(\")) return;\n          var args = [];\n          if (!tokens.matchOpToken(\")\")) {\n              do {\n                  args.push(parser.requireElement(\"expression\", tokens));\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\")\");\n          }\n\n          if (root.root) {\n              var functionCall = {\n                  type: \"functionCall\",\n                  root: root,\n                  argExressions: args,\n                  args: [root.root, args],\n                  op: function (context, rootRoot, args) {\n                      runtime.nullCheck(rootRoot, root.root);\n                      var func = rootRoot[root.prop.value];\n                      runtime.nullCheck(func, root);\n                      if (func.hyperfunc) {\n                          args.push(context);\n                      }\n                      return func.apply(rootRoot, args);\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              var functionCall = {\n                  type: \"functionCall\",\n                  root: root,\n                  argExressions: args,\n                  args: [root, args],\n                  op: function (context, func, argVals) {\n                      runtime.nullCheck(func, root);\n                      if (func.hyperfunc) {\n                          argVals.push(context);\n                      }\n                      var apply = func.apply(null, argVals);\n                      return apply;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n          return parser.parseElement(\"indirectExpression\", tokens, functionCall);\n      });\n\n      parser.addIndirectExpression(\"attributeRefAccess\", function (parser, runtime, tokens, root) {\n          var attribute = parser.parseElement(\"attributeRef\", tokens);\n          if (!attribute) return;\n          var attributeAccess = {\n              type: \"attributeRefAccess\",\n              root: root,\n              attribute: attribute,\n              args: [root],\n              op: function (_ctx, rootVal) {\n                  // @ts-ignore\n                  var value = runtime.resolveAttribute(rootVal, attribute.name);\n                  return value;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n          return attributeAccess;\n      });\n\n      parser.addIndirectExpression(\"arrayIndex\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchOpToken(\"[\")) return;\n          var andBefore = false;\n          var andAfter = false;\n          var firstIndex = null;\n          var secondIndex = null;\n\n          if (tokens.matchOpToken(\"..\")) {\n              andBefore = true;\n              firstIndex = parser.requireElement(\"expression\", tokens);\n          } else {\n              firstIndex = parser.requireElement(\"expression\", tokens);\n\n              if (tokens.matchOpToken(\"..\")) {\n                  andAfter = true;\n                  var current = tokens.currentToken();\n                  if (current.type !== \"R_BRACKET\") {\n                      secondIndex = parser.parseElement(\"expression\", tokens);\n                  }\n              }\n          }\n          tokens.requireOpToken(\"]\");\n\n          var arrayIndex = {\n              type: \"arrayIndex\",\n              root: root,\n              prop: firstIndex,\n              firstIndex: firstIndex,\n              secondIndex: secondIndex,\n              args: [root, firstIndex, secondIndex],\n              op: function (_ctx, root, firstIndex, secondIndex) {\n                  if (root == null) {\n                      return null;\n                  }\n                  if (andBefore) {\n                      if (firstIndex < 0) {\n                          firstIndex = root.length + firstIndex;\n                      }\n                      return root.slice(0, firstIndex + 1); // returns all items from beginning to firstIndex (inclusive)\n                  } else if (andAfter) {\n                      if (secondIndex != null) {\n                          if (secondIndex < 0) {\n                              secondIndex = root.length + secondIndex;\n                          }\n                          return root.slice(firstIndex, secondIndex + 1); // returns all items from firstIndex to secondIndex (inclusive)\n                      } else {\n                          return root.slice(firstIndex); // returns from firstIndex to end of array\n                      }\n                  } else {\n                      return root[firstIndex];\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n\n          return parser.parseElement(\"indirectExpression\", tokens, arrayIndex);\n      });\n\n      // taken from https://drafts.csswg.org/css-values-4/#relative-length\n      //        and https://drafts.csswg.org/css-values-4/#absolute-length\n      //        (NB: we do not support `in` dues to conflicts w/ the hyperscript grammar)\n      var STRING_POSTFIXES = [\n          'em', 'ex', 'cap', 'ch', 'ic', 'rem', 'lh', 'rlh', 'vw', 'vh', 'vi', 'vb', 'vmin', 'vmax',\n          'cm', 'mm', 'Q', 'pc', 'pt', 'px'\n      ];\n      parser.addGrammarElement(\"postfixExpression\", function (parser, runtime, tokens) {\n          var root = parser.parseElement(\"primaryExpression\", tokens);\n\n          let stringPosfix = tokens.matchAnyToken.apply(tokens, STRING_POSTFIXES) || tokens.matchOpToken(\"%\");\n          if (stringPosfix) {\n              return {\n                  type: \"stringPostfix\",\n                  postfix: stringPosfix.value,\n                  args: [root],\n                  op: function (context, val) {\n                      return \"\" + val + stringPosfix.value;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n\n          var timeFactor = null;\n          if (tokens.matchToken(\"s\") || tokens.matchToken(\"seconds\")) {\n              timeFactor = 1000;\n          } else if (tokens.matchToken(\"ms\") || tokens.matchToken(\"milliseconds\")) {\n              timeFactor = 1;\n          }\n          if (timeFactor) {\n              return {\n                  type: \"timeExpression\",\n                  time: root,\n                  factor: timeFactor,\n                  args: [root],\n                  op: function (_context, val) {\n                      return val * timeFactor;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n\n          if (tokens.matchOpToken(\":\")) {\n              var typeName = tokens.requireTokenType(\"IDENTIFIER\");\n              if (!typeName.value) return;\n              var nullOk = !tokens.matchOpToken(\"!\");\n              return {\n                  type: \"typeCheck\",\n                  typeName: typeName,\n                  nullOk: nullOk,\n                  args: [root],\n                  op: function (context, val) {\n                      var passed = runtime.typeCheck(val, this.typeName.value, nullOk);\n                      if (passed) {\n                          return val;\n                      } else {\n                          throw new Error(\"Typecheck failed!  Expected: \" + typeName.value);\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              return root;\n          }\n      });\n\n      parser.addGrammarElement(\"logicalNot\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"not\")) return;\n          var root = parser.requireElement(\"unaryExpression\", tokens);\n          return {\n              type: \"logicalNot\",\n              root: root,\n              args: [root],\n              op: function (context, val) {\n                  return !val;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"noExpression\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"no\")) return;\n          var root = parser.requireElement(\"unaryExpression\", tokens);\n          return {\n              type: \"noExpression\",\n              root: root,\n              args: [root],\n              op: function (_context, val) {\n                  return runtime.isEmpty(val);\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"some\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"some\")) return;\n          var root = parser.requireElement(\"expression\", tokens);\n          return {\n              type: \"noExpression\",\n              root: root,\n              args: [root],\n              op: function (_context, val) {\n                  return !runtime.isEmpty(val);\n              },\n              evaluate(context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"negativeNumber\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"-\")) return;\n          var root = parser.requireElement(\"unaryExpression\", tokens);\n          return {\n              type: \"negativeNumber\",\n              root: root,\n              args: [root],\n              op: function (context, value) {\n                  return -1 * value;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"unaryExpression\", function (parser, runtime, tokens) {\n          tokens.matchToken(\"the\"); // optional \"the\"\n          return parser.parseAnyOf(\n              [\"beepExpression\", \"logicalNot\", \"relativePositionalExpression\", \"positionalExpression\", \"noExpression\", \"negativeNumber\", \"postfixExpression\"],\n              tokens\n          );\n      });\n\n      parser.addGrammarElement(\"beepExpression\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"beep!\")) return;\n          var expression = parser.parseElement(\"unaryExpression\", tokens);\n          if (expression) {\n              expression['booped'] = true;\n              var originalEvaluate = expression.evaluate;\n              expression.evaluate = function(ctx){\n                  let value = originalEvaluate.apply(expression, arguments);\n                  let element = ctx.me;\n                  if (runtime.triggerEvent(element, \"hyperscript:beep\", {element, expression, value})) {\n                      var typeName;\n                      if (value) {\n                          if (value instanceof ElementCollection){\n                              typeName = \"ElementCollection\";\n                          } else if (value.constructor) {\n                              typeName = value.constructor.name;\n                          } else {\n                              typeName = \"unknown\";\n                          }\n                      } else {\n                          typeName = \"object (null)\"\n                      }\n                      var logValue = value;\n                      if (typeName === \"String\") {\n                          logValue = '\"' + logValue + '\"';\n                      } else if (value instanceof ElementCollection) {\n                          logValue = Array.from(value);\n                      }\n                      console.log(\"///_ BEEP! The expression (\" + Tokens.sourceFor.call(expression).substr(6) + \") evaluates to:\", logValue,  \"of type \" + typeName);\n                  }\n                  return value;\n              }\n              return expression;\n          }\n      });\n\n      var scanForwardQuery = function(start, root, match, wrap) {\n          var results = root.querySelectorAll(match);\n          for (var i = 0; i < results.length; i++) {\n              var elt = results[i];\n              if (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_PRECEDING) {\n                  return elt;\n              }\n          }\n          if (wrap) {\n              return results[0];\n          }\n      }\n\n      var scanBackwardsQuery = function(start, root, match, wrap) {\n          var results = root.querySelectorAll(match);\n          for (var i = results.length - 1; i >= 0; i--) {\n              var elt = results[i];\n              if (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_FOLLOWING) {\n                  return elt;\n              }\n          }\n          if (wrap) {\n              return results[results.length - 1];\n          }\n      }\n\n      var scanForwardArray = function(start, array, match, wrap) {\n          var matches = [];\n          Runtime.prototype.forEach(array, function(elt){\n              if (elt.matches(match) || elt === start) {\n                  matches.push(elt);\n              }\n          })\n          for (var i = 0; i < matches.length - 1; i++) {\n              var elt = matches[i];\n              if (elt === start) {\n                  return matches[i + 1];\n              }\n          }\n          if (wrap) {\n              var first = matches[0];\n              if (first && first.matches(match)) {\n                  return first;\n              }\n          }\n      }\n\n      var scanBackwardsArray = function(start, array, match, wrap) {\n          return scanForwardArray(start, Array.from(array).reverse(), match, wrap);\n      }\n\n      parser.addGrammarElement(\"relativePositionalExpression\", function (parser, runtime, tokens) {\n          var op = tokens.matchAnyToken(\"next\", \"previous\");\n          if (!op) return;\n          var forwardSearch = op.value === \"next\";\n\n          var thing = parser.parseElement(\"expression\", tokens);\n\n          if (tokens.matchToken(\"from\")) {\n              tokens.pushFollow(\"in\");\n              try {\n                  var from = parser.requireElement(\"unaryExpression\", tokens);\n              } finally {\n                  tokens.popFollow();\n              }\n          } else {\n              var from = parser.requireElement(\"implicitMeTarget\", tokens);\n          }\n\n          var inSearch = false;\n          var withinElt;\n          if (tokens.matchToken(\"in\")) {\n              inSearch = true;\n              var inElt = parser.requireElement(\"unaryExpression\", tokens);\n          } else if (tokens.matchToken(\"within\")) {\n              withinElt = parser.requireElement(\"unaryExpression\", tokens);\n          } else {\n              withinElt = document.body;\n          }\n\n          var wrapping = false;\n          if (tokens.matchToken(\"with\")) {\n              tokens.requireToken(\"wrapping\")\n              wrapping = true;\n          }\n\n          return {\n              type: \"relativePositionalExpression\",\n              from: from,\n              forwardSearch: forwardSearch,\n              inSearch: inSearch,\n              wrapping: wrapping,\n              inElt: inElt,\n              withinElt: withinElt,\n              operator: op.value,\n              args: [thing, from, inElt, withinElt],\n              op: function (context, thing, from, inElt, withinElt) {\n\n                  var css = thing.css;\n                  if (css == null) {\n                      throw \"Expected a CSS value\";\n                  }\n\n                  if(inSearch) {\n                      if (inElt) {\n                          if (forwardSearch) {\n                              return scanForwardArray(from, inElt, css, wrapping);\n                          } else {\n                              return scanBackwardsArray(from, inElt, css, wrapping);\n                          }\n                      }\n                  } else {\n                      if (withinElt) {\n                          if (forwardSearch) {\n                              return scanForwardQuery(from, withinElt, css, wrapping);\n                          } else {\n                              return scanBackwardsQuery(from, withinElt, css, wrapping);\n                          }\n                      }\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          }\n\n      });\n\n      parser.addGrammarElement(\"positionalExpression\", function (parser, runtime, tokens) {\n          var op = tokens.matchAnyToken(\"first\", \"last\", \"random\");\n          if (!op) return;\n          tokens.matchAnyToken(\"in\", \"from\", \"of\");\n          var rhs = parser.requireElement(\"unaryExpression\", tokens);\n          const operator = op.value;\n          return {\n              type: \"positionalExpression\",\n              rhs: rhs,\n              operator: op.value,\n              args: [rhs],\n              op: function (context, rhsVal) {\n                  if (rhsVal && !Array.isArray(rhsVal)) {\n                      if (rhsVal.children) {\n                          rhsVal = rhsVal.children;\n                      } else {\n                          rhsVal = Array.from(rhsVal);\n                      }\n                  }\n                  if (rhsVal) {\n                      if (operator === \"first\") {\n                          return rhsVal[0];\n                      } else if (operator === \"last\") {\n                          return rhsVal[rhsVal.length - 1];\n                      } else if (operator === \"random\") {\n                          return rhsVal[Math.floor(Math.random() * rhsVal.length)];\n                      }\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"mathOperator\", function (parser, runtime, tokens) {\n          var expr = parser.parseElement(\"unaryExpression\", tokens);\n          var mathOp,\n              initialMathOp = null;\n          mathOp = tokens.matchAnyOpToken(\"+\", \"-\", \"*\", \"/\", \"%\");\n          while (mathOp) {\n              initialMathOp = initialMathOp || mathOp;\n              var operator = mathOp.value;\n              if (initialMathOp.value !== operator) {\n                  parser.raiseParseError(tokens, \"You must parenthesize math operations with different operators\");\n              }\n              var rhs = parser.parseElement(\"unaryExpression\", tokens);\n              expr = {\n                  type: \"mathOperator\",\n                  lhs: expr,\n                  rhs: rhs,\n                  operator: operator,\n                  args: [expr, rhs],\n                  op: function (context, lhsVal, rhsVal) {\n                      if (operator === \"+\") {\n                          return lhsVal + rhsVal;\n                      } else if (operator === \"-\") {\n                          return lhsVal - rhsVal;\n                      } else if (operator === \"*\") {\n                          return lhsVal * rhsVal;\n                      } else if (operator === \"/\") {\n                          return lhsVal / rhsVal;\n                      } else if (operator === \"%\") {\n                          return lhsVal % rhsVal;\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n              mathOp = tokens.matchAnyOpToken(\"+\", \"-\", \"*\", \"/\", \"%\");\n          }\n          return expr;\n      });\n\n      parser.addGrammarElement(\"mathExpression\", function (parser, runtime, tokens) {\n          return parser.parseAnyOf([\"mathOperator\", \"unaryExpression\"], tokens);\n      });\n\n      function sloppyContains(src, container, value){\n          if (container['contains']) {\n              return container.contains(value);\n          } else if (container['includes']) {\n              return container.includes(value);\n          } else {\n              throw Error(\"The value of \" + src.sourceFor() + \" does not have a contains or includes method on it\");\n          }\n      }\n      function sloppyMatches(src, target, toMatch){\n          if (target['match']) {\n              return !!target.match(toMatch);\n          } else if (target['matches']) {\n              return target.matches(toMatch);\n          } else {\n              throw Error(\"The value of \" + src.sourceFor() + \" does not have a match or matches method on it\");\n          }\n      }\n\n      parser.addGrammarElement(\"comparisonOperator\", function (parser, runtime, tokens) {\n          var expr = parser.parseElement(\"mathExpression\", tokens);\n          var comparisonToken = tokens.matchAnyOpToken(\"<\", \">\", \"<=\", \">=\", \"==\", \"===\", \"!=\", \"!==\");\n          var operator = comparisonToken ? comparisonToken.value : null;\n          var hasRightValue = true; // By default, most comparisons require two values, but there are some exceptions.\n          var typeCheck = false;\n\n          if (operator == null) {\n              if (tokens.matchToken(\"is\") || tokens.matchToken(\"am\")) {\n                  if (tokens.matchToken(\"not\")) {\n                      if (tokens.matchToken(\"in\")) {\n                          operator = \"not in\";\n                      } else if (tokens.matchToken(\"a\")) {\n                          operator = \"not a\";\n                          typeCheck = true;\n                      } else if (tokens.matchToken(\"empty\")) {\n                          operator = \"not empty\";\n                          hasRightValue = false;\n                      } else {\n                          operator = \"!=\";\n                      }\n                  } else if (tokens.matchToken(\"in\")) {\n                      operator = \"in\";\n                  } else if (tokens.matchToken(\"a\")) {\n                      operator = \"a\";\n                      typeCheck = true;\n                  } else if (tokens.matchToken(\"empty\")) {\n                      operator = \"empty\";\n                      hasRightValue = false;\n                  } else if (tokens.matchToken(\"less\")) {\n                      tokens.requireToken(\"than\");\n                      if (tokens.matchToken(\"or\")) {\n                          tokens.requireToken(\"equal\");\n                          tokens.requireToken(\"to\");\n                          operator = \"<=\";\n                      } else {\n                          operator = \"<\";\n                      }\n                  } else if (tokens.matchToken(\"greater\")) {\n                      tokens.requireToken(\"than\");\n                      if (tokens.matchToken(\"or\")) {\n                          tokens.requireToken(\"equal\");\n                          tokens.requireToken(\"to\");\n                          operator = \">=\";\n                      } else {\n                          operator = \">\";\n                      }\n                  } else {\n                      operator = \"==\";\n                  }\n              } else if (tokens.matchToken(\"exist\") || tokens.matchToken(\"exists\")) {\n                  operator = \"exist\";\n                  hasRightValue = false;\n              } else if (tokens.matchToken(\"matches\") || tokens.matchToken(\"match\")) {\n                  operator = \"match\";\n              } else if (tokens.matchToken(\"contains\") || tokens.matchToken(\"contain\")) {\n                  operator = \"contain\";\n              } else if (tokens.matchToken(\"includes\") || tokens.matchToken(\"include\")) {\n                  operator = \"include\";\n              } else if (tokens.matchToken(\"do\") || tokens.matchToken(\"does\")) {\n                  tokens.requireToken(\"not\");\n                  if (tokens.matchToken(\"matches\") || tokens.matchToken(\"match\")) {\n                      operator = \"not match\";\n                  } else if (tokens.matchToken(\"contains\") || tokens.matchToken(\"contain\")) {\n                      operator = \"not contain\";\n                  } else if (tokens.matchToken(\"exist\") || tokens.matchToken(\"exist\")) {\n                      operator = \"not exist\";\n                      hasRightValue = false;\n                  } else if (tokens.matchToken(\"include\")) {\n                      operator = \"not include\";\n                  } else {\n                      parser.raiseParseError(tokens, \"Expected matches or contains\");\n                  }\n              }\n          }\n\n          if (operator) {\n              // Do not allow chained comparisons, which is dumb\n              var typeName, nullOk, rhs\n              if (typeCheck) {\n                  typeName = tokens.requireTokenType(\"IDENTIFIER\");\n                  nullOk = !tokens.matchOpToken(\"!\");\n              } else if (hasRightValue) {\n                  rhs = parser.requireElement(\"mathExpression\", tokens);\n                  if (operator === \"match\" || operator === \"not match\") {\n                      rhs = rhs.css ? rhs.css : rhs;\n                  }\n              }\n              var lhs = expr;\n              expr = {\n                  type: \"comparisonOperator\",\n                  operator: operator,\n                  typeName: typeName,\n                  nullOk: nullOk,\n                  lhs: expr,\n                  rhs: rhs,\n                  args: [expr, rhs],\n                  op: function (context, lhsVal, rhsVal) {\n                      if (operator === \"==\") {\n                          return lhsVal == rhsVal;\n                      } else if (operator === \"!=\") {\n                          return lhsVal != rhsVal;\n                      }\n                      if (operator === \"match\") {\n                          return lhsVal != null && sloppyMatches(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"not match\") {\n                          return lhsVal == null || !sloppyMatches(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"in\") {\n                          return rhsVal != null && sloppyContains(rhs, rhsVal, lhsVal);\n                      }\n                      if (operator === \"not in\") {\n                          return rhsVal == null || !sloppyContains(rhs, rhsVal, lhsVal);\n                      }\n                      if (operator === \"contain\") {\n                          return lhsVal != null && sloppyContains(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"not contain\") {\n                          return lhsVal == null || !sloppyContains(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"include\") {\n                          return lhsVal != null && sloppyContains(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"not include\") {\n                          return lhsVal == null || !sloppyContains(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"===\") {\n                          return lhsVal === rhsVal;\n                      } else if (operator === \"!==\") {\n                          return lhsVal !== rhsVal;\n                      } else if (operator === \"<\") {\n                          return lhsVal < rhsVal;\n                      } else if (operator === \">\") {\n                          return lhsVal > rhsVal;\n                      } else if (operator === \"<=\") {\n                          return lhsVal <= rhsVal;\n                      } else if (operator === \">=\") {\n                          return lhsVal >= rhsVal;\n                      } else if (operator === \"empty\") {\n                          return runtime.isEmpty(lhsVal);\n                      } else if (operator === \"not empty\") {\n                          return !runtime.isEmpty(lhsVal);\n                      } else if (operator === \"exist\") {\n                          return runtime.doesExist(lhsVal);\n                      } else if (operator === \"not exist\") {\n                          return !runtime.doesExist(lhsVal);\n                      } else if (operator === \"a\") {\n                          return runtime.typeCheck(lhsVal, typeName.value, nullOk);\n                      } else if (operator === \"not a\") {\n                          return !runtime.typeCheck(lhsVal, typeName.value, nullOk);\n                      } else {\n                          throw \"Unknown comparison : \" + operator;\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n          return expr;\n      });\n\n      parser.addGrammarElement(\"comparisonExpression\", function (parser, runtime, tokens) {\n          return parser.parseAnyOf([\"comparisonOperator\", \"mathExpression\"], tokens);\n      });\n\n      parser.addGrammarElement(\"logicalOperator\", function (parser, runtime, tokens) {\n          var expr = parser.parseElement(\"comparisonExpression\", tokens);\n          var logicalOp,\n              initialLogicalOp = null;\n          logicalOp = tokens.matchToken(\"and\") || tokens.matchToken(\"or\");\n          while (logicalOp) {\n              initialLogicalOp = initialLogicalOp || logicalOp;\n              if (initialLogicalOp.value !== logicalOp.value) {\n                  parser.raiseParseError(tokens, \"You must parenthesize logical operations with different operators\");\n              }\n              var rhs = parser.requireElement(\"comparisonExpression\", tokens);\n              const operator = logicalOp.value;\n              expr = {\n                  type: \"logicalOperator\",\n                  operator: operator,\n                  lhs: expr,\n                  rhs: rhs,\n                  args: [expr, rhs],\n                  op: function (context, lhsVal, rhsVal) {\n                      if (operator === \"and\") {\n                          return lhsVal && rhsVal;\n                      } else {\n                          return lhsVal || rhsVal;\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n              logicalOp = tokens.matchToken(\"and\") || tokens.matchToken(\"or\");\n          }\n          return expr;\n      });\n\n      parser.addGrammarElement(\"logicalExpression\", function (parser, runtime, tokens) {\n          return parser.parseAnyOf([\"logicalOperator\", \"mathExpression\"], tokens);\n      });\n\n      parser.addGrammarElement(\"asyncExpression\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"async\")) {\n              var value = parser.requireElement(\"logicalExpression\", tokens);\n              var expr = {\n                  type: \"asyncExpression\",\n                  value: value,\n                  evaluate: function (context) {\n                      return {\n                          asyncWrapper: true,\n                          value: this.value.evaluate(context), //OK\n                      };\n                  },\n              };\n              return expr;\n          } else {\n              return parser.parseElement(\"logicalExpression\", tokens);\n          }\n      });\n\n      parser.addGrammarElement(\"expression\", function (parser, runtime, tokens) {\n          tokens.matchToken(\"the\"); // optional the\n          return parser.parseElement(\"asyncExpression\", tokens);\n      });\n\n      parser.addGrammarElement(\"assignableExpression\", function (parser, runtime, tokens) {\n          tokens.matchToken(\"the\"); // optional the\n\n          // TODO obviously we need to generalize this as a left hand side / targetable concept\n          var expr = parser.parseElement(\"primaryExpression\", tokens);\n          if (expr && (\n              expr.type === \"symbol\" ||\n              expr.type === \"ofExpression\" ||\n              expr.type === \"propertyAccess\" ||\n              expr.type === \"attributeRefAccess\" ||\n              expr.type === \"attributeRef\" ||\n              expr.type === \"styleRef\" ||\n              expr.type === \"arrayIndex\" ||\n              expr.type === \"possessive\")\n          ) {\n              return expr;\n          } else {\n              parser.raiseParseError(\n                  tokens,\n                  \"A target expression must be writable.  The expression type '\" + (expr && expr.type) + \"' is not.\"\n              );\n          }\n          return expr;\n      });\n\n      parser.addGrammarElement(\"hyperscript\", function (parser, runtime, tokens) {\n          var features = [];\n\n          if (tokens.hasMore()) {\n              while (parser.featureStart(tokens.currentToken()) || tokens.currentToken().value === \"(\") {\n                  var feature = parser.requireElement(\"feature\", tokens);\n                  features.push(feature);\n                  tokens.matchToken(\"end\"); // optional end\n              }\n          }\n          return {\n              type: \"hyperscript\",\n              features: features,\n              apply: function (target, source, args) {\n                  // no op\n                  for (const feature of features) {\n                      feature.install(target, source, args);\n                  }\n              },\n          };\n      });\n\n      var parseEventArgs = function (tokens) {\n          var args = [];\n          // handle argument list (look ahead 3)\n          if (\n              tokens.token(0).value === \"(\" &&\n              (tokens.token(1).value === \")\" || tokens.token(2).value === \",\" || tokens.token(2).value === \")\")\n          ) {\n              tokens.matchOpToken(\"(\");\n              do {\n                  args.push(tokens.requireTokenType(\"IDENTIFIER\"));\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\")\");\n          }\n          return args;\n      };\n\n      parser.addFeature(\"on\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"on\")) return;\n          var every = false;\n          if (tokens.matchToken(\"every\")) {\n              every = true;\n          }\n          var events = [];\n          var displayName = null;\n          do {\n              var on = parser.requireElement(\"eventName\", tokens, \"Expected event name\");\n\n              var eventName = on.evaluate(); // OK No Promise\n\n              if (displayName) {\n                  displayName = displayName + \" or \" + eventName;\n              } else {\n                  displayName = \"on \" + eventName;\n              }\n              var args = parseEventArgs(tokens);\n\n              var filter = null;\n              if (tokens.matchOpToken(\"[\")) {\n                  filter = parser.requireElement(\"expression\", tokens);\n                  tokens.requireOpToken(\"]\");\n              }\n\n              var startCount, endCount ,unbounded;\n              if (tokens.currentToken().type === \"NUMBER\") {\n                  var startCountToken = tokens.consumeToken();\n                  if (!startCountToken.value) return;\n                  startCount = parseInt(startCountToken.value);\n                  if (tokens.matchToken(\"to\")) {\n                      var endCountToken = tokens.consumeToken();\n                      if (!endCountToken.value) return;\n                      endCount = parseInt(endCountToken.value);\n                  } else if (tokens.matchToken(\"and\")) {\n                      unbounded = true;\n                      tokens.requireToken(\"on\");\n                  }\n              }\n\n              var intersectionSpec, mutationSpec;\n              if (eventName === \"intersection\") {\n                  intersectionSpec = {};\n                  if (tokens.matchToken(\"with\")) {\n                      intersectionSpec[\"with\"] = parser.requireElement(\"expression\", tokens).evaluate();\n                  }\n                  if (tokens.matchToken(\"having\")) {\n                      do {\n                          if (tokens.matchToken(\"margin\")) {\n                              intersectionSpec[\"rootMargin\"] = parser.requireElement(\"stringLike\", tokens).evaluate();\n                          } else if (tokens.matchToken(\"threshold\")) {\n                              intersectionSpec[\"threshold\"] = parser.requireElement(\"expression\", tokens).evaluate();\n                          } else {\n                              parser.raiseParseError(tokens, \"Unknown intersection config specification\");\n                          }\n                      } while (tokens.matchToken(\"and\"));\n                  }\n              } else if (eventName === \"mutation\") {\n                  mutationSpec = {};\n                  if (tokens.matchToken(\"of\")) {\n                      do {\n                          if (tokens.matchToken(\"anything\")) {\n                              mutationSpec[\"attributes\"] = true;\n                              mutationSpec[\"subtree\"] = true;\n                              mutationSpec[\"characterData\"] = true;\n                              mutationSpec[\"childList\"] = true;\n                          } else if (tokens.matchToken(\"childList\")) {\n                              mutationSpec[\"childList\"] = true;\n                          } else if (tokens.matchToken(\"attributes\")) {\n                              mutationSpec[\"attributes\"] = true;\n                              mutationSpec[\"attributeOldValue\"] = true;\n                          } else if (tokens.matchToken(\"subtree\")) {\n                              mutationSpec[\"subtree\"] = true;\n                          } else if (tokens.matchToken(\"characterData\")) {\n                              mutationSpec[\"characterData\"] = true;\n                              mutationSpec[\"characterDataOldValue\"] = true;\n                          } else if (tokens.currentToken().type === \"ATTRIBUTE_REF\") {\n                              var attribute = tokens.consumeToken();\n                              if (mutationSpec[\"attributeFilter\"] == null) {\n                                  mutationSpec[\"attributeFilter\"] = [];\n                              }\n                              if (attribute.value.indexOf(\"@\") == 0) {\n                                  mutationSpec[\"attributeFilter\"].push(attribute.value.substring(1));\n                              } else {\n                                  parser.raiseParseError(\n                                      tokens,\n                                      \"Only shorthand attribute references are allowed here\"\n                                  );\n                              }\n                          } else {\n                              parser.raiseParseError(tokens, \"Unknown mutation config specification\");\n                          }\n                      } while (tokens.matchToken(\"or\"));\n                  } else {\n                      mutationSpec[\"attributes\"] = true;\n                      mutationSpec[\"characterData\"] = true;\n                      mutationSpec[\"childList\"] = true;\n                  }\n              }\n\n              var from = null;\n              var elsewhere = false;\n              if (tokens.matchToken(\"from\")) {\n                  if (tokens.matchToken(\"elsewhere\")) {\n                      elsewhere = true;\n                  } else {\n                      from = parser.parseElement(\"expression\", tokens);\n                      if (!from) {\n                          parser.raiseParseError(tokens, 'Expected either target value or \"elsewhere\".');\n                      }\n                  }\n              }\n              // support both \"elsewhere\" and \"from elsewhere\"\n              if (from === null && elsewhere === false && tokens.matchToken(\"elsewhere\")) {\n                  elsewhere = true;\n              }\n\n              if (tokens.matchToken(\"in\")) {\n                  var inExpr = parser.parseElement('unaryExpression', tokens);\n              }\n\n              if (tokens.matchToken(\"debounced\")) {\n                  tokens.requireToken(\"at\");\n                  var timeExpr = parser.requireElement(\"expression\", tokens);\n                  // @ts-ignore\n                  var debounceTime = timeExpr.evaluate({}); // OK No promise TODO make a literal time expr\n              } else if (tokens.matchToken(\"throttled\")) {\n                  tokens.requireToken(\"at\");\n                  var timeExpr = parser.requireElement(\"expression\", tokens);\n                  // @ts-ignore\n                  var throttleTime = timeExpr.evaluate({}); // OK No promise TODO make a literal time expr\n              }\n\n              events.push({\n                  execCount: 0,\n                  every: every,\n                  on: eventName,\n                  args: args,\n                  filter: filter,\n                  from: from,\n                  inExpr: inExpr,\n                  elsewhere: elsewhere,\n                  startCount: startCount,\n                  endCount: endCount,\n                  unbounded: unbounded,\n                  debounceTime: debounceTime,\n                  throttleTime: throttleTime,\n                  mutationSpec: mutationSpec,\n                  intersectionSpec: intersectionSpec,\n                  debounced: undefined,\n                  lastExec: undefined,\n              });\n          } while (tokens.matchToken(\"or\"));\n\n          var queueLast = true;\n          if (!every) {\n              if (tokens.matchToken(\"queue\")) {\n                  if (tokens.matchToken(\"all\")) {\n                      var queueAll = true;\n                      var queueLast = false;\n                  } else if (tokens.matchToken(\"first\")) {\n                      var queueFirst = true;\n                  } else if (tokens.matchToken(\"none\")) {\n                      var queueNone = true;\n                  } else {\n                      tokens.requireToken(\"last\");\n                  }\n              }\n          }\n\n          var start = parser.requireElement(\"commandList\", tokens);\n          parser.ensureTerminated(start);\n\n          var errorSymbol, errorHandler;\n          if (tokens.matchToken(\"catch\")) {\n              errorSymbol = tokens.requireTokenType(\"IDENTIFIER\").value;\n              errorHandler = parser.requireElement(\"commandList\", tokens);\n              parser.ensureTerminated(errorHandler);\n          }\n\n          if (tokens.matchToken(\"finally\")) {\n              var finallyHandler = parser.requireElement(\"commandList\", tokens);\n              parser.ensureTerminated(finallyHandler);\n          }\n\n          var onFeature = {\n              displayName: displayName,\n              events: events,\n              start: start,\n              every: every,\n              execCount: 0,\n              errorHandler: errorHandler,\n              errorSymbol: errorSymbol,\n              execute: function (/** @type {Context} */ ctx) {\n                  let eventQueueInfo = runtime.getEventQueueFor(ctx.me, onFeature);\n                  if (eventQueueInfo.executing && every === false) {\n                      if (queueNone || (queueFirst && eventQueueInfo.queue.length > 0)) {\n                          return;\n                      }\n                      if (queueLast) {\n                          eventQueueInfo.queue.length = 0;\n                      }\n                      eventQueueInfo.queue.push(ctx);\n                      return;\n                  }\n                  onFeature.execCount++;\n                  eventQueueInfo.executing = true;\n                  ctx.meta.onHalt = function () {\n                      eventQueueInfo.executing = false;\n                      var queued = eventQueueInfo.queue.shift();\n                      if (queued) {\n                          setTimeout(function () {\n                              onFeature.execute(queued);\n                          }, 1);\n                      }\n                  };\n                  ctx.meta.reject = function (err) {\n                      console.error(err.message ? err.message : err);\n                      var hypertrace = runtime.getHyperTrace(ctx, err);\n                      if (hypertrace) {\n                          hypertrace.print();\n                      }\n                      runtime.triggerEvent(ctx.me, \"exception\", {\n                          error: err,\n                      });\n                  };\n                  start.execute(ctx);\n              },\n              install: function (elt, source) {\n                  for (const eventSpec of onFeature.events) {\n                      var targets;\n                      if (eventSpec.elsewhere) {\n                          targets = [document];\n                      } else if (eventSpec.from) {\n                          targets = eventSpec.from.evaluate(runtime.makeContext(elt, onFeature, elt, null));\n                      } else {\n                          targets = [elt];\n                      }\n                      runtime.implicitLoop(targets, function (target) {\n                          // OK NO PROMISE\n\n                          var eventName = eventSpec.on;\n                          if (target == null) {\n                            console.warn(\"'%s' feature ignored because target does not exists:\", displayName, elt);\n                            return;\n                          }\n                          \n                          if (eventSpec.mutationSpec) {\n                              eventName = \"hyperscript:mutation\";\n                              const observer = new MutationObserver(function (mutationList, observer) {\n                                  if (!onFeature.executing) {\n                                      runtime.triggerEvent(target, eventName, {\n                                          mutationList: mutationList,\n                                          observer: observer,\n                                      });\n                                  }\n                              });\n                              observer.observe(target, eventSpec.mutationSpec);\n                          }\n\n                          if (eventSpec.intersectionSpec) {\n                              eventName = \"hyperscript:insersection\";\n                              const observer = new IntersectionObserver(function (entries) {\n                                  for (const entry of entries) {\n                                      var detail = {\n                                          observer: observer,\n                                      };\n                                      detail = Object.assign(detail, entry);\n                                      detail[\"intersecting\"] = entry.isIntersecting;\n                                      runtime.triggerEvent(target, eventName, detail);\n                                  }\n                              }, eventSpec.intersectionSpec);\n                              observer.observe(target);\n                          }\n\n                          var addEventListener = target.addEventListener || target.on;\n                          addEventListener.call(target, eventName, function listener(evt) {\n                              // OK NO PROMISE\n                              if (typeof Node !== 'undefined' && elt instanceof Node && target !== elt && !elt.isConnected) {\n                                  target.removeEventListener(eventName, listener);\n                                  return;\n                              }\n\n                              var ctx = runtime.makeContext(elt, onFeature, elt, evt);\n                              if (eventSpec.elsewhere && elt.contains(evt.target)) {\n                                  return;\n                              }\n                              if (eventSpec.from) {\n                                  ctx.result = target;\n                              }\n\n                              // establish context\n                              for (const arg of eventSpec.args) {\n                                  let eventValue = ctx.event[arg.value];\n                                  if (eventValue !== undefined) {\n                                      ctx.locals[arg.value] = eventValue;\n                                  } else if ('detail' in ctx.event) {\n                                      ctx.locals[arg.value] = ctx.event['detail'][arg.value];\n                                  }\n                              }\n\n                              // install error handler if any\n                              ctx.meta.errorHandler = errorHandler;\n                              ctx.meta.errorSymbol = errorSymbol;\n                              ctx.meta.finallyHandler = finallyHandler;\n\n                              // apply filter\n                              if (eventSpec.filter) {\n                                  var initialCtx = ctx.meta.context;\n                                  ctx.meta.context = ctx.event;\n                                  try {\n                                      var value = eventSpec.filter.evaluate(ctx); //OK NO PROMISE\n                                      if (value) {\n                                          // match the javascript semantics for if statements\n                                      } else {\n                                          return;\n                                      }\n                                  } finally {\n                                      ctx.meta.context = initialCtx;\n                                  }\n                              }\n\n                              if (eventSpec.inExpr) {\n                                  var inElement = evt.target;\n                                  while (true) {\n                                      if (inElement.matches && inElement.matches(eventSpec.inExpr.css)) {\n                                          ctx.result = inElement;\n                                          break;\n                                      } else {\n                                          inElement = inElement.parentElement;\n                                          if (inElement == null) {\n                                              return; // no match found\n                                          }\n                                      }\n                                  }\n                              }\n\n                              // verify counts\n                              eventSpec.execCount++;\n                              if (eventSpec.startCount) {\n                                  if (eventSpec.endCount) {\n                                      if (\n                                          eventSpec.execCount < eventSpec.startCount ||\n                                          eventSpec.execCount > eventSpec.endCount\n                                      ) {\n                                          return;\n                                      }\n                                  } else if (eventSpec.unbounded) {\n                                      if (eventSpec.execCount < eventSpec.startCount) {\n                                          return;\n                                      }\n                                  } else if (eventSpec.execCount !== eventSpec.startCount) {\n                                      return;\n                                  }\n                              }\n\n                              //debounce\n                              if (eventSpec.debounceTime) {\n                                  if (eventSpec.debounced) {\n                                      clearTimeout(eventSpec.debounced);\n                                  }\n                                  eventSpec.debounced = setTimeout(function () {\n                                      onFeature.execute(ctx);\n                                  }, eventSpec.debounceTime);\n                                  return;\n                              }\n\n                              // throttle\n                              if (eventSpec.throttleTime) {\n                                  if (\n                                      eventSpec.lastExec &&\n                                      Date.now() < (eventSpec.lastExec + eventSpec.throttleTime)\n                                  ) {\n                                      return;\n                                  } else {\n                                      eventSpec.lastExec = Date.now();\n                                  }\n                              }\n\n                              // apply execute\n                              onFeature.execute(ctx);\n                          });\n                      });\n                  }\n              },\n              executing: undefined\n          };\n          parser.setParent(start, onFeature);\n          return onFeature;\n      });\n\n      parser.addFeature(\"def\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"def\")) return;\n          var functionName = parser.requireElement(\"dotOrColonPath\", tokens);\n          var nameVal = functionName.evaluate(); // OK\n          var nameSpace = nameVal.split(\".\");\n          var funcName = nameSpace.pop();\n\n          var args = [];\n          if (tokens.matchOpToken(\"(\")) {\n              if (tokens.matchOpToken(\")\")) {\n                  // emtpy args list\n              } else {\n                  do {\n                      args.push(tokens.requireTokenType(\"IDENTIFIER\"));\n                  } while (tokens.matchOpToken(\",\"));\n                  tokens.requireOpToken(\")\");\n              }\n          }\n\n          var start = parser.requireElement(\"commandList\", tokens);\n\n          var errorSymbol, errorHandler;\n          if (tokens.matchToken(\"catch\")) {\n              errorSymbol = tokens.requireTokenType(\"IDENTIFIER\").value;\n              errorHandler = parser.parseElement(\"commandList\", tokens);\n          }\n\n          if (tokens.matchToken(\"finally\")) {\n              var finallyHandler = parser.requireElement(\"commandList\", tokens);\n              parser.ensureTerminated(finallyHandler);\n          }\n\n          var functionFeature = {\n              displayName:\n                  funcName +\n                  \"(\" +\n                  args\n                      .map(function (arg) {\n                          return arg.value;\n                      })\n                      .join(\", \") +\n                  \")\",\n              name: funcName,\n              args: args,\n              start: start,\n              errorHandler: errorHandler,\n              errorSymbol: errorSymbol,\n              finallyHandler: finallyHandler,\n              install: function (target, source) {\n                  var func = function () {\n                      // null, worker\n                      var ctx = runtime.makeContext(source, functionFeature, target, null);\n\n                      // install error handler if any\n                      ctx.meta.errorHandler = errorHandler;\n                      ctx.meta.errorSymbol = errorSymbol;\n                      ctx.meta.finallyHandler = finallyHandler;\n\n                      for (var i = 0; i < args.length; i++) {\n                          var name = args[i];\n                          var argumentVal = arguments[i];\n                          if (name) {\n                              ctx.locals[name.value] = argumentVal;\n                          }\n                      }\n                      ctx.meta.caller = arguments[args.length];\n                      if (ctx.meta.caller) {\n                          ctx.meta.callingCommand = ctx.meta.caller.meta.command;\n                      }\n                      var resolve,\n                          reject = null;\n                      var promise = new Promise(function (theResolve, theReject) {\n                          resolve = theResolve;\n                          reject = theReject;\n                      });\n                      start.execute(ctx);\n                      if (ctx.meta.returned) {\n                          return ctx.meta.returnValue;\n                      } else {\n                          ctx.meta.resolve = resolve;\n                          ctx.meta.reject = reject;\n                          return promise;\n                      }\n                  };\n                  func['hyperfunc'] = true;\n                  func['hypername'] = nameVal;\n                  runtime.assignToNamespace(target, nameSpace, funcName, func);\n              },\n          };\n\n          parser.ensureTerminated(start);\n\n          // terminate error handler if any\n          if (errorHandler) {\n              parser.ensureTerminated(errorHandler);\n          }\n\n          parser.setParent(start, functionFeature);\n          return functionFeature;\n      });\n\n      parser.addFeature(\"set\", function (parser, runtime, tokens) {\n          let setCmd = parser.parseElement(\"setCommand\", tokens);\n          if (setCmd) {\n              if (setCmd.target.scope !== \"element\") {\n                  parser.raiseParseError(tokens, \"variables declared at the feature level must be element scoped.\");\n              }\n              let setFeature = {\n                  start: setCmd,\n                  install: function (target, source) {\n                      setCmd && setCmd.execute(runtime.makeContext(target, setFeature, target, null));\n                  },\n              };\n              parser.ensureTerminated(setCmd);\n              return setFeature;\n          }\n      });\n\n      parser.addFeature(\"init\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"init\")) return;\n\n          var immediately = tokens.matchToken(\"immediately\");\n\n          var start = parser.requireElement(\"commandList\", tokens);\n          var initFeature = {\n              start: start,\n              install: function (target, source) {\n                  let handler = function () {\n                      start && start.execute(runtime.makeContext(target, initFeature, target, null));\n                  };\n                  if (immediately) {\n                      handler();\n                  } else {\n                      setTimeout(handler, 0);\n                  }\n              },\n          };\n  \n          // terminate body\n          parser.ensureTerminated(start);\n          parser.setParent(start, initFeature);\n          return initFeature;\n      });\n\n      parser.addFeature(\"worker\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"worker\")) {\n              parser.raiseParseError(\n                  tokens,\n                  \"In order to use the 'worker' feature, include \" +\n                      \"the _hyperscript worker plugin. See \" +\n                      \"https://hyperscript.org/features/worker/ for \" +\n                      \"more info.\"\n              );\n              return undefined\n          }\n      });\n\n      parser.addFeature(\"behavior\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"behavior\")) return;\n          var path = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n          var nameSpace = path.split(\".\");\n          var name = nameSpace.pop();\n\n          var formalParams = [];\n          if (tokens.matchOpToken(\"(\") && !tokens.matchOpToken(\")\")) {\n              do {\n                  formalParams.push(tokens.requireTokenType(\"IDENTIFIER\").value);\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\")\");\n          }\n          var hs = parser.requireElement(\"hyperscript\", tokens);\n          for (var i = 0; i < hs.features.length; i++) {\n              var feature = hs.features[i];\n              feature.behavior = path;\n          }\n\n          return {\n              install: function (target, source) {\n                  runtime.assignToNamespace(\n                      globalScope.document && globalScope.document.body,\n                      nameSpace,\n                      name,\n                      function (target, source, innerArgs) {\n                          var internalData = runtime.getInternalData(target);\n                          var elementScope = getOrInitObject(internalData, path + \"Scope\");\n                          for (var i = 0; i < formalParams.length; i++) {\n                              elementScope[formalParams[i]] = innerArgs[formalParams[i]];\n                          }\n                          hs.apply(target, source);\n                      }\n                  );\n              },\n          };\n      });\n\n      parser.addFeature(\"install\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"install\")) return;\n          var behaviorPath = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n          var behaviorNamespace = behaviorPath.split(\".\");\n          var args = parser.parseElement(\"namedArgumentList\", tokens);\n\n          var installFeature;\n          return (installFeature = {\n              install: function (target, source) {\n                  runtime.unifiedEval(\n                      {\n                          args: [args],\n                          op: function (ctx, args) {\n                              var behavior = globalScope;\n                              for (var i = 0; i < behaviorNamespace.length; i++) {\n                                  behavior = behavior[behaviorNamespace[i]];\n                                  if (typeof behavior !== \"object\" && typeof behavior !== \"function\")\n                                      throw new Error(\"No such behavior defined as \" + behaviorPath);\n                              }\n\n                              if (!(behavior instanceof Function))\n                                  throw new Error(behaviorPath + \" is not a behavior\");\n\n                              behavior(target, source, args);\n                          },\n                      },\n                      runtime.makeContext(target, installFeature, target, null)\n                  );\n              },\n          });\n      });\n\n      parser.addGrammarElement(\"jsBody\", function (parser, runtime, tokens) {\n          var jsSourceStart = tokens.currentToken().start;\n          var jsLastToken = tokens.currentToken();\n\n          var funcNames = [];\n          var funcName = \"\";\n          var expectFunctionDeclaration = false;\n          while (tokens.hasMore()) {\n              jsLastToken = tokens.consumeToken();\n              var peek = tokens.token(0, true);\n              if (peek.type === \"IDENTIFIER\" && peek.value === \"end\") {\n                  break;\n              }\n              if (expectFunctionDeclaration) {\n                  if (jsLastToken.type === \"IDENTIFIER\" || jsLastToken.type === \"NUMBER\") {\n                      funcName += jsLastToken.value;\n                  } else {\n                      if (funcName !== \"\") funcNames.push(funcName);\n                      funcName = \"\";\n                      expectFunctionDeclaration = false;\n                  }\n              } else if (jsLastToken.type === \"IDENTIFIER\" && jsLastToken.value === \"function\") {\n                  expectFunctionDeclaration = true;\n              }\n          }\n          var jsSourceEnd = jsLastToken.end + 1;\n\n          return {\n              type: \"jsBody\",\n              exposedFunctionNames: funcNames,\n              jsSource: tokens.source.substring(jsSourceStart, jsSourceEnd),\n          };\n      });\n\n      parser.addFeature(\"js\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"js\")) return;\n          var jsBody = parser.requireElement(\"jsBody\", tokens);\n\n          var jsSource =\n              jsBody.jsSource +\n              \"\\nreturn { \" +\n              jsBody.exposedFunctionNames\n                  .map(function (name) {\n                      return name + \":\" + name;\n                  })\n                  .join(\",\") +\n              \" } \";\n          var func = new Function(jsSource);\n\n          return {\n              jsSource: jsSource,\n              function: func,\n              exposedFunctionNames: jsBody.exposedFunctionNames,\n              install: function () {\n                  Object.assign(globalScope, func());\n              },\n          };\n      });\n\n      parser.addCommand(\"js\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"js\")) return;\n          // Parse inputs\n          var inputs = [];\n          if (tokens.matchOpToken(\"(\")) {\n              if (tokens.matchOpToken(\")\")) {\n                  // empty input list\n              } else {\n                  do {\n                      var inp = tokens.requireTokenType(\"IDENTIFIER\");\n                      inputs.push(inp.value);\n                  } while (tokens.matchOpToken(\",\"));\n                  tokens.requireOpToken(\")\");\n              }\n          }\n\n          var jsBody = parser.requireElement(\"jsBody\", tokens);\n          tokens.matchToken(\"end\");\n\n          var func = varargConstructor(Function, inputs.concat([jsBody.jsSource]));\n\n          var command = {\n              jsSource: jsBody.jsSource,\n              function: func,\n              inputs: inputs,\n              op: function (context) {\n                  var args = [];\n                  inputs.forEach(function (input) {\n                      args.push(runtime.resolveSymbol(input, context, 'default'));\n                  });\n                  var result = func.apply(globalScope, args);\n                  if (result && typeof result.then === \"function\") {\n                      return new Promise(function (resolve) {\n                          result.then(function (actualResult) {\n                              context.result = actualResult;\n                              resolve(runtime.findNext(this, context));\n                          });\n                      });\n                  } else {\n                      context.result = result;\n                      return runtime.findNext(this, context);\n                  }\n              },\n          };\n          return command;\n      });\n\n      parser.addCommand(\"async\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"async\")) return;\n          if (tokens.matchToken(\"do\")) {\n              var body = parser.requireElement(\"commandList\", tokens);\n\n              // Append halt\n              var end = body;\n              while (end.next) end = end.next;\n              end.next = runtime.HALT;\n\n              tokens.requireToken(\"end\");\n          } else {\n              var body = parser.requireElement(\"command\", tokens);\n          }\n          var command = {\n              body: body,\n              op: function (context) {\n                  setTimeout(function () {\n                      body.execute(context);\n                  });\n                  return runtime.findNext(this, context);\n              },\n          };\n          parser.setParent(body, command);\n          return command;\n      });\n\n      parser.addCommand(\"tell\", function (parser, runtime, tokens) {\n          var startToken = tokens.currentToken();\n          if (!tokens.matchToken(\"tell\")) return;\n          var value = parser.requireElement(\"expression\", tokens);\n          var body = parser.requireElement(\"commandList\", tokens);\n          if (tokens.hasMore() && !parser.featureStart(tokens.currentToken())) {\n              tokens.requireToken(\"end\");\n          }\n          var slot = \"tell_\" + startToken.start;\n          var tellCmd = {\n              value: value,\n              body: body,\n              args: [value],\n              resolveNext: function (context) {\n                  var iterator = context.meta.iterators[slot];\n                  if (iterator.index < iterator.value.length) {\n                      context.you = iterator.value[iterator.index++];\n                      return body;\n                  } else {\n                      // restore original me\n                      context.you = iterator.originalYou;\n                      if (this.next) {\n                          return this.next;\n                      } else {\n                          return runtime.findNext(this.parent, context);\n                      }\n                  }\n              },\n              op: function (context, value) {\n                  if (value == null) {\n                      value = [];\n                  } else if (!(Array.isArray(value) || value instanceof NodeList)) {\n                      value = [value];\n                  }\n                  context.meta.iterators[slot] = {\n                      originalYou: context.you,\n                      index: 0,\n                      value: value,\n                  };\n                  return this.resolveNext(context);\n              },\n          };\n          parser.setParent(body, tellCmd);\n          return tellCmd;\n      });\n\n      parser.addCommand(\"wait\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"wait\")) return;\n          var command;\n\n          // wait on event\n          if (tokens.matchToken(\"for\")) {\n              tokens.matchToken(\"a\"); // optional \"a\"\n              var events = [];\n              do {\n                  var lookahead = tokens.token(0);\n                  if (lookahead.type === 'NUMBER' || lookahead.type === 'L_PAREN') {\n                      events.push({\n                          time: parser.requireElement('expression', tokens).evaluate() // TODO: do we want to allow async here?\n                      })\n                  } else {\n                      events.push({\n                          name: parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\").evaluate(),\n                          args: parseEventArgs(tokens),\n                      });\n                  }\n              } while (tokens.matchToken(\"or\"));\n\n              if (tokens.matchToken(\"from\")) {\n                  var on = parser.requireElement(\"expression\", tokens);\n              }\n\n              // wait on event\n              command = {\n                  event: events,\n                  on: on,\n                  args: [on],\n                  op: function (context, on) {\n                      var target = on ? on : context.me;\n                      if (!(target instanceof EventTarget))\n                          throw new Error(\"Not a valid event target: \" + this.on.sourceFor());\n                      return new Promise((resolve) => {\n                          var resolved = false;\n                          for (const eventInfo of events) {\n                              var listener = (event) => {\n                                  context.result = event;\n                                  if (eventInfo.args) {\n                                      for (const arg of eventInfo.args) {\n                                          context.locals[arg.value] =\n                                              event[arg.value] || (event.detail ? event.detail[arg.value] : null);\n                                      }\n                                  }\n                                  if (!resolved) {\n                                      resolved = true;\n                                      resolve(runtime.findNext(this, context));\n                                  }\n                              };\n                              if (eventInfo.name){\n                                  target.addEventListener(eventInfo.name, listener, {once: true});\n                              } else if (eventInfo.time != null) {\n                                  setTimeout(listener, eventInfo.time, eventInfo.time)\n                              }\n                          }\n                      });\n                  },\n              };\n              return command;\n          } else {\n              var time;\n              if (tokens.matchToken(\"a\")) {\n                  tokens.requireToken(\"tick\");\n                  time = 0;\n              } else {\n                  time = parser.requireElement(\"expression\", tokens);\n              }\n\n              command = {\n                  type: \"waitCmd\",\n                  time: time,\n                  args: [time],\n                  op: function (context, timeValue) {\n                      return new Promise((resolve) => {\n                          setTimeout(() => {\n                              resolve(runtime.findNext(this, context));\n                          }, timeValue);\n                      });\n                  },\n                  execute: function (context) {\n                      return runtime.unifiedExec(this, context);\n                  },\n              };\n              return command;\n          }\n      });\n\n      // TODO  - colon path needs to eventually become part of ruby-style symbols\n      parser.addGrammarElement(\"dotOrColonPath\", function (parser, runtime, tokens) {\n          var root = tokens.matchTokenType(\"IDENTIFIER\");\n          if (root) {\n              var path = [root.value];\n\n              var separator = tokens.matchOpToken(\".\") || tokens.matchOpToken(\":\");\n              if (separator) {\n                  do {\n                      path.push(tokens.requireTokenType(\"IDENTIFIER\", \"NUMBER\").value);\n                  } while (tokens.matchOpToken(separator.value));\n              }\n\n              return {\n                  type: \"dotOrColonPath\",\n                  path: path,\n                  evaluate: function () {\n                      return path.join(separator ? separator.value : \"\");\n                  },\n              };\n          }\n      });\n\n\n      parser.addGrammarElement(\"eventName\", function (parser, runtime, tokens) {\n          var token;\n          if ((token = tokens.matchTokenType(\"STRING\"))) {\n              return {\n                  evaluate: function() {\n                      return token.value;\n                  },\n              };\n          }\n\n          return parser.parseElement(\"dotOrColonPath\", tokens);\n      });\n\n      function parseSendCmd(cmdType, parser, runtime, tokens) {\n          var eventName = parser.requireElement(\"eventName\", tokens);\n\n          var details = parser.parseElement(\"namedArgumentList\", tokens);\n          if ((cmdType === \"send\" && tokens.matchToken(\"to\")) ||\n              (cmdType === \"trigger\" && tokens.matchToken(\"on\"))) {\n              var toExpr = parser.requireElement(\"expression\", tokens);\n          } else {\n              var toExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n          }\n\n          var sendCmd = {\n              eventName: eventName,\n              details: details,\n              to: toExpr,\n              args: [toExpr, eventName, details],\n              op: function (context, to, eventName, details) {\n                  runtime.nullCheck(to, toExpr);\n                  runtime.forEach(to, function (target) {\n                      runtime.triggerEvent(target, eventName, details, context.me);\n                  });\n                  return runtime.findNext(sendCmd, context);\n              },\n          };\n          return sendCmd;\n      }\n\n      parser.addCommand(\"trigger\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"trigger\")) {\n              return parseSendCmd(\"trigger\", parser, runtime, tokens);\n          }\n      });\n\n      parser.addCommand(\"send\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"send\")) {\n              return parseSendCmd(\"send\", parser, runtime, tokens);\n          }\n      });\n\n      var parseReturnFunction = function (parser, runtime, tokens, returnAValue) {\n          if (returnAValue) {\n              if (parser.commandBoundary(tokens.currentToken())) {\n                  parser.raiseParseError(tokens, \"'return' commands must return a value.  If you do not wish to return a value, use 'exit' instead.\");\n              } else {\n                  var value = parser.requireElement(\"expression\", tokens);\n              }\n          }\n\n          var returnCmd = {\n              value: value,\n              args: [value],\n              op: function (context, value) {\n                  var resolve = context.meta.resolve;\n                  context.meta.returned = true;\n                  context.meta.returnValue = value;\n                  if (resolve) {\n                      if (value) {\n                          resolve(value);\n                      } else {\n                          resolve();\n                      }\n                  }\n                  return runtime.HALT;\n              },\n          };\n          return returnCmd;\n      };\n\n      parser.addCommand(\"return\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"return\")) {\n              return parseReturnFunction(parser, runtime, tokens, true);\n          }\n      });\n\n      parser.addCommand(\"exit\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"exit\")) {\n              return parseReturnFunction(parser, runtime, tokens, false);\n          }\n      });\n\n      parser.addCommand(\"halt\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"halt\")) {\n              if (tokens.matchToken(\"the\")) {\n                  tokens.requireToken(\"event\");\n                  // optional possessive\n                  if (tokens.matchOpToken(\"'\")) {\n                      tokens.requireToken(\"s\");\n                  }\n                  var keepExecuting = true;\n              }\n              if (tokens.matchToken(\"bubbling\")) {\n                  var bubbling = true;\n              } else if (tokens.matchToken(\"default\")) {\n                  var haltDefault = true;\n              }\n              var exit = parseReturnFunction(parser, runtime, tokens, false);\n\n              var haltCmd = {\n                  keepExecuting: true,\n                  bubbling: bubbling,\n                  haltDefault: haltDefault,\n                  exit: exit,\n                  op: function (ctx) {\n                      if (ctx.event) {\n                          if (bubbling) {\n                              ctx.event.stopPropagation();\n                          } else if (haltDefault) {\n                              ctx.event.preventDefault();\n                          } else {\n                              ctx.event.stopPropagation();\n                              ctx.event.preventDefault();\n                          }\n                          if (keepExecuting) {\n                              return runtime.findNext(this, ctx);\n                          } else {\n                              return exit;\n                          }\n                      }\n                  },\n              };\n              return haltCmd;\n          }\n      });\n\n      parser.addCommand(\"log\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"log\")) return;\n          var exprs = [parser.parseElement(\"expression\", tokens)];\n          while (tokens.matchOpToken(\",\")) {\n              exprs.push(parser.requireElement(\"expression\", tokens));\n          }\n          if (tokens.matchToken(\"with\")) {\n              var withExpr = parser.requireElement(\"expression\", tokens);\n          }\n          var logCmd = {\n              exprs: exprs,\n              withExpr: withExpr,\n              args: [withExpr, exprs],\n              op: function (ctx, withExpr, values) {\n                  if (withExpr) {\n                      withExpr.apply(null, values);\n                  } else {\n                      console.log.apply(null, values);\n                  }\n                  return runtime.findNext(this, ctx);\n              },\n          };\n          return logCmd;\n      });\n\n      parser.addCommand(\"throw\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"throw\")) return;\n          var expr = parser.requireElement(\"expression\", tokens);\n          var throwCmd = {\n              expr: expr,\n              args: [expr],\n              op: function (ctx, expr) {\n                  runtime.registerHyperTrace(ctx, expr);\n                  throw expr;\n              },\n          };\n          return throwCmd;\n      });\n\n      var parseCallOrGet = function (parser, runtime, tokens) {\n          var expr = parser.requireElement(\"expression\", tokens);\n          var callCmd = {\n              expr: expr,\n              args: [expr],\n              op: function (context, result) {\n                  context.result = result;\n                  return runtime.findNext(callCmd, context);\n              },\n          };\n          return callCmd;\n      };\n      parser.addCommand(\"call\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"call\")) return;\n          var call = parseCallOrGet(parser, runtime, tokens);\n          if (call.expr && call.expr.type !== \"functionCall\") {\n              parser.raiseParseError(tokens, \"Must be a function invocation\");\n          }\n          return call;\n      });\n      parser.addCommand(\"get\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"get\")) {\n              return parseCallOrGet(parser, runtime, tokens);\n          }\n      });\n\n      parser.addCommand(\"make\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"make\")) return;\n          tokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n\n          var expr = parser.requireElement(\"expression\", tokens);\n\n          var args = [];\n          if (expr.type !== \"queryRef\" && tokens.matchToken(\"from\")) {\n              do {\n                  args.push(parser.requireElement(\"expression\", tokens));\n              } while (tokens.matchOpToken(\",\"));\n          }\n\n          if (tokens.matchToken(\"called\")) {\n              var target = parser.requireElement(\"symbol\", tokens);\n          }\n\n          var command;\n          if (expr.type === \"queryRef\") {\n              command = {\n                  op: function (ctx) {\n                      var match,\n                          tagname = \"div\",\n                          id,\n                          classes = [];\n                      var re = /(?:(^|#|\\.)([^#\\. ]+))/g;\n                      while ((match = re.exec(expr.css))) {\n                          if (match[1] === \"\") tagname = match[2].trim();\n                          else if (match[1] === \"#\") id = match[2].trim();\n                          else classes.push(match[2].trim());\n                      }\n\n                      var result = document.createElement(tagname);\n                      if (id !== undefined) result.id = id;\n                      for (var i = 0; i < classes.length; i++) {\n                          var cls = classes[i];\n                          result.classList.add(cls)\n                      }\n\n                      ctx.result = result;\n                      if (target){\n                          runtime.setSymbol(target.name, ctx, target.scope, result);\n                      }\n\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n              return command;\n          } else {\n              command = {\n                  args: [expr, args],\n                  op: function (ctx, expr, args) {\n                      ctx.result = varargConstructor(expr, args);\n                      if (target){\n                          runtime.setSymbol(target.name, ctx, target.scope, ctx.result);\n                      }\n\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n              return command;\n          }\n      });\n\n      parser.addGrammarElement(\"pseudoCommand\", function (parser, runtime, tokens) {\n\n          let lookAhead = tokens.token(1);\n          if (!(lookAhead && lookAhead.op && (lookAhead.value === '.' || lookAhead.value === \"(\"))) {\n              return null;\n          }\n\n          var expr = parser.requireElement(\"primaryExpression\", tokens);\n\n          var rootRoot = expr.root;\n          var root = expr;\n          while (rootRoot.root != null) {\n              root = root.root;\n              rootRoot = rootRoot.root;\n          }\n\n          if (expr.type !== \"functionCall\") {\n              parser.raiseParseError(tokens, \"Pseudo-commands must be function calls\");\n          }\n\n          if (root.type === \"functionCall\" && root.root.root == null) {\n              if (tokens.matchAnyToken(\"the\", \"to\", \"on\", \"with\", \"into\", \"from\", \"at\")) {\n                  var realRoot = parser.requireElement(\"expression\", tokens);\n              } else if (tokens.matchToken(\"me\")) {\n                  var realRoot = parser.requireElement(\"implicitMeTarget\", tokens);\n              }\n          }\n\n          /** @type {ASTNode} */\n\n          var pseudoCommand\n          if(realRoot){\n              pseudoCommand = {\n                  type: \"pseudoCommand\",\n                  root: realRoot,\n                  argExressions: root.argExressions,\n                  args: [realRoot, root.argExressions],\n                  op: function (context, rootRoot, args) {\n                      runtime.nullCheck(rootRoot, realRoot);\n                      var func = rootRoot[root.root.name];\n                      runtime.nullCheck(func, root);\n                      if (func.hyperfunc) {\n                          args.push(context);\n                      }\n                      context.result = func.apply(rootRoot, args);\n                      return runtime.findNext(pseudoCommand, context);\n                  },\n                  execute: function (context) {\n                      return runtime.unifiedExec(this, context);\n                  },\n              }\n          } else {\n              pseudoCommand = {\n                  type: \"pseudoCommand\",\n                  expr: expr,\n                  args: [expr],\n                  op: function (context, result) {\n                      context.result = result;\n                      return runtime.findNext(pseudoCommand, context);\n                  },\n                  execute: function (context) {\n                      return runtime.unifiedExec(this, context);\n                  },\n              };\n          }\n\n          return pseudoCommand;\n      });\n\n      /**\n      * @param {Parser} parser\n      * @param {Runtime} runtime\n      * @param {Tokens} tokens\n      * @param {*} target\n      * @param {*} value\n      * @returns\n      */\n      var makeSetter = function (parser, runtime, tokens, target, value) {\n          var symbolWrite = target.type === \"symbol\";\n          var attributeWrite = target.type === \"attributeRef\";\n          var styleWrite = target.type === \"styleRef\";\n          var arrayWrite = target.type === \"arrayIndex\";\n\n          if (!(attributeWrite || styleWrite || symbolWrite) && target.root == null) {\n              parser.raiseParseError(tokens, \"Can only put directly into symbols, not references\");\n          }\n\n          var rootElt = null;\n          var prop = null;\n          if (symbolWrite) {\n              // rootElt is null\n          } else if (attributeWrite || styleWrite) {\n              rootElt = parser.requireElement(\"implicitMeTarget\", tokens);\n              var attribute = target;\n          } else if(arrayWrite) {\n              prop = target.firstIndex;\n              rootElt = target.root;\n          } else {\n              prop = target.prop ? target.prop.value : null;\n              var attribute = target.attribute;\n              rootElt = target.root;\n          }\n\n          /** @type {ASTNode} */\n          var setCmd = {\n              target: target,\n              symbolWrite: symbolWrite,\n              value: value,\n              args: [rootElt, prop, value],\n              op: function (context, root, prop, valueToSet) {\n                  if (symbolWrite) {\n                      runtime.setSymbol(target.name, context, target.scope, valueToSet);\n                  } else {\n                      runtime.nullCheck(root, rootElt);\n                      if (arrayWrite) {\n                          root[prop] = valueToSet;\n                      } else {\n                          runtime.implicitLoop(root, function (elt) {\n                              if (attribute) {\n                                  if (attribute.type === \"attributeRef\") {\n                                      if (valueToSet == null) {\n                                          elt.removeAttribute(attribute.name);\n                                      } else {\n                                          elt.setAttribute(attribute.name, valueToSet);\n                                      }\n                                  } else {\n                                      elt.style[attribute.name] = valueToSet;\n                                  }\n                              } else {\n                                  elt[prop] = valueToSet;\n                              }\n                          });\n                      }\n                  }\n                  return runtime.findNext(this, context);\n              },\n              parent: undefined\n          };\n          return setCmd;\n      };\n\n      parser.addCommand(\"default\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"default\")) return;\n          var target = parser.requireElement(\"assignableExpression\", tokens);\n          tokens.requireToken(\"to\");\n\n          var value = parser.requireElement(\"expression\", tokens);\n\n          /** @type {ASTNode} */\n          var setter = makeSetter(parser, runtime, tokens, target, value);\n          var defaultCmd = {\n              target: target,\n              value: value,\n              setter: setter,\n              args: [target],\n              op: function (context, target) {\n                  if (target) {\n                      return runtime.findNext(this, context);\n                  } else {\n                      return setter;\n                  }\n              },\n          };\n          setter.parent = defaultCmd;\n          return defaultCmd;\n      });\n\n      parser.addCommand(\"set\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"set\")) return;\n          if (tokens.currentToken().type === \"L_BRACE\") {\n              var obj = parser.requireElement(\"objectLiteral\", tokens);\n              tokens.requireToken(\"on\");\n              var target = parser.requireElement(\"expression\", tokens);\n\n              var command = {\n                  objectLiteral: obj,\n                  target: target,\n                  args: [obj, target],\n                  op: function (ctx, obj, target) {\n                      Object.assign(target, obj);\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n              return command;\n          }\n\n          try {\n              tokens.pushFollow(\"to\");\n              var target = parser.requireElement(\"assignableExpression\", tokens);\n          } finally {\n              tokens.popFollow();\n          }\n          tokens.requireToken(\"to\");\n          var value = parser.requireElement(\"expression\", tokens);\n          return makeSetter(parser, runtime, tokens, target, value);\n      });\n\n      parser.addCommand(\"if\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"if\")) return;\n          var expr = parser.requireElement(\"expression\", tokens);\n          tokens.matchToken(\"then\"); // optional 'then'\n          var trueBranch = parser.parseElement(\"commandList\", tokens);\n          if (tokens.matchToken(\"else\") || tokens.matchToken(\"otherwise\")) {\n              var falseBranch = parser.parseElement(\"commandList\", tokens);\n          }\n          if (tokens.hasMore()) {\n              tokens.requireToken(\"end\");\n          }\n\n          /** @type {ASTNode} */\n          var ifCmd = {\n              expr: expr,\n              trueBranch: trueBranch,\n              falseBranch: falseBranch,\n              args: [expr],\n              op: function (context, exprValue) {\n                  if (exprValue) {\n                      return trueBranch;\n                  } else if (falseBranch) {\n                      return falseBranch;\n                  } else {\n                      return runtime.findNext(this, context);\n                  }\n              },\n          };\n          parser.setParent(trueBranch, ifCmd);\n          parser.setParent(falseBranch, ifCmd);\n          return ifCmd;\n      });\n\n      var parseRepeatExpression = function (parser, tokens, runtime, startedWithForToken) {\n          var innerStartToken = tokens.currentToken();\n          var identifier;\n          if (tokens.matchToken(\"for\") || startedWithForToken) {\n              var identifierToken = tokens.requireTokenType(\"IDENTIFIER\");\n              identifier = identifierToken.value;\n              tokens.requireToken(\"in\");\n              var expression = parser.requireElement(\"expression\", tokens);\n          } else if (tokens.matchToken(\"in\")) {\n              identifier = \"it\";\n              var expression = parser.requireElement(\"expression\", tokens);\n          } else if (tokens.matchToken(\"while\")) {\n              var whileExpr = parser.requireElement(\"expression\", tokens);\n          } else if (tokens.matchToken(\"until\")) {\n              var isUntil = true;\n              if (tokens.matchToken(\"event\")) {\n                  var evt = parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\");\n                  if (tokens.matchToken(\"from\")) {\n                      var on = parser.requireElement(\"expression\", tokens);\n                  }\n              } else {\n                  var whileExpr = parser.requireElement(\"expression\", tokens);\n              }\n          } else {\n              if (!parser.commandBoundary(tokens.currentToken()) &&\n                  tokens.currentToken().value !== 'forever') {\n                  var times = parser.requireElement(\"expression\", tokens);\n                  tokens.requireToken(\"times\");\n              } else {\n                  tokens.matchToken(\"forever\"); // consume optional forever\n                  var forever = true;\n              }\n          }\n\n          if (tokens.matchToken(\"index\")) {\n              var identifierToken = tokens.requireTokenType(\"IDENTIFIER\");\n              var indexIdentifier = identifierToken.value;\n          }\n\n          var loop = parser.parseElement(\"commandList\", tokens);\n          if (loop && evt) {\n              // if this is an event based loop, wait a tick at the end of the loop so that\n              // events have a chance to trigger in the loop condition o_O)))\n              var last = loop;\n              while (last.next) {\n                  last = last.next;\n              }\n              var waitATick = {\n                  type: \"waitATick\",\n                  op: function () {\n                      return new Promise(function (resolve) {\n                          setTimeout(function () {\n                              resolve(runtime.findNext(waitATick));\n                          }, 0);\n                      });\n                  },\n              };\n              last.next = waitATick;\n          }\n          if (tokens.hasMore()) {\n              tokens.requireToken(\"end\");\n          }\n\n          if (identifier == null) {\n              identifier = \"_implicit_repeat_\" + innerStartToken.start;\n              var slot:string = identifier;\n          } else {\n              var slot:string = identifier + \"_\" + innerStartToken.start;\n          }\n\n          var repeatCmd = {\n              identifier: identifier,\n              indexIdentifier: indexIdentifier,\n              slot: slot,\n              expression: expression,\n              forever: forever,\n              times: times,\n              until: isUntil,\n              event: evt,\n              on: on,\n              whileExpr: whileExpr,\n              resolveNext: function () {\n                  return this;\n              },\n              loop: loop,\n              args: [whileExpr, times],\n              op: function (context, whileValue, times) {\n                  var iteratorInfo = context.meta.iterators[slot];\n                  var keepLooping = false;\n                  var loopVal = null;\n                  if (this.forever) {\n                      keepLooping = true;\n                  } else if (this.until) {\n                      if (evt) {\n                          keepLooping = context.meta.iterators[slot].eventFired === false;\n                      } else {\n                          keepLooping = whileValue !== true;\n                      }\n                  } else if (whileExpr) {\n                      keepLooping = whileValue;\n                  } else if (times) {\n                      keepLooping = iteratorInfo.index < times;\n                  } else {\n                      var nextValFromIterator = iteratorInfo.iterator.next();\n                      keepLooping = !nextValFromIterator.done;\n                      loopVal = nextValFromIterator.value;\n                  }\n\n                  if (keepLooping) {\n                      if (iteratorInfo.value) {\n                          context.result = context.locals[identifier] = loopVal;\n                      } else {\n                          context.result = iteratorInfo.index;\n                      }\n                      if (indexIdentifier) {\n                          context.locals[indexIdentifier] = iteratorInfo.index;\n                      }\n                      iteratorInfo.index++;\n                      return loop;\n                  } else {\n                      context.meta.iterators[slot] = null;\n                      return runtime.findNext(this.parent, context);\n                  }\n              },\n          };\n          parser.setParent(loop, repeatCmd);\n          var repeatInit = {\n              name: \"repeatInit\",\n              args: [expression, evt, on],\n              op: function (context, value, event, on) {\n                  var iteratorInfo = {\n                    iterator: undefined,\n                      index: 0,\n                      value: value,\n                      eventFired: false,\n                  };\n                  context.meta.iterators[slot] = iteratorInfo;\n                  if (value && value[Symbol.iterator]) {\n                      iteratorInfo.iterator = value[Symbol.iterator]();\n                  }\n                  if (evt) {\n                      var target = on || context.me;\n                      target.addEventListener(\n                          event,\n                          function (e) {\n                              context.meta.iterators[slot].eventFired = true;\n                          },\n                          { once: true }\n                      );\n                  }\n                  return repeatCmd; // continue to loop\n              },\n              execute: function (context) {\n                  return runtime.unifiedExec(this, context);\n              },\n          };\n          parser.setParent(repeatCmd, repeatInit);\n          return repeatInit;\n      };\n\n      parser.addCommand(\"repeat\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"repeat\")) {\n              return parseRepeatExpression(parser, tokens, runtime, false);\n          }\n      });\n\n      parser.addCommand(\"for\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"for\")) {\n              return parseRepeatExpression(parser, tokens, runtime, true);\n          }\n      });\n\n    parser.addCommand(\"continue\", function (parser, runtime, tokens) {\n\n      if (!tokens.matchToken(\"continue\")) return;\n\n      var command = {\n        op: function (context) {\n\n          // scan for the closest repeat statement\n          for (var parent = this.parent ; true ; parent = parent.parent) {\n\n            if (parent == undefined) {\n              parser.raiseParseError(tokens, \"Command `continue` cannot be used outside of a `repeat` loop.\")\n            }\n            if (parent.loop != undefined) {\n              return parent.resolveNext(context)\n            }\n          }\n        }\n      };\n      return command;\n    });\n\n    parser.addCommand(\"break\", function (parser, runtime, tokens) {\n\n      if (!tokens.matchToken(\"break\")) return;\n\n      var command = {\n        op: function (context) {\n\n          // scan for the closest repeat statement\n          for (var parent = this.parent ; true ; parent = parent.parent) {\n\n            if (parent == undefined) {\n              parser.raiseParseError(tokens, \"Command `continue` cannot be used outside of a `repeat` loop.\")\n            }\n            if (parent.loop != undefined) {\n                return runtime.findNext(parent.parent, context);\n            }\n          }\n        }\n      };\n      return command;\n    });\n\n      parser.addGrammarElement(\"stringLike\", function (parser, runtime, tokens) {\n          return parser.parseAnyOf([\"string\", \"nakedString\"], tokens);\n      });\n\n      parser.addCommand(\"append\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"append\")) return;\n          var targetExpr = null;\n\n          var value = parser.requireElement(\"expression\", tokens);\n\n          /** @type {ASTNode} */\n          var implicitResultSymbol = {\n              type: \"symbol\",\n              evaluate: function (context) {\n                  return runtime.resolveSymbol(\"result\", context);\n              },\n          };\n\n          if (tokens.matchToken(\"to\")) {\n              targetExpr = parser.requireElement(\"expression\", tokens);\n          } else {\n              targetExpr = implicitResultSymbol;\n          }\n\n          var setter = null;\n          if (targetExpr.type === \"symbol\" || targetExpr.type === \"attributeRef\" || targetExpr.root != null) {\n              setter = makeSetter(parser, runtime, tokens, targetExpr, implicitResultSymbol);\n          }\n\n          var command = {\n              value: value,\n              target: targetExpr,\n              args: [targetExpr, value],\n              op: function (context, target, value) {\n                  if (Array.isArray(target)) {\n                      target.push(value);\n                      return runtime.findNext(this, context);\n                  } else if (target instanceof Element) {\n                      target.innerHTML += value;\n                      return runtime.findNext(this, context);\n                  } else if(setter) {\n                      context.result = (target || \"\") + value;\n                      return setter;\n                  } else {\n                      throw Error(\"Unable to append a value!\")\n                  }\n              },\n              execute: function (context) {\n                  return runtime.unifiedExec(this, context/*, value, target*/);\n              },\n          };\n\n          if (setter != null) {\n              setter.parent = command;\n          }\n\n          return command;\n      });\n\n      function parsePickRange(parser, runtime, tokens) {\n          tokens.matchToken(\"at\") || tokens.matchToken(\"from\");\n          const rv = { from:undefined, to:undefined, includeStart:true, includeEnd:false, toEnd:undefined }\n\n          rv.from = tokens.matchToken(\"start\") ? 0 : parser.requireElement(\"expression\", tokens)\n\n          if (tokens.matchToken(\"to\") || tokens.matchOpToken(\"..\")) {\n            if (tokens.matchToken(\"end\")) {\n              rv.toEnd = true;\n            } else {\n              rv.to = parser.requireElement(\"expression\", tokens);\n            }\n          }\n\n          if (tokens.matchToken(\"inclusive\")) rv.includeEnd = true;\n          else if (tokens.matchToken(\"exclusive\")) rv.includeStart = false;\n\n          return rv;\n      }\n\n      class RegExpIterator {\n        public re:RegExp\n        public flags:string\n        public str:string\n\n        constructor(re, str) {\n          this.re = re;\n          this.str = str;\n        }\n\n        next() {\n          const match = this.re.exec(this.str);\n          if (match === null) return { done: true };\n          else return { value: match };\n        }\n      }\n\n      class RegExpIterable {\n        public re:RegExp\n        public flags:string\n        public str:string\n\n        constructor(re, flags, str) {\n          this.re = re;\n          this.flags = flags;\n          this.str = str;\n        }\n\n        [Symbol.iterator]() {\n          return new RegExpIterator(new RegExp(this.re, this.flags), this.str);\n        }\n      }\n\n      parser.addCommand(\"pick\", (parser, runtime, tokens) => {\n        if (!tokens.matchToken(\"pick\")) return;\n\n        tokens.matchToken(\"the\");\n\n        if (tokens.matchToken(\"item\") || tokens.matchToken(\"items\")\n         || tokens.matchToken(\"character\") || tokens.matchToken(\"characters\")) {\n          const range = parsePickRange(parser, runtime, tokens);\n\n          tokens.requireToken(\"from\");\n          const root = parser.requireElement(\"expression\", tokens);\n\n          return {\n            args: [root, range.from, range.to],\n            op(ctx, root, from, to) {\n              if (range.toEnd) to = root.length;\n              if (!range.includeStart) from++;\n              if (range.includeEnd) to++;\n              if (to == null || to == undefined) to = from + 1;\n              ctx.result = root.slice(from, to);\n              return runtime.findNext(this, ctx);\n            }\n          }\n        }\n\n        if (tokens.matchToken(\"match\")) {\n          tokens.matchToken(\"of\");\n          const re = parser.parseElement(\"expression\", tokens);\n          let flags = \"\"\n          if (tokens.matchOpToken(\"|\")) {\n            flags = tokens.requireToken(\"identifier\").value;\n          }\n\n          tokens.requireToken(\"from\");\n          const root = parser.parseElement(\"expression\", tokens);\n\n          return {\n            args: [root, re],\n            op(ctx, root, re) {\n              ctx.result = new RegExp(re, flags).exec(root);\n              return runtime.findNext(this, ctx);\n            }\n          }\n        }\n\n        if (tokens.matchToken(\"matches\")) {\n          tokens.matchToken(\"of\");\n          const re = parser.parseElement(\"expression\", tokens);\n          let flags = \"gu\"\n          if (tokens.matchOpToken(\"|\")) {\n            flags = 'g' + tokens.requireToken(\"identifier\").value.replace('g', '');\n          }\n          console.log('flags', flags)\n\n          tokens.requireToken(\"from\");\n          const root = parser.parseElement(\"expression\", tokens);\n\n          return {\n            args: [root, re],\n            op(ctx, root, re) {\n              ctx.result = new RegExpIterable(re, flags, root);\n              return runtime.findNext(this, ctx);\n            }\n          }\n        }\n      });\n  \n      parser.addCommand(\"increment\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"increment\")) return;\n          var amountExpr;\n  \n          // This is optional.  Defaults to \"result\"\n          var target = parser.parseElement(\"assignableExpression\", tokens);\n  \n          // This is optional. Defaults to 1.\n          if (tokens.matchToken(\"by\")) {\n              amountExpr = parser.requireElement(\"expression\", tokens);\n          }\n  \n          var implicitIncrementOp = {\n              type: \"implicitIncrementOp\",\n              target: target,\n              args: [target, amountExpr],\n              op: function (context, targetValue, amount) {\n                  targetValue = targetValue ? parseFloat(targetValue) : 0;\n                  amount = amountExpr ? parseFloat(amount) : 1;\n                  var newValue = targetValue + amount;\n                  context.result = newValue;\n                  return newValue;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              }\n          };\n\n          return makeSetter(parser, runtime, tokens, target, implicitIncrementOp);\n      });\n  \n      parser.addCommand(\"decrement\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"decrement\")) return;\n          var amountExpr;\n  \n          // This is optional.  Defaults to \"result\"\n          var target = parser.parseElement(\"assignableExpression\", tokens);\n  \n          // This is optional. Defaults to 1.\n          if (tokens.matchToken(\"by\")) {\n              amountExpr = parser.requireElement(\"expression\", tokens);\n          }\n  \n          var implicitDecrementOp = {\n              type: \"implicitDecrementOp\",\n              target: target,\n              args: [target, amountExpr],\n              op: function (context, targetValue, amount) {\n                  targetValue = targetValue ? parseFloat(targetValue) : 0;\n                  amount = amountExpr ? parseFloat(amount) : 1;\n                  var newValue = targetValue - amount;\n                  context.result = newValue;\n                  return newValue;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              }\n          };\n\n          return makeSetter(parser, runtime, tokens, target, implicitDecrementOp);\n      });\n\n      function parseConversionInfo(tokens, parser) {\n          var type = \"text\";\n          var conversion;\n          tokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n          if (tokens.matchToken(\"json\") || tokens.matchToken(\"Object\")) {\n              type = \"json\";\n          } else if (tokens.matchToken(\"response\")) {\n              type = \"response\";\n          } else if (tokens.matchToken(\"html\")) {\n              type = \"html\";\n          } else if (tokens.matchToken(\"text\")) {\n              // default, ignore\n          } else {\n              conversion = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n          }\n          return {type, conversion};\n      }\n\n      parser.addCommand(\"fetch\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"fetch\")) return;\n          var url = parser.requireElement(\"stringLike\", tokens);\n\n          if (tokens.matchToken(\"as\")) {\n              var conversionInfo = parseConversionInfo(tokens, parser);\n          }\n\n          if (tokens.matchToken(\"with\") && tokens.currentToken().value !== \"{\") {\n              var args = parser.parseElement(\"nakedNamedArgumentList\", tokens);\n          } else {\n              var args = parser.parseElement(\"objectLiteral\", tokens);\n          }\n\n          if (conversionInfo == null && tokens.matchToken(\"as\")) {\n              conversionInfo = parseConversionInfo(tokens, parser);\n          }\n\n          var type = conversionInfo ? conversionInfo.type : \"text\";\n          var conversion = conversionInfo ? conversionInfo.conversion : null\n\n          /** @type {ASTNode} */\n          var fetchCmd = {\n              url: url,\n              argExpressions: args,\n              args: [url, args],\n              op: function (context, url, args) {\n                  var detail = args || {};\n                  detail[\"sender\"] = context.me;\n                  detail[\"headers\"] = detail[\"headers\"] || {}\n                  var abortController = new AbortController();\n                  let abortListener = context.me.addEventListener('fetch:abort', function(){\n                      abortController.abort();\n                  }, {once: true});\n                  detail['signal'] = abortController.signal;\n                  runtime.triggerEvent(context.me, \"hyperscript:beforeFetch\", detail);\n                  runtime.triggerEvent(context.me, \"fetch:beforeRequest\", detail);\n                  args = detail;\n                  var finished = false;\n                  if (args.timeout) {\n                      setTimeout(function () {\n                          if (!finished) {\n                              abortController.abort();\n                          }\n                      }, args.timeout);\n                  }\n                  return fetch(url, args)\n                      .then(function (resp) {\n                          let resultDetails = {response:resp};\n                          runtime.triggerEvent(context.me, \"fetch:afterResponse\", resultDetails);\n                          resp = resultDetails.response;\n\n                          if (type === \"response\") {\n                              context.result = resp;\n                              runtime.triggerEvent(context.me, \"fetch:afterRequest\", {result:resp});\n                              finished = true;\n                              return runtime.findNext(fetchCmd, context);\n                          }\n                          if (type === \"json\") {\n                              return resp.json().then(function (result) {\n                                  context.result = result;\n                                  runtime.triggerEvent(context.me, \"fetch:afterRequest\", {result});\n                                  finished = true;\n                                  return runtime.findNext(fetchCmd, context);\n                              });\n                          }\n                          return resp.text().then(function (result) {\n                              if (conversion) result = runtime.convertValue(result, conversion);\n\n                              if (type === \"html\") result = runtime.convertValue(result, \"Fragment\");\n\n                              context.result = result;\n                              runtime.triggerEvent(context.me, \"fetch:afterRequest\", {result});\n                              finished = true;\n                              return runtime.findNext(fetchCmd, context);\n                          });\n                      })\n                      .catch(function (reason) {\n                          runtime.triggerEvent(context.me, \"fetch:error\", {\n                              reason: reason,\n                          });\n                          throw reason;\n                      }).finally(function(){\n                          context.me.removeEventListener('fetch:abort', abortListener);\n                      });\n              },\n          };\n          return fetchCmd;\n      });\n  }\n\n  function hyperscriptWebGrammar(parser) {\n      parser.addCommand(\"settle\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"settle\")) {\n              if (!parser.commandBoundary(tokens.currentToken())) {\n                  var onExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  var onExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              }\n\n              var settleCommand = {\n                  type: \"settleCmd\",\n                  args: [onExpr],\n                  op: function (context, on) {\n                      runtime.nullCheck(on, onExpr);\n                      var resolve = null;\n                      var resolved = false;\n                      var transitionStarted = false;\n\n                      var promise = new Promise(function (r) {\n                          resolve = r;\n                      });\n\n                      // listen for a transition begin\n                      on.addEventListener(\n                          \"transitionstart\",\n                          function () {\n                              transitionStarted = true;\n                          },\n                          { once: true }\n                      );\n\n                      // if no transition begins in 500ms, cancel\n                      setTimeout(function () {\n                          if (!transitionStarted && !resolved) {\n                              resolve(runtime.findNext(settleCommand, context));\n                          }\n                      }, 500);\n\n                      // continue on a transition emd\n                      on.addEventListener(\n                          \"transitionend\",\n                          function () {\n                              if (!resolved) {\n                                  resolve(runtime.findNext(settleCommand, context));\n                              }\n                          },\n                          { once: true }\n                      );\n                      return promise;\n                  },\n                  execute: function (context) {\n                      return runtime.unifiedExec(this, context);\n                  },\n              };\n              return settleCommand;\n          }\n      });\n\n      parser.addCommand(\"add\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"add\")) {\n              var classRef = parser.parseElement(\"classRef\", tokens);\n              var attributeRef = null;\n              var cssDeclaration = null;\n              if (classRef == null) {\n                  attributeRef = parser.parseElement(\"attributeRef\", tokens);\n                  if (attributeRef == null) {\n                      cssDeclaration = parser.parseElement(\"styleLiteral\", tokens);\n                      if (cssDeclaration == null) {\n                          parser.raiseParseError(tokens, \"Expected either a class reference or attribute expression\");\n                      }\n                  }\n              } else {\n                  var classRefs = [classRef];\n                  while ((classRef = parser.parseElement(\"classRef\", tokens))) {\n                      classRefs.push(classRef);\n                  }\n              }\n\n              if (tokens.matchToken(\"to\")) {\n                  var toExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  var toExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              }\n\n              if (tokens.matchToken(\"when\")) {\n                  if (cssDeclaration) {\n                      parser.raiseParseError(tokens, \"Only class and properties are supported with a when clause\")\n                  }\n                  var when = parser.requireElement(\"expression\", tokens);\n              }\n\n              if (classRefs) {\n                  return {\n                      classRefs: classRefs,\n                      to: toExpr,\n                      args: [toExpr, classRefs],\n                      op: function (context, to, classRefs) {\n                          runtime.nullCheck(to, toExpr);\n                          runtime.forEach(classRefs, function (classRef) {\n                              runtime.implicitLoop(to, function (target) {\n                                  if (when) {\n                                      context.result = target;\n                                      let whenResult = runtime.evaluateNoPromise(when, context);\n                                      if (whenResult) {\n                                          if (target instanceof Element) target.classList.add(classRef.className);\n                                      } else {\n                                          if (target instanceof Element) target.classList.remove(classRef.className);\n                                      }\n                                      context.result = null;\n                                  } else {\n                                      if (target instanceof Element) target.classList.add(classRef.className);\n                                  }\n                              });\n                          });\n                          return runtime.findNext(this, context);\n                      },\n                  };\n              } else if (attributeRef) {\n                  return {\n                      type: \"addCmd\",\n                      attributeRef: attributeRef,\n                      to: toExpr,\n                      args: [toExpr],\n                      op: function (context, to, attrRef) {\n                          runtime.nullCheck(to, toExpr);\n                          runtime.implicitLoop(to, function (target) {\n                              if (when) {\n                                  context.result = target;\n                                  let whenResult = runtime.evaluateNoPromise(when, context);\n                                  if (whenResult) {\n                                      target.setAttribute(attributeRef.name, attributeRef.value);\n                                  } else {\n                                      target.removeAttribute(attributeRef.name);\n                                  }\n                                  context.result = null;\n                              } else {\n                                  target.setAttribute(attributeRef.name, attributeRef.value);\n                              }\n                          });\n                          return runtime.findNext(this, context);\n                      },\n                      execute: function (ctx) {\n                          return runtime.unifiedExec(this, ctx);\n                      },\n                  };\n              } else {\n                  return {\n                      type: \"addCmd\",\n                      cssDeclaration: cssDeclaration,\n                      to: toExpr,\n                      args: [toExpr, cssDeclaration],\n                      op: function (context, to, css) {\n                          runtime.nullCheck(to, toExpr);\n                          runtime.implicitLoop(to, function (target) {\n                              target.style.cssText += css;\n                          });\n                          return runtime.findNext(this, context);\n                      },\n                      execute: function (ctx) {\n                          return runtime.unifiedExec(this, ctx);\n                      },\n                  };\n              }\n          }\n      });\n\n      parser.addGrammarElement(\"styleLiteral\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"{\")) return;\n\n          var stringParts = [\"\"]\n          var exprs = []\n\n          while (tokens.hasMore()) {\n              if (tokens.matchOpToken(\"\\\\\")) {\n                  tokens.consumeToken();\n              } else if (tokens.matchOpToken(\"}\")) {\n                  break;\n              } else if (tokens.matchToken(\"$\")) {\n                  var opencurly = tokens.matchOpToken(\"{\");\n                  var expr = parser.parseElement(\"expression\", tokens);\n                  if (opencurly) tokens.requireOpToken(\"}\");\n\n                  exprs.push(expr)\n                  stringParts.push(\"\")\n              } else {\n                  var tok = tokens.consumeToken();\n                  stringParts[stringParts.length-1] += tokens.source.substring(tok.start, tok.end);\n              }\n\n              stringParts[stringParts.length-1] += tokens.lastWhitespace();\n          }\n\n          return {\n              type: \"styleLiteral\",\n              args: [exprs],\n              op: function (ctx, exprs) {\n                  var rv = \"\";\n\n                  stringParts.forEach(function (part, idx) {\n                      rv += part;\n                      if (idx in exprs) rv += exprs[idx];\n                  });\n\n                  return rv;\n              },\n              evaluate: function(ctx) {\n                  return runtime.unifiedEval(this, ctx);\n              }\n          }\n      })\n\n      parser.addCommand(\"remove\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"remove\")) {\n              var classRef = parser.parseElement(\"classRef\", tokens);\n              var attributeRef = null;\n              var elementExpr = null;\n              if (classRef == null) {\n                  attributeRef = parser.parseElement(\"attributeRef\", tokens);\n                  if (attributeRef == null) {\n                      elementExpr = parser.parseElement(\"expression\", tokens);\n                      if (elementExpr == null) {\n                          parser.raiseParseError(\n                              tokens,\n                              \"Expected either a class reference, attribute expression or value expression\"\n                          );\n                      }\n                  }\n              } else {\n                  var classRefs = [classRef];\n                  while ((classRef = parser.parseElement(\"classRef\", tokens))) {\n                      classRefs.push(classRef);\n                  }\n              }\n\n              if (tokens.matchToken(\"from\")) {\n                  var fromExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  if (elementExpr == null) {\n                      var fromExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n                  }\n              }\n\n              if (elementExpr) {\n                  return {\n                      elementExpr: elementExpr,\n                      from: fromExpr,\n                      args: [elementExpr, fromExpr],\n                      op: function (context, element, from) {\n                          runtime.nullCheck(element, elementExpr);\n                          runtime.implicitLoop(element, function (target) {\n                              if (target.parentElement && (from == null || from.contains(target))) {\n                                  target.parentElement.removeChild(target);\n                              }\n                          });\n                          return runtime.findNext(this, context);\n                      },\n                  };\n              } else {\n                  return {\n                      classRefs: classRefs,\n                      attributeRef: attributeRef,\n                      elementExpr: elementExpr,\n                      from: fromExpr,\n                      args: [classRefs, fromExpr],\n                      op: function (context, classRefs, from) {\n                          runtime.nullCheck(from, fromExpr);\n                          if (classRefs) {\n                              runtime.forEach(classRefs, function (classRef) {\n                                  runtime.implicitLoop(from, function (target) {\n                                      target.classList.remove(classRef.className);\n                                  });\n                              });\n                          } else {\n                              runtime.implicitLoop(from, function (target) {\n                                  target.removeAttribute(attributeRef.name);\n                              });\n                          }\n                          return runtime.findNext(this, context);\n                      },\n                  };\n              }\n          }\n      });\n\n      parser.addCommand(\"toggle\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"toggle\")) {\n              tokens.matchAnyToken(\"the\", \"my\");\n              if (tokens.currentToken().type === \"STYLE_REF\") {\n                  let styleRef = tokens.consumeToken();\n                  var name = styleRef.value.substr(1);\n                  var visibility = true;\n                  var hideShowStrategy = resolveStrategy(parser, tokens, name);\n                  if (tokens.matchToken(\"of\")) {\n                      tokens.pushFollow(\"with\");\n                      try {\n                          var onExpr = parser.requireElement(\"expression\", tokens);\n                      } finally {\n                          tokens.popFollow();\n                      }\n                  } else {\n                      var onExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n                  }\n              } else if (tokens.matchToken(\"between\")) {\n                  var between = true;\n                  var classRef = parser.parseElement(\"classRef\", tokens);\n                  tokens.requireToken(\"and\");\n                  var classRef2 = parser.requireElement(\"classRef\", tokens);\n              } else {\n                  var classRef = parser.parseElement(\"classRef\", tokens);\n                  var attributeRef = null;\n                  if (classRef == null) {\n                      attributeRef = parser.parseElement(\"attributeRef\", tokens);\n                      if (attributeRef == null) {\n                          parser.raiseParseError(tokens, \"Expected either a class reference or attribute expression\");\n                      }\n                  } else {\n                      var classRefs = [classRef];\n                      while ((classRef = parser.parseElement(\"classRef\", tokens))) {\n                          classRefs.push(classRef);\n                      }\n                  }\n              }\n\n              if (visibility !== true) {\n                  if (tokens.matchToken(\"on\")) {\n                      var onExpr = parser.requireElement(\"expression\", tokens);\n                  } else {\n                      var onExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n                  }\n              }\n\n              if (tokens.matchToken(\"for\")) {\n                  var time = parser.requireElement(\"expression\", tokens);\n              } else if (tokens.matchToken(\"until\")) {\n                  var evt = parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\");\n                  if (tokens.matchToken(\"from\")) {\n                      var from = parser.requireElement(\"expression\", tokens);\n                  }\n              }\n\n              var toggleCmd = {\n                  classRef: classRef,\n                  classRef2: classRef2,\n                  classRefs: classRefs,\n                  attributeRef: attributeRef,\n                  on: onExpr,\n                  time: time,\n                  evt: evt,\n                  from: from,\n                  toggle: function (on, classRef, classRef2, classRefs) {\n                      runtime.nullCheck(on, onExpr);\n                      if (visibility) {\n                          runtime.implicitLoop(on, function (target) {\n                              hideShowStrategy(\"toggle\", target);\n                          });\n                      } else if (between) {\n                          runtime.implicitLoop(on, function (target) {\n                              if (target.classList.contains(classRef.className)) {\n                                  target.classList.remove(classRef.className);\n                                  target.classList.add(classRef2.className);\n                              } else {\n                                  target.classList.add(classRef.className);\n                                  target.classList.remove(classRef2.className);\n                              }\n                          });\n                      } else if (classRefs) {\n                          runtime.forEach(classRefs, function (classRef) {\n                              runtime.implicitLoop(on, function (target) {\n                                  target.classList.toggle(classRef.className);\n                              });\n                          });\n                      } else {\n                          runtime.forEach(on, function (target) {\n                              if (target.hasAttribute(attributeRef.name)) {\n                                  target.removeAttribute(attributeRef.name);\n                              } else {\n                                  target.setAttribute(attributeRef.name, attributeRef.value);\n                              }\n                          });\n                      }\n                  },\n                  args: [onExpr, time, evt, from, classRef, classRef2, classRefs],\n                  op: function (context, on, time, evt, from, classRef, classRef2, classRefs) {\n                      if (time) {\n                          return new Promise(function (resolve) {\n                              toggleCmd.toggle(on, classRef, classRef2, classRefs);\n                              setTimeout(function () {\n                                  toggleCmd.toggle(on, classRef, classRef2, classRefs);\n                                  resolve(runtime.findNext(toggleCmd, context));\n                              }, time);\n                          });\n                      } else if (evt) {\n                          return new Promise(function (resolve) {\n                              var target = from || context.me;\n                              target.addEventListener(\n                                  evt,\n                                  function () {\n                                      toggleCmd.toggle(on, classRef, classRef2, classRefs);\n                                      resolve(runtime.findNext(toggleCmd, context));\n                                  },\n                                  { once: true }\n                              );\n                              toggleCmd.toggle(on, classRef, classRef2, classRefs);\n                          });\n                      } else {\n                          this.toggle(on, classRef, classRef2, classRefs);\n                          return runtime.findNext(toggleCmd, context);\n                      }\n                  },\n              };\n              return toggleCmd;\n          }\n      });\n\n      var HIDE_SHOW_STRATEGIES = {\n          display: function (op, element, arg) {\n              if (arg) {\n                  element.style.display = arg;\n              } else if (op === \"toggle\") {\n                  if (getComputedStyle(element).display === \"none\") {\n                      HIDE_SHOW_STRATEGIES.display(\"show\", element, arg);\n                  } else {\n                      HIDE_SHOW_STRATEGIES.display(\"hide\", element, arg);\n                  }\n              } else if (op === \"hide\") {\n                  const internalData = parser.runtime.getInternalData(element);\n                  if (internalData.originalDisplay == null) {\n                      internalData.originalDisplay = element.style.display;\n                  }\n                  element.style.display = \"none\";\n              } else {\n                  const internalData = parser.runtime.getInternalData(element);\n                  if (internalData.originalDisplay && internalData.originalDisplay !== 'none') {\n                      element.style.display = internalData.originalDisplay;\n                  } else {\n                      element.style.removeProperty('display');\n                  }\n              }\n          },\n          visibility: function (op, element, arg) {\n              if (arg) {\n                  element.style.visibility = arg;\n              } else if (op === \"toggle\") {\n                  if (getComputedStyle(element).visibility === \"hidden\") {\n                      HIDE_SHOW_STRATEGIES.visibility(\"show\", element, arg);\n                  } else {\n                      HIDE_SHOW_STRATEGIES.visibility(\"hide\", element, arg);\n                  }\n              } else if (op === \"hide\") {\n                  element.style.visibility = \"hidden\";\n              } else {\n                  element.style.visibility = \"visible\";\n              }\n          },\n          opacity: function (op, element, arg) {\n              if (arg) {\n                  element.style.opacity = arg;\n              } else if (op === \"toggle\") {\n                  if (getComputedStyle(element).opacity === \"0\") {\n                      HIDE_SHOW_STRATEGIES.opacity(\"show\", element, arg);\n                  } else {\n                      HIDE_SHOW_STRATEGIES.opacity(\"hide\", element, arg);\n                  }\n              } else if (op === \"hide\") {\n                  element.style.opacity = \"0\";\n              } else {\n                  element.style.opacity = \"1\";\n              }\n          },\n      };\n\n      var parseShowHideTarget = function (parser, runtime, tokens) {\n          var target;\n          var currentTokenValue = tokens.currentToken();\n          if (currentTokenValue.value === \"when\" || currentTokenValue.value === \"with\" || parser.commandBoundary(currentTokenValue)) {\n              target = parser.parseElement(\"implicitMeTarget\", tokens);\n          } else {\n              target = parser.parseElement(\"expression\", tokens);\n          }\n          return target;\n      };\n\n      var resolveStrategy = function (parser, tokens, name) {\n          var configDefault = config.defaultHideShowStrategy;\n          var strategies = HIDE_SHOW_STRATEGIES;\n          if (config.hideShowStrategies) {\n              strategies = Object.assign(strategies, config.hideShowStrategies); // merge in user provided strategies\n          }\n          name = name || configDefault || \"display\";\n          var value = strategies[name];\n          if (value == null) {\n              parser.raiseParseError(tokens, \"Unknown show/hide strategy : \" + name);\n          }\n          return value;\n      };\n\n      parser.addCommand(\"hide\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"hide\")) {\n              var targetExpr = parseShowHideTarget(parser, runtime, tokens);\n\n              var name = null;\n              if (tokens.matchToken(\"with\")) {\n                  name = tokens.requireTokenType(\"IDENTIFIER\", \"STYLE_REF\").value;\n                  if (name.indexOf(\"*\") === 0) {\n                      name = name.substr(1);\n                  }\n              }\n              var hideShowStrategy = resolveStrategy(parser, tokens, name);\n\n              return {\n                  target: targetExpr,\n                  args: [targetExpr],\n                  op: function (ctx, target) {\n                      runtime.nullCheck(target, targetExpr);\n                      runtime.implicitLoop(target, function (elt) {\n                          hideShowStrategy(\"hide\", elt);\n                      });\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n          }\n      });\n\n      parser.addCommand(\"show\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"show\")) {\n              var targetExpr = parseShowHideTarget(parser, runtime, tokens);\n\n              var name = null;\n              if (tokens.matchToken(\"with\")) {\n                  name = tokens.requireTokenType(\"IDENTIFIER\", \"STYLE_REF\").value;\n                  if (name.indexOf(\"*\") === 0) {\n                      name = name.substr(1);\n                  }\n              }\n              var arg = null;\n              if (tokens.matchOpToken(\":\")) {\n                  var tokenArr = tokens.consumeUntilWhitespace();\n                  tokens.matchTokenType(\"WHITESPACE\");\n                  arg = tokenArr\n                      .map(function (t) {\n                          return t.value;\n                      })\n                      .join(\"\");\n              }\n\n              if (tokens.matchToken(\"when\")) {\n                  var when = parser.requireElement(\"expression\", tokens);\n              }\n\n              var hideShowStrategy = resolveStrategy(parser, tokens, name);\n\n              return {\n                  target: targetExpr,\n                  when: when,\n                  args: [targetExpr],\n                  op: function (ctx, target) {\n                      runtime.nullCheck(target, targetExpr);\n                      runtime.implicitLoop(target, function (elt) {\n                          if (when) {\n                              ctx.result = elt;\n                              let whenResult = runtime.evaluateNoPromise(when, ctx);\n                              if (whenResult) {\n                                  hideShowStrategy(\"show\", elt, arg);\n                              } else {\n                                  hideShowStrategy(\"hide\", elt);\n                              }\n                              ctx.result = null;\n                          } else {\n                              hideShowStrategy(\"show\", elt, arg);\n                          }\n                      });\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n          }\n      });\n\n      parser.addCommand(\"take\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"take\")) {\n              var classRef = parser.requireElement(\"classRef\", tokens);\n\n              if (tokens.matchToken(\"from\")) {\n                  var fromExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  var fromExpr = classRef;\n              }\n\n              if (tokens.matchToken(\"for\")) {\n                  var forExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  var forExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              }\n\n              var takeCmd = {\n                  classRef: classRef,\n                  from: fromExpr,\n                  forElt: forExpr,\n                  args: [classRef, fromExpr, forExpr],\n                  op: function (context, eltColl, from, forElt) {\n                      runtime.nullCheck(from, fromExpr);\n                      runtime.nullCheck(forElt, forExpr);\n                      var clazz = eltColl.className;\n                      runtime.implicitLoop(from, function (target) {\n                          target.classList.remove(clazz);\n                      });\n                      runtime.implicitLoop(forElt, function (target) {\n                          target.classList.add(clazz);\n                      });\n                      return runtime.findNext(this, context);\n                  },\n              };\n              return takeCmd;\n          }\n      });\n\n      function putInto(runtime, context, prop, valueToPut) {\n          if (prop != null) {\n              var value = runtime.resolveSymbol(prop, context);\n          } else {\n              var value = context;\n          }\n          if (value instanceof Element || value instanceof HTMLDocument) {\n              while (value.firstChild) value.removeChild(value.firstChild);\n              value.append(parser.runtime.convertValue(valueToPut, \"Fragment\"));\n              runtime.processNode(value);\n          } else {\n              if (prop != null) {\n                  runtime.setSymbol(prop, context, null, valueToPut);\n              } else {\n                  throw \"Don't know how to put a value into \" + typeof context;\n              }\n          }\n      }\n\n      parser.addCommand(\"put\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"put\")) {\n              var value = parser.requireElement(\"expression\", tokens);\n\n              var operationToken = tokens.matchAnyToken(\"into\", \"before\", \"after\");\n\n              if (operationToken == null && tokens.matchToken(\"at\")) {\n                  tokens.matchToken(\"the\"); // optional \"the\"\n                  operationToken = tokens.matchAnyToken(\"start\", \"end\");\n                  tokens.requireToken(\"of\");\n              }\n\n              if (operationToken == null) {\n                  parser.raiseParseError(tokens, \"Expected one of 'into', 'before', 'at start of', 'at end of', 'after'\");\n              }\n              var target = parser.requireElement(\"expression\", tokens);\n\n              var operation = operationToken.value;\n\n              var arrayIndex = false;\n              var symbolWrite = false;\n              var rootExpr = null;\n              var prop = null;\n\n              if (target.type === \"arrayIndex\" && operation === \"into\") {\n                  arrayIndex = true;\n                  prop = target.prop;\n                  rootExpr = target.root;\n              }  else if (target.prop && target.root && operation === \"into\") {\n                  prop = target.prop.value;\n                  rootExpr = target.root;\n              } else if (target.type === \"symbol\" && operation === \"into\") {\n                  symbolWrite = true;\n                  prop = target.name;\n              } else if (target.type === \"attributeRef\" && operation === \"into\") {\n                  var attributeWrite = true;\n                  prop = target.name;\n                  rootExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              } else if (target.type === \"styleRef\" && operation === \"into\") {\n                  var styleWrite = true;\n                  prop = target.name;\n                  rootExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              } else if (target.attribute && operation === \"into\") {\n                  var attributeWrite = target.attribute.type === \"attributeRef\";\n                  var styleWrite = target.attribute.type === \"styleRef\";\n                  prop = target.attribute.name;\n                  rootExpr = target.root;\n              } else {\n                  rootExpr = target;\n              }\n\n              var putCmd = {\n                  target: target,\n                  operation: operation,\n                  symbolWrite: symbolWrite,\n                  value: value,\n                  args: [rootExpr, prop, value],\n                  op: function (context, root, prop, valueToPut) {\n                      if (symbolWrite) {\n                          putInto(runtime, context, prop, valueToPut);\n                      } else {\n                          runtime.nullCheck(root, rootExpr);\n                          if (operation === \"into\") {\n                              if (attributeWrite) {\n                                  runtime.implicitLoop(root, function (elt) {\n                                      elt.setAttribute(prop, valueToPut);\n                                  });\n                              } else if (styleWrite) {\n                                  runtime.implicitLoop(root, function (elt) {\n                                      elt.style[prop] = valueToPut;\n                                  });\n                              } else if (arrayIndex) {\n                                  root[prop] = valueToPut;\n                              } else {\n                                  runtime.implicitLoop(root, function (elt) {\n                                      putInto(runtime, elt, prop, valueToPut);\n                                  });\n                              }\n                          } else {\n                              var op =\n                                  operation === \"before\"\n                                      ? Element.prototype.before\n                                      : operation === \"after\"\n                                      ? Element.prototype.after\n                                      : operation === \"start\"\n                                      ? Element.prototype.prepend\n                                      : operation === \"end\"\n                                      ? Element.prototype.append\n                                      : Element.prototype.append; // unreachable\n\n                              runtime.implicitLoop(root, function (elt) {\n                                  op.call(\n                                      elt,\n                                      valueToPut instanceof Node\n                                          ? valueToPut\n                                          : runtime.convertValue(valueToPut, \"Fragment\")\n                                  );\n                                  // process any new content\n                                  if (elt.parentElement) {\n                                      runtime.processNode(elt.parentElement);\n                                  } else {\n                                      runtime.processNode(elt);\n                                  }\n                              });\n                          }\n                      }\n                      return runtime.findNext(this, context);\n                  },\n              };\n              return putCmd;\n          }\n      });\n\n      function parsePseudopossessiveTarget(parser, runtime, tokens) {\n          var targets;\n          if (\n              tokens.matchToken(\"the\") ||\n              tokens.matchToken(\"element\") ||\n              tokens.matchToken(\"elements\") ||\n              tokens.currentToken().type === \"CLASS_REF\" ||\n              tokens.currentToken().type === \"ID_REF\" ||\n              (tokens.currentToken().op && tokens.currentToken().value === \"<\")\n          ) {\n              parser.possessivesDisabled = true;\n              try {\n                  targets = parser.parseElement(\"expression\", tokens);\n              } finally {\n                  delete parser.possessivesDisabled;\n              }\n              // optional possessive\n              if (tokens.matchOpToken(\"'\")) {\n                  tokens.requireToken(\"s\");\n              }\n          } else if (tokens.currentToken().type === \"IDENTIFIER\" && tokens.currentToken().value === \"its\") {\n              var identifier = tokens.matchToken(\"its\");\n              targets = {\n                  type: \"pseudopossessiveIts\",\n                  token: identifier,\n                  name: identifier.value,\n                  evaluate: function (context) {\n                      return runtime.resolveSymbol(\"it\", context);\n                  },\n              };\n          } else {\n              tokens.matchToken(\"my\") || tokens.matchToken(\"me\"); // consume optional 'my'\n              targets = parser.parseElement(\"implicitMeTarget\", tokens);\n          }\n          return targets;\n      }\n\n      parser.addCommand(\"transition\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"transition\")) {\n              var targetsExpr = parsePseudopossessiveTarget(parser, runtime, tokens);\n\n              var properties = [];\n              var from = [];\n              var to = [];\n              var currentToken = tokens.currentToken();\n              while (\n                  !parser.commandBoundary(currentToken) &&\n                  currentToken.value !== \"over\" &&\n                  currentToken.value !== \"using\"\n              ) {\n                  if (tokens.currentToken().type === \"STYLE_REF\") {\n                      let styleRef = tokens.consumeToken();\n                      let styleProp = styleRef.value.substr(1);\n                      properties.push({\n                          type: \"styleRefValue\",\n                          evaluate: function () {\n                              return styleProp;\n                          },\n                      });\n                  } else {\n                      properties.push(parser.requireElement(\"stringLike\", tokens));\n                  }\n\n                  if (tokens.matchToken(\"from\")) {\n                      from.push(parser.requireElement(\"expression\", tokens));\n                  } else {\n                      from.push(null);\n                  }\n                  tokens.requireToken(\"to\");\n                  if (tokens.matchToken(\"initial\")) {\n                      to.push({\n                          type: \"initial_literal\",\n                          evaluate : function(){\n                              return \"initial\";\n                          }\n                      });\n                  } else {\n                      to.push(parser.requireElement(\"expression\", tokens));\n                  }\n                  currentToken = tokens.currentToken();\n              }\n              if (tokens.matchToken(\"over\")) {\n                  var over = parser.requireElement(\"expression\", tokens);\n              } else if (tokens.matchToken(\"using\")) {\n                  var using = parser.requireElement(\"expression\", tokens);\n              }\n\n              var transition = {\n                  to: to,\n                  args: [targetsExpr, properties, from, to, using, over],\n                  op: function (context, targets, properties, from, to, using, over) {\n                      runtime.nullCheck(targets, targetsExpr);\n                      var promises = [];\n                      runtime.implicitLoop(targets, function (target) {\n                          var promise = new Promise(function (resolve, reject) {\n                              var initialTransition = target.style.transition;\n                              if (over) {\n                                  target.style.transition = \"all \" + over + \"ms ease-in\";\n                              } else if (using) {\n                                  target.style.transition = using;\n                              } else {\n                                  target.style.transition = config.defaultTransition;\n                              }\n                              var internalData = runtime.getInternalData(target);\n                              var computedStyles = getComputedStyle(target);\n\n                              var initialStyles = {};\n                              for (var i = 0; i < computedStyles.length; i++) {\n                                  var name = computedStyles[i];\n                                  var initialValue = computedStyles[name];\n                                  initialStyles[name] = initialValue;\n                              }\n\n                              // store intitial values\n                              if (!internalData.initalStyles) {\n                                  internalData.initalStyles = initialStyles;\n                              }\n\n                              for (var i = 0; i < properties.length; i++) {\n                                  var property = properties[i];\n                                  var fromVal = from[i];\n                                  if (fromVal === \"computed\" || fromVal == null) {\n                                      target.style[property] = initialStyles[property];\n                                  } else {\n                                      target.style[property] = fromVal;\n                                  }\n                              }\n                              //console.log(\"transition started\", transition);\n\n                              var transitionStarted = false;\n                              var resolved = false;\n\n                              target.addEventListener(\n                                  \"transitionend\",\n                                  function () {\n                                      if (!resolved) {\n                                          //console.log(\"transition ended\", transition);\n                                          target.style.transition = initialTransition;\n                                          resolved = true;\n                                          resolve(undefined);\n                                      }\n                                  },\n                                  { once: true }\n                              );\n\n                              target.addEventListener(\n                                  \"transitionstart\",\n                                  function () {\n                                      transitionStarted = true;\n                                  },\n                                  { once: true }\n                              );\n\n                              // it no transition has started in 100ms, continue\n                              setTimeout(function () {\n                                  if (!resolved && !transitionStarted) {\n                                      //console.log(\"transition ended\", transition);\n                                      target.style.transition = initialTransition;\n                                      resolved = true;\n                                      resolve(undefined);\n                                  }\n                              }, 100);\n\n                              setTimeout(function () {\n                                  var autoProps = [];\n                                  for (var i = 0; i < properties.length; i++) {\n                                      var property = properties[i];\n                                      var toVal = to[i];\n                                      if (toVal === \"initial\") {\n                                          var propertyValue = internalData.initalStyles[property];\n                                          target.style[property] = propertyValue;\n                                      } else {\n                                          target.style[property] = toVal;\n                                      }\n                                      //console.log(\"set\", property, \"to\", target.style[property], \"on\", target, \"value passed in : \", toVal);\n                                  }\n                              }, 0);\n                          });\n                          promises.push(promise);\n                      });\n                      return Promise.all(promises).then(function () {\n                          return runtime.findNext(transition, context);\n                      });\n                  },\n              };\n              return transition;\n          }\n      });\n\n      parser.addCommand(\"measure\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"measure\")) return;\n\n          var targetExpr = parsePseudopossessiveTarget(parser, runtime, tokens);\n\n          var propsToMeasure = [];\n          if (!parser.commandBoundary(tokens.currentToken()))\n              do {\n                  propsToMeasure.push(tokens.matchTokenType(\"IDENTIFIER\").value);\n              } while (tokens.matchOpToken(\",\"));\n\n          return {\n              properties: propsToMeasure,\n              args: [targetExpr],\n              op: function (ctx, target) {\n                  runtime.nullCheck(target, targetExpr);\n                  if (0 in target) target = target[0]; // not measuring multiple elts\n                  var rect = target.getBoundingClientRect();\n                  var scroll = {\n                      top: target.scrollTop,\n                      left: target.scrollLeft,\n                      topMax: target.scrollTopMax,\n                      leftMax: target.scrollLeftMax,\n                      height: target.scrollHeight,\n                      width: target.scrollWidth,\n                  };\n\n                  ctx.result = {\n                      x: rect.x,\n                      y: rect.y,\n                      left: rect.left,\n                      top: rect.top,\n                      right: rect.right,\n                      bottom: rect.bottom,\n                      width: rect.width,\n                      height: rect.height,\n                      bounds: rect,\n\n                      scrollLeft: scroll.left,\n                      scrollTop: scroll.top,\n                      scrollLeftMax: scroll.leftMax,\n                      scrollTopMax: scroll.topMax,\n                      scrollWidth: scroll.width,\n                      scrollHeight: scroll.height,\n                      scroll: scroll,\n                  };\n\n                  runtime.forEach(propsToMeasure, function (prop) {\n                      if (prop in ctx.result) ctx.locals[prop] = ctx.result[prop];\n                      else throw \"No such measurement as \" + prop;\n                  });\n\n                  return runtime.findNext(this, ctx);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"closestExpr\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"closest\")) {\n              if (tokens.matchToken(\"parent\")) {\n                  var parentSearch = true;\n              }\n\n              var css = null;\n              if (tokens.currentToken().type === \"ATTRIBUTE_REF\") {\n                  var attributeRef = parser.requireElement(\"attributeRefAccess\", tokens, null);\n                  css = \"[\" + attributeRef.attribute.name + \"]\";\n              }\n\n              if (css == null) {\n                  var expr = parser.requireElement(\"expression\", tokens);\n                  if (expr.css == null) {\n                      parser.raiseParseError(tokens, \"Expected a CSS expression\");\n                  } else {\n                      css = expr.css;\n                  }\n              }\n\n              if (tokens.matchToken(\"to\")) {\n                  var to = parser.parseElement(\"expression\", tokens);\n              } else {\n                  var to = parser.parseElement(\"implicitMeTarget\", tokens);\n              }\n\n              var closestExpr = {\n                  type: \"closestExpr\",\n                  parentSearch: parentSearch,\n                  expr: expr,\n                  css: css,\n                  to: to,\n                  args: [to],\n                  op: function (ctx, to) {\n                      if (to == null) {\n                          return null;\n                      } else {\n                          let result = [];\n                          runtime.implicitLoop(to, function(to){\n                              if (parentSearch) {\n                                  result.push(to.parentElement ? to.parentElement.closest(css) : null);\n                              } else {\n                                  result.push(to.closest(css));\n                              }\n                          })\n                          if (runtime.shouldAutoIterate(to)) {\n                              return result;\n                          } else {\n                              return result[0];\n                          }\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n\n              if (attributeRef) {\n                  attributeRef.root = closestExpr;\n                  attributeRef.args = [closestExpr];\n                  return attributeRef;\n              } else {\n                  return closestExpr;\n              }\n          }\n      });\n\n      parser.addCommand(\"go\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"go\")) {\n              if (tokens.matchToken(\"back\")) {\n                  var back = true;\n              } else {\n                  tokens.matchToken(\"to\");\n                  if (tokens.matchToken(\"url\")) {\n                      var target = parser.requireElement(\"stringLike\", tokens);\n                      var url = true;\n                      if (tokens.matchToken(\"in\")) {\n                          tokens.requireToken(\"new\");\n                          tokens.requireToken(\"window\");\n                          var newWindow = true;\n                      }\n                  } else {\n                      tokens.matchToken(\"the\"); // optional the\n                      var verticalPosition = tokens.matchAnyToken(\"top\", \"middle\", \"bottom\");\n                      var horizontalPosition = tokens.matchAnyToken(\"left\", \"center\", \"right\");\n                      if (verticalPosition || horizontalPosition) {\n                          tokens.requireToken(\"of\");\n                      }\n                      var target = parser.requireElement(\"unaryExpression\", tokens);\n\n                      var plusOrMinus = tokens.matchAnyOpToken(\"+\", \"-\");\n                      if (plusOrMinus) {\n                          tokens.pushFollow(\"px\");\n                          try {\n                              var offset = parser.requireElement(\"expression\", tokens);\n                          } finally {\n                              tokens.popFollow();\n                          }\n                      }\n                      tokens.matchToken(\"px\"); // optional px\n\n                      var smoothness = tokens.matchAnyToken(\"smoothly\", \"instantly\");\n\n                      var scrollOptions:ScrollOptions & { block?:string, inline?:string} = {};\n                      if (verticalPosition) {\n                          if (verticalPosition.value === \"top\") {\n                              scrollOptions.block = \"start\";\n                          } else if (verticalPosition.value === \"bottom\") {\n                              scrollOptions.block = \"end\";\n                          } else if (verticalPosition.value === \"middle\") {\n                              scrollOptions.block = \"center\";\n                          }\n                      }\n\n                      if (horizontalPosition) {\n                          if (horizontalPosition.value === \"left\") {\n                              scrollOptions.inline = \"start\";\n                          } else if (horizontalPosition.value === \"center\") {\n                              scrollOptions.inline = \"center\";\n                          } else if (horizontalPosition.value === \"right\") {\n                              scrollOptions.inline = \"end\";\n                          }\n                      }\n\n                      if (smoothness) {\n                          if (smoothness.value === \"smoothly\") {\n                              scrollOptions.behavior = \"smooth\";\n                          } else if (smoothness.value === \"instantly\") {\n// @ts-ignore *C* is the following correct?\n                              scrollOptions.behavior = \"instant\";\n                          }\n                      }\n                  }\n              }\n\n              var goCmd = {\n                  target: target,\n                  args: [target, offset],\n                  op: function (ctx, to, offset) {\n                      if (back) {\n                          window.history.back();\n                      } else if (url) {\n                          if (to) {\n                              if (newWindow) {\n                                  window.open(to);\n                              } else {\n                                  window.location.href = to;\n                              }\n                          }\n                      } else {\n                          runtime.implicitLoop(to, function (target) {\n\n                              if (target === window) {\n                                  target = document.body;\n                              }\n\n                              if(plusOrMinus) {\n                                  // a top scroll w/ an offset of some sort\n                                  var boundingRect = target.getBoundingClientRect();\n                                  let scrollShim = document.createElement('div');\n\n                                  if (plusOrMinus.value === \"-\") {\n                                      var finalOffset = -offset;\n                                  } else {\n                                      var finalOffset = - -offset;\n                                  }\n\n                                  scrollShim.style.position = 'absolute';\n                                  scrollShim.style.top = (boundingRect.x + finalOffset) + \"px\";\n                                  scrollShim.style.left = (boundingRect.y + finalOffset) + \"px\";\n                                  scrollShim.style.height = (boundingRect.height + (2 * finalOffset)) + \"px\";\n                                  scrollShim.style.width = (boundingRect.width + (2 * finalOffset)) + \"px\";\n                                  scrollShim.style.zIndex = \"\" + Number.MIN_SAFE_INTEGER;\n                                  scrollShim.style.opacity = \"0\";\n\n                                  document.body.appendChild(scrollShim);\n                                  setTimeout(function () {\n                                      document.body.removeChild(scrollShim);\n                                  }, 100);\n\n                                  target = scrollShim;\n                              }\n\n                              target.scrollIntoView(scrollOptions);\n                          });\n                      }\n                      return runtime.findNext(goCmd, ctx);\n                  },\n              };\n              return goCmd;\n          }\n      });\n\n      config.conversions.dynamicResolvers.push(function (str, node) {\n          if (!(str === \"Values\" || str.indexOf(\"Values:\") === 0)) {\n              return;\n          }\n          var conversion = str.split(\":\")[1];\n          /** @type Object<string,string | string[]> */\n          var result = {};\n\n          var implicitLoop = parser.runtime.implicitLoop.bind(parser.runtime);\n\n          implicitLoop(node, function (/** @type HTMLInputElement */ node) {\n              // Try to get a value directly from this node\n              var input = getInputInfo(node);\n\n              if (input !== undefined) {\n                  result[input.name] = input.value;\n                  return;\n              }\n\n              // Otherwise, try to query all child elements of this node that *should* contain values.\n              if (node.querySelectorAll != undefined) {\n                  /** @type {NodeListOf<HTMLInputElement>} */\n                  var children = node.querySelectorAll(\"input,select,textarea\");\n                  children.forEach(appendValue);\n              }\n          });\n\n          if (conversion) {\n              if (conversion === \"JSON\") {\n                  return JSON.stringify(result);\n              } else if (conversion === \"Form\") {\n                  /** @ts-ignore */\n                  // TODO: does this work with multiple inputs of the same name?\n                  return new URLSearchParams(result).toString();\n              } else {\n                  throw \"Unknown conversion: \" + conversion;\n              }\n          } else {\n              return result;\n          }\n\n          /**\n           * @param {HTMLInputElement} node\n           */\n          function appendValue(node) {\n              var info = getInputInfo(node);\n\n              if (info == undefined) {\n                  return;\n              }\n\n              // If there is no value already stored in this space.\n              if (result[info.name] == undefined) {\n                  result[info.name] = info.value;\n                  return;\n              }\n\n              if (Array.isArray(result[info.name]) && Array.isArray(info.value)) {\n                  result[info.name] = [].concat(result[info.name], info.value);\n                  return;\n              }\n          }\n\n          /**\n           * @param {HTMLInputElement} node\n           * @returns {{name:string, value:string | string[]} | undefined}\n           */\n          function getInputInfo(node) {\n              try {\n                  /** @type {{name: string, value: string | string[]}}*/\n                  var result = {\n                      name: node.name,\n                      value: node.value,\n                  };\n\n                  if (result.name == undefined || result.value == undefined) {\n                      return undefined;\n                  }\n\n                  if (node.type == \"radio\" && node.checked == false) {\n                      return undefined;\n                  }\n\n                  if (node.type == \"checkbox\") {\n                      if (node.checked == false) {\n                          result.value = undefined;\n                      } else if (typeof result.value === \"string\") {\n                          result.value = [result.value];\n                      }\n                  }\n\n                  if (node.type == \"select-multiple\") {\n                      /** @type {NodeListOf<HTMLSelectElement>} */\n                      var selected = node.querySelectorAll(\"option[selected]\");\n\n                      result.value = [];\n                      for (var index = 0; index < selected.length; index++) {\n                          result.value.push(selected[index].value);\n                      }\n                  }\n                  return result;\n              } catch (e) {\n                  return undefined;\n              }\n          }\n      });\n\n      config.conversions[\"HTML\"] = function (value) {\n          var toHTML = /** @returns {string}*/ function (/** @type any*/ value) {\n              if (value instanceof Array) {\n                  return value\n                      .map(function (item) {\n                          return toHTML(item);\n                      })\n                      .join(\"\");\n              }\n\n              if (value instanceof HTMLElement) {\n                  return value.outerHTML;\n              }\n\n              if (value instanceof NodeList) {\n                  var result = \"\";\n                  for (var i = 0; i < value.length; i++) {\n                      var node = value[i];\n                      if (node instanceof HTMLElement) {\n                          result += node.outerHTML;\n                      }\n                  }\n                  return result;\n              }\n\n              if (value.toString) {\n                  return value.toString();\n              }\n\n              return \"\";\n          };\n\n          return toHTML(value);\n      };\n\n      config.conversions[\"Fragment\"] = function (val) {\n          var frag = document.createDocumentFragment();\n          parser.runtime.implicitLoop(val, function (val) {\n              if (val instanceof Node) frag.append(val);\n              else {\n                  var temp = document.createElement(\"template\");\n                  temp.innerHTML = val;\n                  frag.append(temp.content);\n              }\n          });\n          return frag;\n      };\n  }\n\n\n  // Public API\n\n  const runtime_ = new Runtime(), lexer_ = runtime_.lexer, parser_ = runtime_.parser\n\n  /**\n   *\n   * @param {string} src\n   * @param {Partial<Context>} [ctx]\n   */\n  function run(src, ctx = undefined) {\n      return runtime_.evaluate(src, ctx)\n  }\n\n  function browserInit() {\n      /** @type {HTMLScriptElement[]} */\n      var scripts = Array.from(globalScope.document.querySelectorAll(\"script[type='text/hyperscript'][src]\"))\n      Promise.all(\n          scripts.map(function (script:any) {\n              return fetch(script.src)\n                  .then(function (res) {\n                      return res.text();\n                  });\n          })\n      )\n      .then(script_values => script_values.forEach(sc => _hyperscript(sc)))\n      .then(() => ready(function () {\n          mergeMetaConfig();\n          runtime_.processNode(document.documentElement);\n          globalScope.document.addEventListener(\"htmx:load\", function (/** @type {CustomEvent} */ evt) {\n              runtime_.processNode(evt.detail.elt);\n          });\n      }));\n\n      function ready(fn) {\n          if (document.readyState !== \"loading\") {\n              setTimeout(fn);\n          } else {\n              document.addEventListener(\"DOMContentLoaded\", fn);\n          }\n      }\n\n      function getMetaConfig() {\n          /** @type {HTMLMetaElement} */\n          var element = document.querySelector('meta[name=\"htmx-config\"]');\n          if (element) {\n              return parseJSON(element['content']);\n          } else {\n              return null;\n          }\n      }\n\n      function mergeMetaConfig() {\n          var metaConfig = getMetaConfig();\n          if (metaConfig) {\n              Object.assign(config, metaConfig);\n          }\n      }\n  }\n\n  /**\n   * @typedef {Object} HyperscriptAPI\n   *\n   * @property {Object} config\n   * @property {string} config.attributes\n   * @property {string} config.defaultTransition\n   * @property {string} config.disableSelector\n   * @property {typeof conversions} config.conversions\n   *\n   * @property {Object} internals\n   * @property {Lexer} internals.lexer\n   * @property {typeof Lexer} internals.Lexer\n   * @property {Parser} internals.parser\n   * @property {typeof Parser} internals.Parser\n   * @property {Runtime} internals.runtime\n   * @property {typeof Runtime} internals.Runtime\n   *\n   * @property {typeof ElementCollection} ElementCollection\n   *\n   * @property {(keyword: string, definition: ParseRule) => void} addFeature\n   * @property {(keyword: string, definition: ParseRule) => void} addCommand\n   * @property {(keyword: string, definition: ParseRule) => void} addLeafExpression\n   * @property {(keyword: string, definition: ParseRule) => void} addIndirectExpression\n   *\n   * @property {(src: string, ctx?: Partial<Context>) => any} evaluate\n   * @property {(src: string) => ASTNode} parse\n   * @property {(node: Element) => void} processNode\n   *\n   * @property {() => void} browserInit\n   *\n   *\n   * @typedef {HyperscriptAPI & ((src: string, ctx?: Partial<Context>) => any)} Hyperscript\n   */\n\n  /**\n   * @type {Hyperscript}\n   */\n  const _hyperscript = Object.assign(\n      run,\n      {\n          config,\n\n          use(plugin) { plugin(_hyperscript) },\n\n          internals: {\n              lexer: lexer_, parser: parser_, runtime: runtime_,\n              Lexer, Tokens, Parser, Runtime,\n          },\n          ElementCollection,\n\n          addFeature:            parser_.addFeature.bind(parser_),\n          addCommand:            parser_.addCommand.bind(parser_),\n          addLeafExpression:     parser_.addLeafExpression.bind(parser_),\n          addIndirectExpression: parser_.addIndirectExpression.bind(parser_),\n\n          evaluate:    runtime_.evaluate.bind(runtime_),\n          parse:       runtime_.parse.bind(runtime_),\n          processNode: runtime_.processNode.bind(runtime_),\n\n          browserInit,\n      }\n  )\n\n  return _hyperscript\n})\n"],"names":["self","factory","_hyperscript","globalScope","conversions","dynamicResolvers","str","value","Number","toFixed","indexOf","num","split","parseInt","String","val","toString","Int","Float","parseFloat","Date","Array","from","JSON","stringify","Object","parse","assign","config","attributes","hideShowStrategies","undefined","defaultHideShowStrategy","defaultTransition","disableSelector","Lexer","isValidCSSClassChar","c","isAlpha","isNumeric","isValidCSSIDChar","isWhitespace","isNewline","positionString","token","line","column","isIdentifierChar","isReservedChar","isValidSingleQuoteStringStart","tokens","length","previousToken","type","op","tokenize","string","template","source","position","lastToken","templateBraceCount","inTemplate","currentChar","nextChar","nextCharAt","consumeComment","consumeCommentMultiline","push","consumeWhitespace","possiblePrecedingSymbol","consumeAttributeReference","consumeShortAttributeReference","consumeStyleReference","consumeIdentifier","consumeNumber","OP_TABLE","consumeOp","makeToken","consumeChar","Error","consumeString","consumeIdReference","consumeClassReference","Tokens","makeOpToken","start","end","classRef","attributeRef","styleRef","idRef","identifier","number","startChar","nextChar_1","charAt","whitespace","prototype","$","consumed","this","_lastConsumed","follows","defineProperty","get","shift","raiseError","error","Parser","raiseParseError","requireOpToken","matchOpToken","currentToken","matchAnyOpToken","i","arguments","opToken","match","matchAnyToken","matchToken","consumeToken","requireTokenType","type1","type2","type3","type4","matchTokenType","requireToken","peekToken","peek","consumeUntil","tokenList","lastWhitespace","consumeUntilWhitespace","hasMore","n","dontIgnoreWhitespace","lastMatch","pushFollow","popFollow","pop","clearFollows","tmp","restoreFollows","f","sourceFor","programSource","substring","startToken","endToken","lineFor","runtime","GRAMMAR","COMMANDS","FEATURES","LEAF_EXPRESSIONS","INDIRECT_EXPRESSIONS","possessivesDisabled","addGrammarElement","parser","featureElement","requireElement","featureDefinition","commandElement_1","commandElement","commandDefinition","parseElement","cmd","next","result","parseAnyOf","root","indirect","unless","args","context","conditional","execute","unifiedExec","parent","leaf","use","plugin","initElt","elementDefinition","message","types","expression","name","definition","addCommand","keyword","commandGrammarType","commandDefinitionWrapper","meta","command","addFeature","featureGrammarType","featureDefinitionWrapper","isFeature","addLeafExpression","addIndirectExpression","createParserContext","lines","contextLine","offset","repeat","parseHyperScript","setParent","elt","children","Set","add","commandStart","featureStart","commandBoundary","parseStringTemplate","returnArr","startingBrace","ensureTerminated","commandList","implicitReturn","returned","resolve","HALT","ctx","Runtime","lexer","_scriptAttrs","hyperscriptFeaturesMap","WeakMap","internalDataMap","hyperscriptUrl","document","currentScript","src","hyperscriptCoreGrammar","hyperscriptWebGrammar","matchesSelector","selector","matchesFunction","matches","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","call","makeEvent","eventName","detail","evt","Event","bubbles","cancelable","createEvent","initCustomEvent","triggerEvent","sender","event","dispatchEvent","isArrayLike","isArray","NodeList","HTMLCollection","isIterable","Symbol","iterator","shouldAutoIterate","shouldAutoIterateSymbol","forEach","func","value_1","__values","value_1_1","done","implicitLoop","value_2","value_2_1","wrapArrays","arr","arg","Promise","all","unwrapAsyncs","values","asyncWrapper","j","valueElement","_this","unifiedEval","e","handlingFinally","console","registerHyperTrace","errorHandler","handlingError","locals","errorSymbol","currentException","then","resolvedNext","catch","reason","finallyHandler","onHalt","reject","async","wrappedAsyncs","argument","element","evaluate","apply","getScriptAttributes","replace","getScript","scriptAttribute","hasAttribute","getAttribute","HTMLScriptElement","innerText","getHyperscriptFeatures","hyperscriptFeatures","set","addFeatures","owner","parentElement","makeContext","feature","hyperscriptTarget","Context","getScriptSelector","map","attribute","join","convertValue","converted","dynamicResolver","converter","hyperscript","evaluateNoPromise","HyperscriptModule","_super","mod","module","__extends","id","EventTarget","body","processNode","initElement","querySelectorAll","target","closest","internalData","getInternalData","initialized","script","hyperScript","setTimeout","stack","typeCheck","typeString","nullOk","slice","getElementScope","scopeName","behavior","getOrInitObject","isReservedWord","includes","isHyperscriptContext","resolveSymbol","me","you","fromMetaContext","fromContext","setSymbol","elementScope","findNext","resolveNext","flatGet","property","getter","root_1","root_1_1","componentValue","resolveProperty","resolveAttribute","resolveStyle","style","resolveComputedStyle","getComputedStyle","getPropertyValue","assignToNamespace","nameSpace","propertyName","newRoot","getHyperTrace","thrown","trace","caller","traceMap","Map","traceEntry","print","logger","maxLen","Math","max","displayName","traceElt","padEnd","escapeSelector","nullCheck","isEmpty","doesExist","value_3","value_3_1","getRootNode","node","Node","rv","Document","ShadowRoot","getEventQueueFor","onFeature","eventQueuesForElt","eventQueues","eventQueueForFeature","queue","executing","iterators","ElementCollection","css","relativeToElement","escape","_css","substr","className","contains","_b","_c","selectMatches","prop","newObj","parseJSON","jString","logError","msg","log","varargConstructor","Cls","bind","concat","_runtime","expr","stringToken","rawValue","innerTokens","returnStr","tokenArr","t","numberToken","elementId","templateValue","getElementById","value_4","css_1","TemplatedQueryElementCollection","templateParts","elements","filter","Element","el","dataset","hsQueryId","removeAttribute","queryTokens","queryValue","_i","outerVal","innerValue","styleProp","startsWith","key","keyExpressions","valueExpressions","keys","returnVal","fields","_namedArgList_","scope","eltPrefix","booleanLiteral","arg1","returnFunc","propertyAccess","_context","rootVal","childOfUrRoot","urRoot","attributeElt","apostrophe","targetElt","results","within","rootElt","conversion","functionCall","argExressions","rootRoot","hyperfunc","argVals","_ctx","andBefore","andAfter","firstIndex","secondIndex","arrayIndex","STRING_POSTFIXES","stringPosfix","postfix","timeFactor","time","factor","typeName","originalEvaluate","logValue","constructor","scanForwardQuery","wrap","compareDocumentPosition","DOCUMENT_POSITION_PRECEDING","scanBackwardsQuery","DOCUMENT_POSITION_FOLLOWING","scanForwardArray","array","first","scanBackwardsArray","reverse","sloppyContains","container","sloppyMatches","toMatch","forwardSearch","thing","withinElt","inSearch","inElt","wrapping","operator","rhs","rhsVal","floor","random","mathOp","initialMathOp","lhs","lhsVal","comparisonToken","hasRightValue","logicalOp","initialLogicalOp","features","features_1","features_1_1","install","parseEventArgs","parseSendCmd","cmdType","details","toExpr","sendCmd","to","every","events","startCount","endCount","unbounded","intersectionSpec","mutationSpec","startCountToken","endCountToken","elsewhere","inExpr","debounceTime","throttleTime","execCount","on","debounced","lastExec","queueLast","queueFirst","queueNone","eventQueueInfo","queued","err","hypertrace","targets","eventSpec","MutationObserver","mutationList","observer","observe","observer_1","IntersectionObserver","entries","entries_1","entries_1_1","entry","isIntersecting","addEventListener","listener","isConnected","removeEventListener","eventValue","initialCtx","inElement","clearTimeout","now","warn","nameVal","funcName","functionFeature","argumentVal","callingCommand","promise","theResolve","theReject","returnValue","setCmd","setFeature_1","immediately","initFeature","handler","path","formalParams","hs","innerArgs","installFeature","behaviorPath","behaviorNamespace","Function","jsSourceStart","jsLastToken","funcNames","expectFunctionDeclaration","jsSourceEnd","exposedFunctionNames","jsSource","jsBody","function","inputs","inp","input","actualResult","slot","tellCmd","index","originalYou","lookahead","resolved","eventInfo","once","events_1","events_1_1","timeValue","separator","parseReturnFunction","returnAValue","returnCmd","keepExecuting","bubbling","haltDefault","exit","stopPropagation","preventDefault","exprs","withExpr","logCmd","throwCmd","parseCallOrGet","callCmd","tagname","classes","re","exec","trim","createElement","cls","classList","lookAhead","pseudoCommand","realRoot","makeSetter","symbolWrite","attributeWrite","styleWrite","arrayWrite","valueToSet","setAttribute","setter","defaultCmd","obj","objectLiteral","trueBranch","falseBranch","ifCmd","exprValue","parseRepeatExpression","startedWithForToken","innerStartToken","identifierToken","whileExpr","isUntil","forever","times","indexIdentifier","loop","last","waitATick","repeatCmd","until","whileValue","iteratorInfo","keepLooping","loopVal","eventFired","nextValFromIterator","repeatInit","parsePickRange","includeStart","includeEnd","toEnd","targetExpr","implicitResultSymbol","innerHTML","RegExpIterator","RegExpIterable","flags","RegExp","parseConversionInfo","range_1","flags_1","flags_2","amountExpr","implicitIncrementOp","targetValue","amount","newValue","implicitDecrementOp","url","conversionInfo","fetchCmd","argExpressions","abortController","AbortController","abortListener","abort","signal","finished","timeout","fetch","resp","resultDetails","response","json","text","finally","onExpr","settleCommand","transitionStarted","r","cssDeclaration","classRefs","when","remove","attrRef","cssText","stringParts","opencurly","tok","part","idx","elementExpr","fromExpr","removeChild","visibility","hideShowStrategy","resolveStrategy","between","classRef2","toggleCmd","toggle","HIDE_SHOW_STRATEGIES","display","originalDisplay","removeProperty","opacity","parseShowHideTarget","currentTokenValue","configDefault","strategies","putInto","valueToPut","HTMLDocument","firstChild","append","parsePseudopossessiveTarget","forExpr","forElt","eltColl","clazz","operationToken","operation","rootExpr","putCmd","before","after","prepend","targetsExpr","properties","styleProp_1","over","using","transition","promises","initialTransition","computedStyles","initialStyles","initialValue","initalStyles","fromVal","toVal","propertyValue","propsToMeasure","rect","getBoundingClientRect","scroll","top","scrollTop","left","scrollLeft","topMax","scrollTopMax","leftMax","scrollLeftMax","height","scrollHeight","width","scrollWidth","x","y","right","bottom","bounds","parentSearch","closestExpr","result_1","back","newWindow","verticalPosition","horizontalPosition","plusOrMinus","smoothness","scrollOptions","block","inline","goCmd","window","history","open","location","href","boundingRect","scrollShim_1","finalOffset","zIndex","MIN_SAFE_INTEGER","appendChild","scrollIntoView","getInputInfo","appendValue","URLSearchParams","info","checked","selected","toHTML","item","HTMLElement","outerHTML","frag","createDocumentFragment","temp","content","runtime_","lexer_","parser_","run","browserInit","scripts","ready","fn","readyState","getMetaConfig","querySelector","mergeMetaConfig","metaConfig","res","script_values","sc","documentElement","internals","exports"],"mappings":"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"}