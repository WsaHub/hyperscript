{"version":3,"file":"_hyperscript.js","sources":["../src/_hyperscript.ts"],"sourcesContent":["/**\n * @typedef {Object} Hyperscript\n */\n\n (function (self, factory) {\n  const _hyperscript = factory(self)\n\n  if (typeof exports === 'object' && typeof exports['nodeName'] !== 'string') {\n      module.exports = _hyperscript\n  } else {\n      self['_hyperscript'] = _hyperscript\n      if ('document' in self) self['_hyperscript'].browserInit()\n  }\n})(typeof self !== 'undefined' ? self : undefined, (globalScope) => {\n\n  'use strict';\n\n  /**\n   * @type {Object}\n   * @property {DynamicConverter[]} dynamicResolvers\n   * \n   * @callback DynamicConverter\n   * @param {String} str\n   * @param {*} value\n   * @returns {*}\n   */\n  const conversions = {\n      dynamicResolvers: [\n          function(str, value):any {\n              if (str === \"Fixed\") {\n                  return Number(value).toFixed();\n              } else if (str.indexOf(\"Fixed:\") === 0) {\n                  let num = str.split(\":\")[1];\n                  return Number(value).toFixed(parseInt(num));\n              }\n          }\n      ],\n      String: function (val) {\n          if (val.toString) {\n              return val.toString();\n          } else {\n              return \"\" + val;\n          }\n      },\n      Int: function (val) {\n          return parseInt(val);\n      },\n      Float: function (val) {\n          return parseFloat(val);\n      },\n      Number: function (val) {\n          return Number(val);\n      },\n      Date: function (val) {\n          return new Date(val);\n      },\n      Array: function (val) {\n          return Array.from(val);\n      },\n      JSON: function (val) {\n          return JSON.stringify(val);\n      },\n      Object: function (val) {\n          if (val instanceof String) {\n              val = val.toString();\n          }\n          if (typeof val === \"string\") {\n              return JSON.parse(val);\n          } else {\n              return Object.assign({}, val);\n          }\n      },\n  }\n\n  const config = {\n      attributes: \"_, script, data-script\",\n      hideShowStrategies: undefined,\n      defaultHideShowStrategy: undefined,\n      defaultTransition: \"all 500ms ease-in\",\n      disableSelector: \"[disable-scripting], [data-disable-scripting]\",\n      conversions,\n  }\n\n  type token = {\n    type:any, value:string,\n    start:number, end:number, column:number, line:number,\n    op?:boolean, template?:boolean,\n  }\n\n  class Lexer {\n      static OP_TABLE = {\n          \"+\": \"PLUS\",\n          \"-\": \"MINUS\",\n          \"*\": \"MULTIPLY\",\n          \"/\": \"DIVIDE\",\n          \".\": \"PERIOD\",\n          \"..\": \"ELLIPSIS\",\n          \"\\\\\": \"BACKSLASH\",\n          \":\": \"COLON\",\n          \"%\": \"PERCENT\",\n          \"|\": \"PIPE\",\n          \"!\": \"EXCLAMATION\",\n          \"?\": \"QUESTION\",\n          \"#\": \"POUND\",\n          \"&\": \"AMPERSAND\",\n          $: \"DOLLAR\",\n          \";\": \"SEMI\",\n          \",\": \"COMMA\",\n          \"(\": \"L_PAREN\",\n          \")\": \"R_PAREN\",\n          \"<\": \"L_ANG\",\n          \">\": \"R_ANG\",\n          \"<=\": \"LTE_ANG\",\n          \">=\": \"GTE_ANG\",\n          \"==\": \"EQ\",\n          \"===\": \"EQQ\",\n          \"!=\": \"NEQ\",\n          \"!==\": \"NEQQ\",\n          \"{\": \"L_BRACE\",\n          \"}\": \"R_BRACE\",\n          \"[\": \"L_BRACKET\",\n          \"]\": \"R_BRACKET\",\n          \"=\": \"EQUALS\",\n      };\n  \n      /**\n       * isValidCSSClassChar returns `true` if the provided character is valid in a CSS class.\n       * @param {string} c\n       * @returns boolean\n       */\n      static isValidCSSClassChar(c) {\n          return Lexer.isAlpha(c) || Lexer.isNumeric(c) || c === \"-\" || c === \"_\" || c === \":\";\n      }\n  \n      /**\n       * isValidCSSIDChar returns `true` if the provided character is valid in a CSS ID\n       * @param {string} c\n       * @returns boolean\n       */\n      static isValidCSSIDChar(c) {\n          return Lexer.isAlpha(c) || Lexer.isNumeric(c) || c === \"-\" || c === \"_\" || c === \":\";\n      }\n  \n      /**\n       * isWhitespace returns `true` if the provided character is whitespace.\n       * @param {string} c\n       * @returns boolean\n       */\n      static isWhitespace(c) {\n          return c === \" \" || c === \"\\t\" || Lexer.isNewline(c);\n      }\n  \n      /**\n       * positionString returns a string representation of a Token's line and column details.\n       * @param {Token} token\n       * @returns string\n       */\n      static positionString(token) {\n          return \"[Line: \" + token.line + \", Column: \" + token.column + \"]\";\n      }\n  \n      /**\n       * isNewline returns `true` if the provided character is a carrage return or newline\n       * @param {string} c\n       * @returns boolean\n       */\n      static isNewline(c) {\n          return c === \"\\r\" || c === \"\\n\";\n      }\n  \n      /**\n       * isNumeric returns `true` if the provided character is a number (0-9)\n       * @param {string} c\n       * @returns boolean\n       */\n      static isNumeric(c) {\n          return c >= \"0\" && c <= \"9\";\n      }\n  \n      /**\n       * isAlpha returns `true` if the provided character is a letter in the alphabet\n       * @param {string} c\n       * @returns boolean\n       */\n      static isAlpha(c) {\n          return (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\");\n      }\n  \n      /**\n       * @param {string} c\n       * @param {boolean} [dollarIsOp]\n       * @returns boolean\n       */\n      static isIdentifierChar(c) {\n          return c === \"_\" || c === \"$\";\n      }\n  \n      /**\n       * @param {string} c\n       * @returns boolean\n       */\n      static isReservedChar(c) {\n          return c === \"`\" || c === \"^\";\n      }\n  \n      /**\n       * @param {Token[]} tokens\n       * @returns {boolean}\n       */\n      static isValidSingleQuoteStringStart(tokens) {\n          if (tokens.length > 0) {\n              var previousToken = tokens[tokens.length - 1];\n              if (\n                  previousToken.type === \"IDENTIFIER\" ||\n                  previousToken.type === \"CLASS_REF\" ||\n                  previousToken.type === \"ID_REF\"\n              ) {\n                  return false;\n              }\n              if (previousToken.op && (previousToken.value === \">\" || previousToken.value === \")\")) {\n                  return false;\n              }\n          }\n          return true;\n      }\n  \n      /**\n       * @param {string} string\n       * @param {boolean} [template]\n       * @returns {Tokens}\n       */\n      static tokenize(string, template = undefined) {\n          var tokens = /** @type {Token[]}*/ [];\n          var source = string;\n          var position = 0;\n          var column = 0;\n          var line = 1;\n          var lastToken = \"<START>\";\n          var templateBraceCount = 0;\n  \n          function inTemplate() {\n              return template && templateBraceCount === 0;\n          }\n  \n          while (position < source.length) {\n              if ((currentChar() === \"-\" && nextChar() === \"-\" && (Lexer.isWhitespace(nextCharAt(2)) || nextCharAt(2) === \"\" || nextCharAt(2) === \"-\"))\n                  || (currentChar() === \"/\" && nextChar() === \"/\")) {\n                  consumeComment();\n              } else if (currentChar() === \"/\" && nextChar() === \"*\") {\n                  consumeCommentMultiline();\n              } else {\n                  if (Lexer.isWhitespace(currentChar())) {\n                      tokens.push(consumeWhitespace());\n                  } else if (\n                      !possiblePrecedingSymbol() &&\n                      currentChar() === \".\" &&\n                      (Lexer.isAlpha(nextChar()) || nextChar() === \"{\")\n                  ) {\n                      tokens.push(consumeClassReference());\n                  } else if (\n                      !possiblePrecedingSymbol() &&\n                      currentChar() === \"#\" &&\n                      (Lexer.isAlpha(nextChar()) || nextChar() === \"{\")\n                  ) {\n                      tokens.push(consumeIdReference());\n                  } else if (currentChar() === \"[\" && nextChar() === \"@\") {\n                      tokens.push(consumeAttributeReference());\n                  } else if (currentChar() === \"@\") {\n                      tokens.push(consumeShortAttributeReference());\n                  } else if (currentChar() === \"*\" && Lexer.isAlpha(nextChar())) {\n                      tokens.push(consumeStyleReference());\n                  } else if (Lexer.isAlpha(currentChar()) || (!inTemplate() && Lexer.isIdentifierChar(currentChar()))) {\n                      tokens.push(consumeIdentifier());\n                  } else if (Lexer.isNumeric(currentChar())) {\n                      tokens.push(consumeNumber());\n                  } else if (!inTemplate() && (currentChar() === '\"' || currentChar() === \"`\")) {\n                      tokens.push(consumeString());\n                  } else if (!inTemplate() && currentChar() === \"'\") {\n                      if (Lexer.isValidSingleQuoteStringStart(tokens)) {\n                          tokens.push(consumeString());\n                      } else {\n                          tokens.push(consumeOp());\n                      }\n                  } else if (Lexer.OP_TABLE[currentChar()]) {\n                      if (lastToken === \"$\" && currentChar() === \"{\") {\n                          templateBraceCount++;\n                      }\n                      if (currentChar() === \"}\") {\n                          templateBraceCount--;\n                      }\n                      tokens.push(consumeOp());\n                  } else if (inTemplate() || Lexer.isReservedChar(currentChar())) {\n                      tokens.push(makeToken(\"RESERVED\", consumeChar()));\n                  } else {\n                      if (position < source.length) {\n                          throw Error(\"Unknown token: \" + currentChar() + \" \");\n                      }\n                  }\n              }\n          }\n\n          return new Tokens(tokens, [], source);\n\n          /**\n           * @param {string} [type]\n           * @param {string} [value]\n           * @returns {Token}\n           */\n          function makeOpToken(type = undefined, value = undefined):token {\n              var token = makeToken(type, value);\n              token.op = true;\n              return token;\n          }\n\n          /**\n           * @param {string} [type]\n           * @param {string} [value]\n           * @returns {Token}\n           */\n          function makeToken(type, value = undefined):token {\n              return {\n                  type: type,\n                  value: value || \"\",\n                  start: position,\n                  end: position + 1,\n                  column: column,\n                  line: line,\n              };\n          }\n\n          function consumeComment() {\n              while (currentChar() && !Lexer.isNewline(currentChar())) {\n                  consumeChar();\n              }\n              consumeChar(); // Consume newline\n          }\n\n          function consumeCommentMultiline() {\n              while (currentChar() && !(currentChar() === '*' && nextChar() === '/')) {\n                  consumeChar();\n              }\n              consumeChar(); // Consume \"*/\"\n              consumeChar();\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeClassReference() {\n              var classRef = makeToken(\"CLASS_REF\");\n              var value = consumeChar();\n              if (currentChar() === \"{\") {\n                  classRef.template = true;\n                  value += consumeChar();\n                  while (currentChar() && currentChar() !== \"}\") {\n                      value += consumeChar();\n                  }\n                  if (currentChar() !== \"}\") {\n                      throw Error(\"Unterminated class reference\");\n                  } else {\n                      value += consumeChar(); // consume final curly\n                  }\n              } else {\n                  while (Lexer.isValidCSSClassChar(currentChar())) {\n                      value += consumeChar();\n                  }\n              }\n              classRef.value = value;\n              classRef.end = position;\n              return classRef;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeAttributeReference() {\n              var attributeRef = makeToken(\"ATTRIBUTE_REF\");\n              var value = consumeChar();\n              while (position < source.length && currentChar() !== \"]\") {\n                  value += consumeChar();\n              }\n              if (currentChar() === \"]\") {\n                  value += consumeChar();\n              }\n              attributeRef.value = value;\n              attributeRef.end = position;\n              return attributeRef;\n          }\n\n          function consumeShortAttributeReference() {\n              var attributeRef = makeToken(\"ATTRIBUTE_REF\");\n              var value = consumeChar();\n              while (Lexer.isValidCSSIDChar(currentChar())) {\n                  value += consumeChar();\n              }\n              attributeRef.value = value;\n              attributeRef.end = position;\n              return attributeRef;\n          }\n\n          function consumeStyleReference() {\n              var styleRef = makeToken(\"STYLE_REF\");\n              var value = consumeChar();\n              while (Lexer.isAlpha(currentChar()) || currentChar() === \"-\") {\n                  value += consumeChar();\n              }\n              styleRef.value = value;\n              styleRef.end = position;\n              return styleRef;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeIdReference() {\n              var idRef = makeToken(\"ID_REF\");\n              var value = consumeChar();\n              if (currentChar() === \"{\") {\n                  idRef.template = true;\n                  value += consumeChar();\n                  while (currentChar() && currentChar() !== \"}\") {\n                      value += consumeChar();\n                  }\n                  if (currentChar() !== \"}\") {\n                      throw Error(\"Unterminated id reference\");\n                  } else {\n                      consumeChar(); // consume final quote\n                  }\n              } else {\n                  while (Lexer.isValidCSSIDChar(currentChar())) {\n                      value += consumeChar();\n                  }\n              }\n              idRef.value = value;\n              idRef.end = position;\n              return idRef;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeIdentifier() {\n              var identifier = makeToken(\"IDENTIFIER\");\n              var value = consumeChar();\n              while (Lexer.isAlpha(currentChar()) ||\n                     Lexer.isNumeric(currentChar()) ||\n                     Lexer.isIdentifierChar(currentChar())) {\n                  value += consumeChar();\n              }\n              if (currentChar() === \"!\" && value === \"beep\") {\n                  value += consumeChar();\n              }\n              identifier.value = value;\n              identifier.end = position;\n              return identifier;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeNumber() {\n              var number = makeToken(\"NUMBER\");\n              var value = consumeChar();\n              while (Lexer.isNumeric(currentChar())) {\n                  value += consumeChar();\n              }\n              if (currentChar() === \".\" && Lexer.isNumeric(nextChar())) {\n                  value += consumeChar();\n              }\n              while (Lexer.isNumeric(currentChar())) {\n                  value += consumeChar();\n              }\n              number.value = value;\n              number.end = position;\n              return number;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeOp() {\n              var op = makeOpToken();\n              var value = consumeChar(); // consume leading char\n              while (currentChar() && Lexer.OP_TABLE[value + currentChar()]) {\n                  value += consumeChar();\n              }\n              op.type = Lexer.OP_TABLE[value];\n              op.value = value;\n              op.end = position;\n              return op;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeString() {\n              var string = makeToken(\"STRING\");\n              var startChar = consumeChar(); // consume leading quote\n              var value = \"\";\n              while (currentChar() && currentChar() !== startChar) {\n                  if (currentChar() === \"\\\\\") {\n                      consumeChar(); // consume escape char and get the next one\n                      let nextChar = consumeChar();\n                      if (nextChar === \"b\") {\n                          value += \"\\b\";\n                      } else if (nextChar === \"f\") {\n                          value += \"\\f\";\n                      } else if (nextChar === \"n\") {\n                          value += \"\\n\";\n                      } else if (nextChar === \"r\") {\n                          value += \"\\r\";\n                      } else if (nextChar === \"t\") {\n                          value += \"\\t\";\n                      } else if (nextChar === \"v\") {\n                          value += \"\\v\";\n                      } else {\n                          value += nextChar;\n                      }\n                  } else {\n                      value += consumeChar();\n                  }\n              }\n              if (currentChar() !== startChar) {\n                  throw Error(\"Unterminated string at \" + Lexer.positionString(string));\n              } else {\n                  consumeChar(); // consume final quote\n              }\n              string.value = value;\n              string.end = position;\n              string.template = startChar === \"`\";\n              return string;\n          }\n\n          /**\n           * @returns string\n           */\n          function currentChar() {\n              return source.charAt(position);\n          }\n\n          /**\n           * @returns string\n           */\n          function nextChar() {\n              return source.charAt(position + 1);\n          }\n\n          function nextCharAt(number = 1) {\n              return source.charAt(position + number);\n          }\n\n          /**\n           * @returns string\n           */\n          function consumeChar() {\n              lastToken = currentChar();\n              position++;\n              column++;\n              return lastToken;\n          }\n\n          /**\n           * @returns boolean\n           */\n          function possiblePrecedingSymbol() {\n              return (\n                  Lexer.isAlpha(lastToken) ||\n                  Lexer.isNumeric(lastToken) ||\n                  lastToken === \")\" ||\n                  lastToken === \"\\\"\" ||\n                  lastToken === \"'\" ||\n                  lastToken === \"`\" ||\n                  lastToken === \"}\" ||\n                  lastToken === \"]\"\n              );\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeWhitespace() {\n              var whitespace = makeToken(\"WHITESPACE\");\n              var value = \"\";\n              while (currentChar() && Lexer.isWhitespace(currentChar())) {\n                  if (Lexer.isNewline(currentChar())) {\n                      column = 0;\n                      line++;\n                  }\n                  value += consumeChar();\n              }\n              whitespace.value = value;\n              whitespace.end = position;\n              return whitespace;\n          }\n      }\n\n      /**\n       * @param {string} string\n       * @param {boolean} [template]\n       * @returns {Tokens}\n       */\n      tokenize(string, template = undefined) {\n          return Lexer.tokenize(string, template)\n      }\n  }\n\n  /**\n   * @typedef {Object} Token\n   * @property {string} [type]\n   * @property {string} value\n   * @property {number} [start]\n   * @property {number} [end]\n   * @property {number} [column]\n   * @property {number} [line]\n   * @property {boolean} [op] `true` if this token represents an operator\n   * @property {boolean} [template] `true` if this token is a template, for class refs, id refs, strings\n   */\n\n  class Tokens {\n    public tokens:any\n    public consumed:any[]\n    public source:any\n\n      constructor(tokens, consumed, source) {\n          this.tokens = tokens\n          this.consumed = consumed\n          this.source = source\n\n          this.consumeWhitespace(); // consume initial whitespace\n      }\n\n      get list() {\n          return this.tokens\n      }\n\n      /** @type Token | null */\n      _lastConsumed = null;\n\n      consumeWhitespace() {\n          while (this.token(0, true).type === \"WHITESPACE\") {\n              this.consumed.push(this.tokens.shift());\n          }\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @param {*} error\n       * @returns {never}\n       */\n      raiseError(tokens, error) {\n          Parser.raiseParseError(tokens, error);\n      }\n\n      /**\n       * @param {string} value\n       * @returns {Token}\n       */\n      requireOpToken(value) {\n          var token = this.matchOpToken(value);\n          if (token) {\n              return token;\n          } else {\n              this.raiseError(this, \"Expected '\" + value + \"' but found '\" + this.currentToken().value + \"'\");\n          }\n      }\n\n      /**\n       * @param {string} op1\n       * @param {string} [op2]\n       * @param {string} [op3]\n       * @returns {Token | void}\n       */\n      matchAnyOpToken(op1, op2, op3) {\n          for (var i = 0; i < arguments.length; i++) {\n              var opToken = arguments[i];\n              var match = this.matchOpToken(opToken);\n              if (match) {\n                  return match;\n              }\n          }\n      }\n\n      /**\n       * @param {string} op1\n       * @param {string} [op2]\n       * @param {string} [op3]\n       * @returns {Token | void}\n       */\n      matchAnyToken(op1, op2, op3) {\n          for (var i = 0; i < arguments.length; i++) {\n              var opToken = arguments[i];\n              var match = this.matchToken(opToken);\n              if (match) {\n                  return match;\n              }\n          }\n      }\n\n      /**\n       * @param {string} value\n       * @returns {Token | void}\n       */\n      matchOpToken(value) {\n          if (this.currentToken() && this.currentToken().op && this.currentToken().value === value) {\n              return this.consumeToken();\n          }\n      }\n\n      /**\n       * @param {string} type1\n       * @param {string} [type2]\n       * @param {string} [type3]\n       * @param {string} [type4]\n       * @returns {Token}\n       */\n      requireTokenType(type1, type2, type3, type4) {\n          var token = this.matchTokenType(type1, type2, type3, type4);\n          if (token) {\n              return token;\n          } else {\n              this.raiseError(this, \"Expected one of \" + JSON.stringify([type1, type2, type3]));\n          }\n      }\n\n      /**\n       * @param {string} type1\n       * @param {string} [type2]\n       * @param {string} [type3]\n       * @param {string} [type4]\n       * @returns {Token | void}\n       */\n      matchTokenType(type1, type2, type3, type4) {\n          if (\n              this.currentToken() &&\n              this.currentToken().type &&\n              [type1, type2, type3, type4].indexOf(this.currentToken().type) >= 0\n          ) {\n              return this.consumeToken();\n          }\n      }\n\n      /**\n       * @param {string} value\n       * @param {string} [type]\n       * @returns {Token}\n       */\n      requireToken(value, type) {\n          var token = this.matchToken(value, type);\n          if (token) {\n              return token;\n          } else {\n              this.raiseError(this, \"Expected '\" + value + \"' but found '\" + this.currentToken().value + \"'\");\n          }\n      }\n\n      peekToken(value, peek, type) {\n          return this.tokens[peek] && this.tokens[peek].value === value && this.tokens[peek].type === type\n      }\n\n      /**\n       * @param {string} value\n       * @param {string} [type]\n       * @returns {Token | void}\n       */\n      matchToken(value, type = 'IDENTIFIER') {\n          if (this.follows.indexOf(value) !== -1) {\n              return; // disallowed token here\n          }\n          type = type || \"IDENTIFIER\";\n          if (this.currentToken() && this.currentToken().value === value && this.currentToken().type === type) {\n              return this.consumeToken();\n          }\n      }\n\n      /**\n       * @returns {Token}\n       */\n      consumeToken() {\n          var match = this.tokens.shift();\n          this.consumed.push(match);\n          this._lastConsumed = match;\n          this.consumeWhitespace(); // consume any whitespace\n          return match;\n      }\n\n      /**\n       * @param {string | null} value\n       * @param {string | null} [type]\n       * @returns {Token[]}\n       */\n      consumeUntil(value, type) {\n          /** @type Token[] */\n          var tokenList = [];\n          var currentToken = this.token(0, true);\n\n          while (\n              (type == null || currentToken.type !== type) &&\n              (value == null || currentToken.value !== value) &&\n              currentToken.type !== \"EOF\"\n          ) {\n              var match = this.tokens.shift();\n              this.consumed.push(match);\n              tokenList.push(currentToken);\n              currentToken = this.token(0, true);\n          }\n          this.consumeWhitespace(); // consume any whitespace\n          return tokenList;\n      }\n\n      /**\n       * @returns {string}\n       */\n      lastWhitespace() {\n          if (this.consumed[this.consumed.length - 1] && this.consumed[this.consumed.length - 1].type === \"WHITESPACE\") {\n              return this.consumed[this.consumed.length - 1].value;\n          } else {\n              return \"\";\n          }\n      }\n\n      consumeUntilWhitespace() {\n          return this.consumeUntil(null, \"WHITESPACE\");\n      }\n\n      /**\n       * @returns {boolean}\n       */\n      hasMore() {\n          return this.tokens.length > 0;\n      }\n\n      /**\n       * @param {number} n\n       * @param {boolean} [dontIgnoreWhitespace]\n       * @returns {Token}\n       */\n      token(n, dontIgnoreWhitespace = false) {\n          var /**@type {Token}*/ token;\n          var i = 0;\n          do {\n              if (!dontIgnoreWhitespace) {\n                  while (this.tokens[i] && this.tokens[i].type === \"WHITESPACE\") {\n                      i++;\n                  }\n              }\n              token = this.tokens[i];\n              n--;\n              i++;\n          } while (n > -1);\n          if (token) {\n              return token;\n          } else {\n              return {\n                  type: \"EOF\",\n                  value: \"<<<EOF>>>\",\n              };\n          }\n      }\n\n      /**\n       * @returns {Token}\n       */\n      currentToken() {\n          return this.token(0);\n      }\n\n      /**\n       * @returns {Token | null}\n       */\n      lastMatch() {\n          return this._lastConsumed;\n      }\n\n      /**\n       * @returns {string}\n       */\n      static sourceFor = function () {\n          return this.programSource.substring(this.startToken.start, this.endToken.end);\n      }\n\n      /**\n       * @returns {string}\n       */\n      static lineFor = function () {\n          return this.programSource.split(\"\\n\")[this.startToken.line - 1];\n      }\n\n      follows = [];\n\n      pushFollow(str) {\n          this.follows.push(str);\n      }\n\n      popFollow() {\n          this.follows.pop();\n      }\n\n      clearFollows() {\n          var tmp = this.follows;\n          this.follows = [];\n          return tmp;\n      }\n\n      restoreFollows(f) {\n          this.follows = f;\n      }\n  }\n\n  /**\n   * @callback ParseRule\n   * @param {Parser} parser\n   * @param {Runtime} runtime\n   * @param {Tokens} tokens\n   * @param {*} [root]\n   * @returns {ASTNode | undefined}\n   *\n   * @typedef {Object} ASTNode\n   * @member {boolean} isFeature\n   * @member {string} type\n   * @member {any[]} args\n   * @member {(this: ASTNode, ctx:Context, root:any, ...args:any) => any} op\n   * @member {(this: ASTNode, context?:Context) => any} evaluate\n   * @member {ASTNode} parent\n   * @member {Set<ASTNode>} children\n   * @member {ASTNode} root\n   * @member {String} keyword\n   * @member {Token} endToken\n   * @member {ASTNode} next\n   * @member {(context:Context) => ASTNode} resolveNext\n   * @member {EventSource} eventSource\n   * @member {(this: ASTNode) => void} install\n   * @member {(this: ASTNode, context:Context) => void} execute\n   * @member {(this: ASTNode, target: object, source: object, args?: Object) => void} apply\n   *\n   *\n   */\n\n  class Parser {\n    public parser:Parser\n    public runtime:any\n    public possessivesDisabled\n\n      /**\n       *\n       * @param {Runtime} runtime\n       */\n      constructor(runtime) {\n          this.runtime = runtime\n\n          this.possessivesDisabled = false\n\n          /* ============================================================================================ */\n          /* Core hyperscript Grammar Elements                                                            */\n          /* ============================================================================================ */\n          this.addGrammarElement(\"feature\", function (parser, runtime, tokens) {\n              if (tokens.matchOpToken(\"(\")) {\n                  var featureElement = parser.requireElement(\"feature\", tokens);\n                  tokens.requireOpToken(\")\");\n                  return featureElement;\n              }\n\n              var featureDefinition = parser.FEATURES[tokens.currentToken().value || \"\"];\n              if (featureDefinition) {\n                  return featureDefinition(parser, runtime, tokens);\n              }\n          });\n\n          this.addGrammarElement(\"command\", function (parser, runtime, tokens) {\n              if (tokens.matchOpToken(\"(\")) {\n                  const commandElement = parser.requireElement(\"command\", tokens);\n                  tokens.requireOpToken(\")\");\n                  return commandElement;\n              }\n\n              var commandDefinition = parser.COMMANDS[tokens.currentToken().value || \"\"];\n              let commandElement;\n              if (commandDefinition) {\n                  commandElement = commandDefinition(parser, runtime, tokens);\n              } else if (tokens.currentToken().type === \"IDENTIFIER\") {\n                  commandElement = parser.parseElement(\"pseudoCommand\", tokens);\n              }\n              if (commandElement) {\n                  return parser.parseElement(\"indirectStatement\", tokens, commandElement);\n              }\n\n              return commandElement;\n          });\n\n          this.addGrammarElement(\"commandList\", function (parser, runtime, tokens) {\n              var cmd = parser.parseElement(\"command\", tokens);\n              if (cmd) {\n                  tokens.matchToken(\"then\");\n                  const next = parser.parseElement(\"commandList\", tokens);\n                  if (next) cmd.next = next;\n                  return cmd;\n              }\n          });\n\n          this.addGrammarElement(\"leaf\", function (parser, runtime, tokens) {\n              var result = parser.parseAnyOf(parser.LEAF_EXPRESSIONS, tokens);\n              // symbol is last so it doesn't consume any constants\n              if (result == null) {\n                  return parser.parseElement(\"symbol\", tokens);\n              }\n\n              return result;\n          });\n\n          this.addGrammarElement(\"indirectExpression\", function (parser, runtime, tokens, root) {\n              for (var i = 0; i < parser.INDIRECT_EXPRESSIONS.length; i++) {\n                  var indirect = parser.INDIRECT_EXPRESSIONS[i];\n                  root.endToken = tokens.lastMatch();\n                  var result = parser.parseElement(indirect, tokens, root);\n                  if (result) {\n                      return result;\n                  }\n              }\n              return root;\n          });\n\n          this.addGrammarElement(\"indirectStatement\", function (parser, runtime, tokens, root) {\n              if (tokens.matchToken(\"unless\")) {\n                  root.endToken = tokens.lastMatch();\n                  var conditional = parser.requireElement(\"expression\", tokens);\n                  var unless = {\n                      type: \"unlessStatementModifier\",\n                      args: [conditional],\n                      op: function (context, conditional) {\n                          if (conditional) {\n                              return this.next;\n                          } else {\n                              return root;\n                          }\n                      },\n                      execute: function (context) {\n                          return runtime.unifiedExec(this, context);\n                      },\n                  };\n                  root.parent = unless;\n                  return unless;\n              }\n              return root;\n          });\n\n          this.addGrammarElement(\"primaryExpression\", function (parser, runtime, tokens) {\n              var leaf = parser.parseElement(\"leaf\", tokens);\n              if (leaf) {\n                  return parser.parseElement(\"indirectExpression\", tokens, leaf);\n              }\n              parser.raiseParseError(tokens, \"Unexpected value: \" + tokens.currentToken().value);\n          });\n      }\n\n      use(plugin) {\n          plugin(this)\n          return this\n      }\n\n      /** @type {Object<string,ParseRule>} */\n      GRAMMAR = {};\n\n      /** @type {Object<string,ParseRule>} */\n      COMMANDS = {};\n\n      /** @type {Object<string,ParseRule>} */\n      FEATURES = {};\n\n      /** @type {string[]} */\n      LEAF_EXPRESSIONS = [];\n      /** @type {string[]} */\n      INDIRECT_EXPRESSIONS = [];\n\n      /**\n       * @param {*} parseElement\n       * @param {*} start\n       * @param {Tokens} tokens\n       */\n      initElt(parseElement, start, tokens) {\n          parseElement.startToken = start;\n          parseElement.sourceFor = Tokens.sourceFor;\n          parseElement.lineFor = Tokens.lineFor;\n          parseElement.programSource = tokens.source;\n      }\n\n      /**\n       * @param {string} type\n       * @param {Tokens} tokens\n       * @param {ASTNode?} root\n       * @returns {ASTNode}\n       */\n      parseElement(type, tokens, root = undefined) {\n          var elementDefinition = this.GRAMMAR[type];\n          if (elementDefinition) {\n              var start = tokens.currentToken();\n              var parseElement = elementDefinition(this, this.runtime, tokens, root);\n              if (parseElement) {\n                  this.initElt(parseElement, start, tokens);\n                  parseElement.endToken = parseElement.endToken || tokens.lastMatch();\n                  var root = parseElement.root;\n                  while (root != null) {\n                      this.initElt(root, start, tokens);\n                      root = root.root;\n                  }\n              }\n              return parseElement;\n          }\n      }\n\n      /**\n       * @param {string} type\n       * @param {Tokens} tokens\n       * @param {string} [message]\n       * @param {*} [root]\n       * @returns {ASTNode}\n       */\n      requireElement(type, tokens, message = undefined, root = undefined) {\n          var result = this.parseElement(type, tokens, root);\n          if (!result) Parser.raiseParseError(tokens, message || \"Expected \" + type);\n          // @ts-ignore\n          return result;\n      }\n\n      /**\n       * @param {string[]} types\n       * @param {Tokens} tokens\n       * @returns {ASTNode}\n       */\n      parseAnyOf(types, tokens) {\n          for (var i = 0; i < types.length; i++) {\n              var type = types[i];\n              var expression = this.parseElement(type, tokens);\n              if (expression) {\n                  return expression;\n              }\n          }\n      }\n\n      /**\n       * @param {string} name\n       * @param {ParseRule} definition\n       */\n      addGrammarElement(name, definition) {\n          this.GRAMMAR[name] = definition;\n      }\n\n      /**\n       * @param {string} keyword\n       * @param {ParseRule} definition\n       */\n      addCommand(keyword, definition) {\n          var commandGrammarType = keyword + \"Command\";\n          var commandDefinitionWrapper = function (parser, runtime, tokens) {\n              const commandElement = definition(parser, runtime, tokens);\n              if (commandElement) {\n                  commandElement.type = commandGrammarType;\n                  commandElement.execute = function (context) {\n                      context.meta.command = commandElement;\n                      return runtime.unifiedExec(this, context);\n                  };\n                  return commandElement;\n              }\n          };\n          this.GRAMMAR[commandGrammarType] = commandDefinitionWrapper;\n          this.COMMANDS[keyword] = commandDefinitionWrapper;\n      }\n\n      /**\n       * @param {string} keyword\n       * @param {ParseRule} definition\n       */\n      addFeature(keyword, definition) {\n          var featureGrammarType = keyword + \"Feature\";\n\n          /** @type {ParseRule} */\n          var featureDefinitionWrapper = function (parser, runtime, tokens) {\n              var featureElement = definition(parser, runtime, tokens);\n              if (featureElement) {\n                  featureElement.isFeature = true;\n                  featureElement.keyword = keyword;\n                  featureElement.type = featureGrammarType;\n                  return featureElement;\n              }\n          };\n          this.GRAMMAR[featureGrammarType] = featureDefinitionWrapper;\n          this.FEATURES[keyword] = featureDefinitionWrapper;\n      }\n\n      /**\n       * @param {string} name\n       * @param {ParseRule} definition\n       */\n      addLeafExpression(name, definition) {\n          this.LEAF_EXPRESSIONS.push(name);\n          this.addGrammarElement(name, definition);\n      }\n\n      /**\n       * @param {string} name\n       * @param {ParseRule} definition\n       */\n      addIndirectExpression(name, definition) {\n          this.INDIRECT_EXPRESSIONS.push(name);\n          this.addGrammarElement(name, definition);\n      }\n\n      /**\n       *\n       * @param {Tokens} tokens\n       * @returns string\n       */\n      static createParserContext(tokens) {\n          var currentToken = tokens.currentToken();\n          var source = tokens.source;\n          var lines = source.split(\"\\n\");\n          var line = currentToken && currentToken.line ? currentToken.line - 1 : lines.length - 1;\n          var contextLine = lines[line];\n          var offset = /** @type {number} */ (\n              currentToken && currentToken.line ? currentToken.column : contextLine.length - 1);\n          return contextLine + \"\\n\" + \" \".repeat(offset) + \"^^\\n\\n\";\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @param {string} [message]\n       * @returns {never}\n       */\n      static raiseParseError(tokens, message = undefined) {\n          message =\n              (message || \"Unexpected Token : \" + tokens.currentToken().value) + \"\\n\\n\" + Parser.createParserContext(tokens);\n          var error = new Error(message);\n          error[\"tokens\"] = tokens;\n          throw error;\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @param {string} [message]\n       */\n      raiseParseError(tokens, message = undefined) {\n          Parser.raiseParseError(tokens, message)\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @returns {ASTNode}\n       */\n      parseHyperScript(tokens) {\n          var result = this.parseElement(\"hyperscript\", tokens);\n          if (tokens.hasMore()) this.raiseParseError(tokens);\n          if (result) return result;\n      }\n\n      /**\n       * @param {ASTNode | undefined} elt\n       * @param {ASTNode} parent\n       */\n      setParent(elt, parent) {\n          if (typeof elt === 'object') {\n              elt.parent = parent;\n              if (typeof parent === 'object') {\n                  parent.children = (parent.children || new Set());\n                  parent.children.add(elt)\n              }\n              this.setParent(elt.next, parent);\n          }\n      }\n\n      /**\n       * @param {Token} token\n       * @returns {ParseRule}\n       */\n      commandStart(token) {\n          return this.COMMANDS[token.value || \"\"];\n      }\n\n      /**\n       * @param {Token} token\n       * @returns {ParseRule}\n       */\n      featureStart(token) {\n          return this.FEATURES[token.value || \"\"];\n      }\n\n      /**\n       * @param {Token} token\n       * @returns {boolean}\n       */\n      commandBoundary(token) {\n          if (\n              token.value == \"end\" ||\n              token.value == \"then\" ||\n              token.value == \"else\" ||\n              token.value == \"otherwise\" ||\n              token.value == \")\" ||\n              this.commandStart(token) ||\n              this.featureStart(token) ||\n              token.type == \"EOF\"\n          ) {\n              return true;\n          }\n          return false;\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @returns {(string | ASTNode)[]}\n       */\n      parseStringTemplate(tokens) {\n          /** @type {(string | ASTNode)[]} */\n          var returnArr = [\"\"];\n          do {\n              returnArr.push(tokens.lastWhitespace());\n              if (tokens.currentToken().value === \"$\") {\n                  tokens.consumeToken();\n                  var startingBrace = tokens.matchOpToken(\"{\");\n                  returnArr.push(this.requireElement(\"expression\", tokens));\n                  if (startingBrace) {\n                      tokens.requireOpToken(\"}\");\n                  }\n                  returnArr.push(\"\");\n              } else if (tokens.currentToken().value === \"\\\\\") {\n                  tokens.consumeToken(); // skip next\n                  tokens.consumeToken();\n              } else {\n                  var token = tokens.consumeToken();\n                  returnArr[returnArr.length - 1] += token ? token.value : \"\";\n              }\n          } while (tokens.hasMore());\n          returnArr.push(tokens.lastWhitespace());\n          return returnArr;\n      }\n\n      /**\n       * @param {ASTNode} commandList\n       */\n      ensureTerminated(commandList) {\n          const runtime = this.runtime\n          var implicitReturn = {\n              type: \"implicitReturn\",\n              op: function (context) {\n                  context.meta.returned = true;\n                  if (context.meta.resolve) {\n                      context.meta.resolve();\n                  }\n                  return runtime.HALT;\n              },\n              execute: function (ctx) {\n                  // do nothing\n              },\n          };\n\n          var end = commandList;\n          while (end.next) {\n              end = end.next;\n          }\n          end.next = implicitReturn;\n      }\n  }\n\n  class Runtime {\n    public lexer:Lexer\n    public parser:Parser\n\n      /**\n       *\n       * @param {Lexer} [lexer]\n       * @param {Parser} [parser]\n       */\n      constructor(lexer = undefined, parser = undefined) {\n          this.lexer = lexer ?? new Lexer;\n          this.parser = parser ?? new Parser(this)\n              .use(hyperscriptCoreGrammar)\n              .use(hyperscriptWebGrammar);\n          this.parser.runtime = this\n      }\n\n      /**\n       * @param {HTMLElement} elt\n       * @param {string} selector\n       * @returns boolean\n       */\n      matchesSelector(elt, selector) {\n          // noinspection JSUnresolvedVariable\n          var matchesFunction =\n              // @ts-ignore\n              elt.matches || elt.matchesSelector || elt.msMatchesSelector || elt.mozMatchesSelector || elt.webkitMatchesSelector || elt.oMatchesSelector;\n          return matchesFunction && matchesFunction.call(elt, selector);\n      }\n\n      /**\n       * @param {string} eventName\n       * @param {Object} [detail]\n       * @returns {Event}\n       */\n      makeEvent(eventName, detail) {\n          var evt;\n          if (globalScope.Event && typeof globalScope.Event === \"function\") {\n              evt = new Event(eventName, {\n                  bubbles: true,\n                  cancelable: true,\n              });\n              evt['detail'] = detail;\n          } else {\n              evt = document.createEvent(\"CustomEvent\");\n              evt.initCustomEvent(eventName, true, true, detail);\n          }\n          return evt;\n      }\n\n      /**\n       * @param {Element} elt\n       * @param {string} eventName\n       * @param {Object} [detail]\n       * @param {Element} [sender]\n       * @returns {boolean}\n       */\n      triggerEvent(elt, eventName, detail, sender = undefined) {\n          detail = detail || {};\n          detail[\"sender\"] = sender;\n          var event = this.makeEvent(eventName, detail);\n          var eventResult = elt.dispatchEvent(event);\n          return eventResult;\n      }\n\n      /**\n       * isArrayLike returns `true` if the provided value is an array or\n       * a NodeList (which is close enough to being an array for our purposes).\n       *\n       * @param {any} value\n       * @returns {value is Array | NodeList}\n       */\n      isArrayLike(value) {\n          return Array.isArray(value) ||\n              (typeof NodeList !== 'undefined' && (value instanceof NodeList || value instanceof HTMLCollection));\n      }\n\n      /**\n       * isIterable returns `true` if the provided value supports the\n       * iterator protocol.\n       *\n       * @param {any} value\n       * @returns {value is Iterable}\n       */\n      isIterable(value) {\n          return typeof value === 'object'\n              && Symbol.iterator in value\n              && typeof value[Symbol.iterator] === 'function';\n      }\n\n      /**\n       * shouldAutoIterate returns `true` if the provided value\n       * should be implicitly iterated over when accessing properties,\n       * and as the target of some commands.\n       *\n       * Currently, this is when the value is an {ElementCollection}\n       * or {isArrayLike} returns true.\n       *\n       * @param {any} value\n       * @returns {value is (any[] | ElementCollection)}\n       */\n      shouldAutoIterate(value) {\n          return value != null && value[shouldAutoIterateSymbol] ||\n              this.isArrayLike(value);\n      }\n\n      /**\n       * forEach executes the provided `func` on every item in the `value` array.\n       * if `value` is a single item (and not an array) then `func` is simply called\n       * once.  If `value` is null, then no further actions are taken.\n       *\n       * @template T\n       * @param {T | Iterable<T>} value\n       * @param {(item: T) => void} func\n       */\n      forEach(value, func) {\n          if (value == null) {\n              // do nothing\n          } else if (this.isIterable(value)) {\n              for (const nth of value) {\n                  func(nth);\n              }\n          } else if (this.isArrayLike(value)) {\n              for (var i = 0; i < value.length; i++) {\n                  func(value[i]);\n              }\n          } else {\n              func(value);\n          }\n      }\n\n      /**\n       * implicitLoop executes the provided `func` on:\n       * - every item of {value}, if {value} should be auto-iterated\n       *   (see {shouldAutoIterate})\n       * - {value} otherwise\n       *\n       * @template T\n       * @param {ElementCollection | T | T[]} value\n       * @param {(item: T) => void} func\n       */\n      implicitLoop(value, func) {\n          if (this.shouldAutoIterate(value)) {\n              for (const x of value) func(x);\n          } else {\n              func(value);\n          }\n      }\n\n      wrapArrays(args) {\n          var arr = [];\n          for (var i = 0; i < args.length; i++) {\n              var arg = args[i];\n              if (Array.isArray(arg)) {\n                  arr.push(Promise.all(arg));\n              } else {\n                  arr.push(arg);\n              }\n          }\n          return arr;\n      }\n\n      unwrapAsyncs(values) {\n          for (var i = 0; i < values.length; i++) {\n              var value = values[i];\n              if (value.asyncWrapper) {\n                  values[i] = value.value;\n              }\n              if (Array.isArray(value)) {\n                  for (var j = 0; j < value.length; j++) {\n                      var valueElement = value[j];\n                      if (valueElement.asyncWrapper) {\n                          value[j] = valueElement.value;\n                      }\n                  }\n              }\n          }\n      }\n\n      static HALT = {};\n      HALT = Runtime.HALT;\n\n      /**\n       * @param {ASTNode} command\n       * @param {Context} ctx\n       */\n      unifiedExec(command, ctx) {\n          while (true) {\n              try {\n                  var next = this.unifiedEval(command, ctx);\n              } catch (e) {\n                  if (ctx.meta.handlingFinally) {\n                      console.error(\" Exception in finally block: \", e);\n                      next = Runtime.HALT;\n                  } else {\n                      this.registerHyperTrace(ctx, e);\n                      if (ctx.meta.errorHandler && !ctx.meta.handlingError) {\n                          ctx.meta.handlingError = true;\n                          ctx.locals[ctx.meta.errorSymbol] = e;\n                          command = ctx.meta.errorHandler;\n                          continue;\n                      } else  {\n                          ctx.meta.currentException = e;\n                          next = Runtime.HALT;\n                      }\n                  }\n              }\n              if (next == null) {\n                  console.error(command, \" did not return a next element to execute! context: \", ctx);\n                  return;\n              } else if (next.then) {\n                  next.then(resolvedNext => {\n                      this.unifiedExec(resolvedNext, ctx);\n                  }).catch(reason => {\n                      this.unifiedExec({ // Anonymous command to simply throw the exception\n                          op: function(){\n                              throw reason;\n                          }\n                      }, ctx);\n                  });\n                  return;\n              } else if (next === Runtime.HALT) {\n                  if (ctx.meta.finallyHandler && !ctx.meta.handlingFinally) {\n                      ctx.meta.handlingFinally = true;\n                      command = ctx.meta.finallyHandler;\n                  } else {\n                      if (ctx.meta.onHalt) {\n                          ctx.meta.onHalt();\n                      }\n                      if (ctx.meta.currentException) {\n                          if (ctx.meta.reject) {\n                              ctx.meta.reject(ctx.meta.currentException);\n                              return;\n                          } else {\n                              throw ctx.meta.currentException;\n                          }\n                      } else {\n                          return;\n                      }\n                  }\n              } else {\n                  command = next; // move to the next command\n              }\n          }\n      }\n\n      /**\n      * @param {*} parseElement\n      * @param {Context} ctx\n      * @returns {*}\n      */\n      unifiedEval(parseElement, ctx) {\n          /** @type any[] */\n          var args = [ctx];\n          var async = false;\n          var wrappedAsyncs = false;\n\n          if (parseElement.args) {\n              for (var i = 0; i < parseElement.args.length; i++) {\n                  var argument = parseElement.args[i];\n                  if (argument == null) {\n                      args.push(null);\n                  } else if (Array.isArray(argument)) {\n                      var arr = [];\n                      for (var j = 0; j < argument.length; j++) {\n                          var element = argument[j];\n                          var value = element ? element.evaluate(ctx) : null; // OK\n                          if (value) {\n                              if (value.then) {\n                                  async = true;\n                              } else if (value.asyncWrapper) {\n                                  wrappedAsyncs = true;\n                              }\n                          }\n                          arr.push(value);\n                      }\n                      args.push(arr);\n                  } else if (argument.evaluate) {\n                      var value = argument.evaluate(ctx); // OK\n                      if (value) {\n                          if (value.then) {\n                              async = true;\n                          } else if (value.asyncWrapper) {\n                              wrappedAsyncs = true;\n                          }\n                      }\n                      args.push(value);\n                  } else {\n                      args.push(argument);\n                  }\n              }\n          }\n          if (async) {\n              return new Promise((resolve, reject) => {\n                  args = this.wrapArrays(args);\n                  Promise.all(args)\n                      .then(function (values) {\n                          if (wrappedAsyncs) {\n                              this.unwrapAsyncs(values);\n                          }\n                          try {\n                              var apply = parseElement.op.apply(parseElement, values);\n                              resolve(apply);\n                          } catch (e) {\n                              reject(e);\n                          }\n                      })\n                      .catch(function (reason) {\n                          reject(reason);\n                      });\n              });\n          } else {\n              if (wrappedAsyncs) {\n                  this.unwrapAsyncs(args);\n              }\n              return parseElement.op.apply(parseElement, args);\n          }\n      }\n\n      /**\n       * @type {string[] | null}\n       */\n      _scriptAttrs = null;\n\n      /**\n      * getAttributes returns the attribute name(s) to use when\n      * locating hyperscript scripts in a DOM element.  If no value\n      * has been configured, it defaults to config.attributes\n      * @returns string[]\n      */\n      getScriptAttributes() {\n          if (this._scriptAttrs == null) {\n              this._scriptAttrs = config.attributes.replace(/ /g, \"\").split(\",\");\n          }\n          return this._scriptAttrs;\n      }\n\n      /**\n      * @param {Element} elt\n      * @returns {string | null}\n      */\n      getScript(elt) {\n          for (var i = 0; i < this.getScriptAttributes().length; i++) {\n              var scriptAttribute = this.getScriptAttributes()[i];\n              if (elt.hasAttribute && elt.hasAttribute(scriptAttribute)) {\n                  return elt.getAttribute(scriptAttribute);\n              }\n          }\n          if (elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\") {\n              return elt.innerText;\n          }\n          return null;\n      }\n\n      hyperscriptFeaturesMap = new WeakMap\n\n      /**\n      * @param {*} elt\n      * @returns {Object}\n      */\n      getHyperscriptFeatures(elt) {\n          var hyperscriptFeatures = this.hyperscriptFeaturesMap.get(elt);\n          if (typeof hyperscriptFeatures === 'undefined') {\n              if (elt) {\n                  // in some rare cases, elt is null and this line crashes\n                  this.hyperscriptFeaturesMap.set(elt, hyperscriptFeatures = {});\n              }\n          }\n          return hyperscriptFeatures;\n      }\n\n      /**\n      * @param {Object} owner\n      * @param {Context} ctx\n      */\n      addFeatures(owner, ctx) {\n          if (owner) {\n              Object.assign(ctx.locals, this.getHyperscriptFeatures(owner));\n              this.addFeatures(owner.parentElement, ctx);\n          }\n      }\n\n      /**\n      * @param {*} owner\n      * @param {*} feature\n      * @param {*} hyperscriptTarget\n      * @param {*} event\n      * @returns {Context}\n      */\n      makeContext(owner, feature, hyperscriptTarget, event):Context {\n          return new Context(owner, feature, hyperscriptTarget, event, this)\n      }\n\n      /**\n      * @returns string\n      */\n      getScriptSelector() {\n          return this.getScriptAttributes()\n              .map(function (attribute) {\n                  return \"[\" + attribute + \"]\";\n              })\n              .join(\", \");\n      }\n\n      /**\n      * @param {any} value\n      * @param {string} type\n      * @returns {any}\n      */\n      convertValue(value, type) {\n          var dynamicResolvers = conversions.dynamicResolvers;\n          for (var i = 0; i < dynamicResolvers.length; i++) {\n              var dynamicResolver = dynamicResolvers[i];\n              var converted = dynamicResolver(type, value);\n              if (converted !== undefined) {\n                  return converted;\n              }\n          }\n\n          if (value == null) {\n              return null;\n          }\n          var converter = conversions[type];\n          if (converter) {\n              return converter(value);\n          }\n\n          throw \"Unknown conversion : \" + type;\n      }\n\n      /**\n      * @param {string} src\n      * @returns {ASTNode}\n      */\n      parse(src) {\n          const lexer = this.lexer, parser = this.parser\n          var tokens = lexer.tokenize(src);\n          if (this.parser.commandStart(tokens.currentToken())) {\n              var commandList = parser.requireElement(\"commandList\", tokens);\n              if (tokens.hasMore()) parser.raiseParseError(tokens);\n              parser.ensureTerminated(commandList);\n              return commandList;\n          } else if (parser.featureStart(tokens.currentToken())) {\n              var hyperscript = parser.requireElement(\"hyperscript\", tokens);\n              if (tokens.hasMore()) parser.raiseParseError(tokens);\n              return hyperscript;\n          } else {\n              var expression = parser.requireElement(\"expression\", tokens);\n              if (tokens.hasMore()) parser.raiseParseError(tokens);\n              return expression;\n          }\n      }\n\n      /**\n       *\n       * @param {ASTNode} elt\n       * @param {Context} ctx\n       * @returns {any}\n       */\n      evaluateNoPromise(elt, ctx) {\n          let result = elt.evaluate(ctx);\n          if (result.next) {\n              throw new Error(Tokens.sourceFor.call(elt) + \" returned a Promise in a context that they are not allowed.\");\n          }\n          return result;\n      }\n\n      /**\n      * @param {string} src\n      * @param {Partial<Context>} [ctx]\n      * @param {Object} [args]\n      * @returns {any}\n      */\n      evaluate(src, ctx?:Context, args = undefined) {\n          class HyperscriptModule extends EventTarget {\n            public module:any \n\n              constructor(mod) {\n                  super();\n                  this.module = mod;\n              }\n              toString() {\n                  return this.module.id;\n              }\n          }\n\n          var body = 'document' in globalScope\n              ? globalScope.document.body\n              : new HyperscriptModule(args && args.module);\n          ctx = Object.assign(this.makeContext(body, null, body, null), ctx || {});\n          var element = this.parse(src);\n          if (element.execute) {\n              element.execute(ctx);\n              return ctx.result;\n          } else if (element.apply) {\n              element.apply(body, body, args);\n              return this.getHyperscriptFeatures(body);\n          } else {\n              return element.evaluate(ctx);\n          }\n\n          function makeModule() {\n              return {}\n          }\n      }\n\n      /**\n      * @param {HTMLElement} elt\n      */\n      processNode(elt) {\n          var selector = this.getScriptSelector();\n          if (this.matchesSelector(elt, selector)) {\n              this.initElement(elt, elt);\n          }\n          if (elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\") {\n              this.initElement(elt, document.body);\n          }\n          if (elt.querySelectorAll) {\n              this.forEach(elt.querySelectorAll(selector + \", [type='text/hyperscript']\"), elt => {\n                  this.initElement(elt, elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\" ? document.body : elt);\n              });\n          }\n      }\n\n      /**\n      * @param {Element} elt\n      * @param {Element} [target]\n      */\n      initElement(elt, target) {\n          if (elt.closest && elt.closest(config.disableSelector)) {\n              return;\n          }\n          var internalData = this.getInternalData(elt);\n          if (!internalData.initialized) {\n              var src = this.getScript(elt);\n              if (src) {\n                  try {\n                      internalData.initialized = true;\n                      internalData.script = src;\n                      const lexer = this.lexer, parser = this.parser\n                      var tokens = lexer.tokenize(src);\n                      var hyperScript = parser.parseHyperScript(tokens);\n                      if (!hyperScript) return;\n                      hyperScript.apply(target || elt, elt);\n                      setTimeout(() => {\n                          this.triggerEvent(target || elt, \"load\", {\n                              hyperscript: true,\n                          });\n                      }, 1);\n                  } catch (e) {\n                      this.triggerEvent(elt, \"exception\", {\n                          error: e,\n                      });\n                      console.error(\n                          \"hyperscript errors were found on the following element:\",\n                          elt,\n                          \"\\n\\n\",\n                          e.message,\n                          e.stack\n                      );\n                  }\n              }\n          }\n      }\n\n      internalDataMap = new WeakMap\n\n      /**\n      * @param {Element} elt\n      * @returns {Object}\n      */\n      getInternalData(elt) {\n          var internalData = this.internalDataMap.get(elt);\n          if (typeof internalData === 'undefined') {\n              this.internalDataMap.set(elt, internalData = {});\n          }\n          return internalData;\n      }\n\n      /**\n      * @param {any} value\n      * @param {string} typeString\n      * @param {boolean} [nullOk]\n      * @returns {boolean}\n      */\n      typeCheck(value, typeString, nullOk) {\n          if (value == null && nullOk) {\n              return true;\n          }\n          var typeName = Object.prototype.toString.call(value).slice(8, -1);\n          return typeName === typeString;\n      }\n\n      getElementScope(context) {\n          var elt = context.meta && context.meta.owner;\n          if (elt) {\n              var internalData = this.getInternalData(elt);\n              var scopeName = \"elementScope\";\n              if (context.meta.feature && context.meta.feature.behavior) {\n                  scopeName = context.meta.feature.behavior + \"Scope\";\n              }\n              var elementScope = getOrInitObject(internalData, scopeName);\n              return elementScope;\n          } else {\n              return {}; // no element, return empty scope\n          }\n      }\n\n      /**\n      * @param {string} str\n      * @returns {boolean}\n      */\n      isReservedWord(str) {\n          return [\"meta\", \"it\", \"result\", \"locals\", \"event\", \"target\", \"detail\", \"sender\", \"body\"].includes(str)\n      }\n\n      /**\n      * @param {any} context\n      * @returns {boolean}\n      */\n      isHyperscriptContext(context) {\n          return context instanceof Context;\n      }\n\n      /**\n      * @param {string} str\n      * @param {Context} context\n      * @returns {any}\n      */\n      resolveSymbol(str, context, type) {\n          if (str === \"me\" || str === \"my\" || str === \"I\") {\n              return context.me;\n          }\n          if (str === \"it\" || str === \"its\" || str === \"result\") {\n              return context.result;\n          }\n          if (str === \"you\" || str === \"your\" || str === \"yourself\") {\n              return context.you;\n          } else {\n              if (type === \"global\") {\n                  return globalScope[str];\n              } else if (type === \"element\") {\n                  var elementScope = this.getElementScope(context);\n                  return elementScope[str];\n              } else if (type === \"local\") {\n                  return context.locals[str];\n              } else {\n                  // meta scope (used for event conditionals)\n                  if (context.meta && context.meta.context) {\n                      var fromMetaContext = context.meta.context[str];\n                      if (typeof fromMetaContext !== \"undefined\") {\n                          return fromMetaContext;\n                      }\n                  }\n                  if (this.isHyperscriptContext(context) && !this.isReservedWord(str)) {\n                      // local scope\n                      var fromContext = context.locals[str];\n                  } else {\n                      // direct get from normal JS object or top-level of context\n                      var fromContext = context[str];\n                  }\n                  if (typeof fromContext !== \"undefined\") {\n                      return fromContext;\n                  } else {\n                      // element scope\n                      var elementScope = this.getElementScope(context);\n                      fromContext = elementScope[str];\n                      if (typeof fromContext !== \"undefined\") {\n                          return fromContext;\n                      } else {\n                          // global scope\n                          return globalScope[str];\n                      }\n                  }\n              }\n          }\n      }\n\n      setSymbol(str, context, type, value) {\n          if (type === \"global\") {\n              globalScope[str] = value;\n          } else if (type === \"element\") {\n              var elementScope = this.getElementScope(context);\n              elementScope[str] = value;\n          } else if (type === \"local\") {\n              context.locals[str] = value;\n          } else {\n              if (this.isHyperscriptContext(context) && !this.isReservedWord(str) && typeof context.locals[str] !== \"undefined\") {\n                  // local scope\n                  context.locals[str] = value;\n              } else {\n                  // element scope\n                  var elementScope = this.getElementScope(context);\n                  var fromContext = elementScope[str];\n                  if (typeof fromContext !== \"undefined\") {\n                      elementScope[str] = value;\n                  } else {\n                      if (this.isHyperscriptContext(context) && !this.isReservedWord(str)) {\n                          // local scope\n                          context.locals[str] = value;\n                      } else {\n                          // direct set on normal JS object or top-level of context\n                          context[str] = value;\n                      }\n                  }\n              }\n          }\n      }\n\n      /**\n      * @param {ASTNode} command\n      * @param {Context} context\n      * @returns {undefined | ASTNode}\n      */\n      findNext(command, context) {\n          if (command) {\n              if (command.resolveNext) {\n                  return command.resolveNext(context);\n              } else if (command.next) {\n                  return command.next;\n              } else {\n                  return this.findNext(command.parent, context);\n              }\n          }\n      }\n\n      /**\n      * @param {Object<string,any>} root\n      * @param {string} property\n      * @param {Getter} getter\n      * @returns {any}\n      *\n      * @callback Getter\n      * @param {Object<string,any>} root\n      * @param {string} property\n      */\n      flatGet(root, property, getter) {\n          if (root != null) {\n              var val = getter(root, property);\n              if (typeof val !== \"undefined\") {\n                  return val;\n              }\n\n              if (this.shouldAutoIterate(root)) {\n                  // flat map\n                  var result = [];\n                  for (var component of root) {\n                      var componentValue = getter(component, property);\n                      result.push(componentValue);\n                  }\n                  return result;\n              }\n          }\n      }\n\n      resolveProperty(root, property) {\n          return this.flatGet(root, property, (root, property) => root[property] )\n      }\n\n      resolveAttribute(root, property) {\n          return this.flatGet(root, property, (root, property) => root.getAttribute && root.getAttribute(property) )\n      }\n\n      /**\n       *\n       * @param {Object<string, any>} root\n       * @param {string} property\n       * @returns {string}\n       */\n      resolveStyle(root, property) {\n          return this.flatGet(root, property, (root, property) => root.style && root.style[property] )\n      }\n\n      /**\n       *\n       * @param {Object<string, any>} root\n       * @param {string} property\n       * @returns {string}\n       */\n      resolveComputedStyle(root, property) {\n          return this.flatGet(root, property, (root, property) => getComputedStyle(\n              /** @type {Element} */ (root)).getPropertyValue(property) )\n      }\n\n      /**\n      * @param {Element} elt\n      * @param {string[]} nameSpace\n      * @param {string} name\n      * @param {any} value\n      */\n      assignToNamespace(elt, nameSpace, name, value) {\n          let root\n          if (typeof document !== \"undefined\" && elt === document.body) {\n              root = globalScope;\n          } else {\n              root = this.getHyperscriptFeatures(elt);\n          }\n          var propertyName;\n          while ((propertyName = nameSpace.shift()) !== undefined) {\n              var newRoot = root[propertyName];\n              if (newRoot == null) {\n                  newRoot = {};\n                  root[propertyName] = newRoot;\n              }\n              root = newRoot;\n          }\n\n          root[name] = value;\n      }\n\n      getHyperTrace(ctx, thrown) {\n          var trace = [];\n          var root = ctx;\n          while (root.meta.caller) {\n              root = root.meta.caller;\n          }\n          if (root.meta.traceMap) {\n              return root.meta.traceMap.get(thrown, trace);\n          }\n      }\n\n      registerHyperTrace(ctx, thrown) {\n          var trace = [];\n          var root = null;\n          while (ctx != null) {\n              trace.push(ctx);\n              root = ctx;\n              ctx = ctx.meta.caller;\n          }\n          if (root.meta.traceMap == null) {\n              root.meta.traceMap = new Map(); // TODO - WeakMap?\n          }\n          if (!root.meta.traceMap.get(thrown)) {\n              var traceEntry = {\n                  trace: trace,\n                  print: function (logger) {\n                      logger = logger || console.error;\n                      logger(\"hypertrace /// \");\n                      var maxLen = 0;\n                      for (var i = 0; i < trace.length; i++) {\n                          maxLen = Math.max(maxLen, trace[i].meta.feature.displayName.length);\n                      }\n                      for (var i = 0; i < trace.length; i++) {\n                          var traceElt = trace[i];\n                          logger(\n                              \"  ->\",\n                              traceElt.meta.feature.displayName.padEnd(maxLen + 2),\n                              \"-\",\n                              traceElt.meta.owner\n                          );\n                      }\n                  },\n              };\n              root.meta.traceMap.set(thrown, traceEntry);\n          }\n      }\n\n      /**\n      * @param {string} str\n      * @returns {string}\n      */\n      escapeSelector(str) {\n          return str.replace(/:/g, function (str) {\n              return \"\\\\\" + str;\n          });\n      }\n\n      /**\n      * @param {any} value\n      * @param {*} elt\n      */\n      nullCheck(value, elt) {\n          if (value == null) {\n              throw new Error(\"'\" + elt.sourceFor() + \"' is null\");\n          }\n      }\n\n      /**\n      * @param {any} value\n      * @returns {boolean}\n      */\n      isEmpty(value) {\n          return value == undefined || value.length === 0;\n      }\n\n      /**\n      * @param {any} value\n      * @returns {boolean}\n      */\n      doesExist(value) {\n          if(value == null){\n              return false;\n          }\n          if (this.shouldAutoIterate(value)) {\n              for (const elt of value) {\n                  return true;\n              }\n          }\n          return false;\n      }\n\n      /**\n      * @param {Node} node\n      * @returns {Document|ShadowRoot}\n      */\n      getRootNode(node) {\n          if (node && node instanceof Node) {\n              var rv = node.getRootNode();\n              if (rv instanceof Document || rv instanceof ShadowRoot) return rv;\n          }\n          return document;\n      }\n\n      /**\n       *\n       * @param {Element} elt\n       * @param {ASTNode} onFeature\n       * @returns {EventQueue}\n       *\n       * @typedef {{queue:Array, executing:boolean}} EventQueue\n       */\n      getEventQueueFor(elt, onFeature) {\n          let internalData = this.getInternalData(elt);\n          var eventQueuesForElt = internalData.eventQueues;\n          if (eventQueuesForElt == null) {\n              eventQueuesForElt = new Map();\n              internalData.eventQueues = eventQueuesForElt;\n          }\n          var eventQueueForFeature = eventQueuesForElt.get(onFeature);\n          if (eventQueueForFeature == null) {\n              eventQueueForFeature = {queue:[], executing:false};\n              eventQueuesForElt.set(onFeature, eventQueueForFeature);\n          }\n          return eventQueueForFeature;\n      }\n\n      /** @type string | null */\n      // @ts-ignore\n      hyperscriptUrl = \"document\" in globalScope ? document.currentScript.src : null;\n  }\n\n  class Context {\n    public meta:any\n    public locals:Object\n    public me:any\n    public you:any \n    public result:any \n    public event:any\n    public target:any\n    public detail:any\n    public sender:any\n    public body:any\n\n      /**\n      * @param {*} owner\n      * @param {*} feature\n      * @param {*} hyperscriptTarget\n      * @param {*} event\n      */\n      constructor(owner, feature, hyperscriptTarget, event, runtime) {\n          this.meta = {\n              parser: runtime.parser,\n              lexer: runtime.lexer,\n              runtime,\n              owner: owner,\n              feature: feature,\n              iterators: {},\n              ctx: this\n          }\n          this.locals = {};\n          this.me = hyperscriptTarget,\n          this.you = undefined\n          this.result = undefined\n          this.event = event;\n          this.target = event ? event.target : null;\n          this.detail = event ? event.detail : null;\n          this.sender = event ? event.detail ? event.detail.sender : null : null;\n          this.body = \"document\" in globalScope ? document.body : null;\n          runtime.addFeatures(owner, this);\n      }\n  }\n\n  class ElementCollection {\n    public _css:any\n    public relativeToElement:any\n    public escape:any\n\n      constructor(css, relativeToElement, escape = undefined) {\n          this._css = css;\n          this.relativeToElement = relativeToElement;\n          this.escape = escape;\n          this[shouldAutoIterateSymbol] = true;\n      }\n\n      get css() {\n          if (this.escape) {\n              return Runtime.prototype.escapeSelector(this._css);\n          } else {\n              return this._css;\n          }\n      }\n\n      get className() {\n          return this._css.substr(1);\n      }\n\n      get id() {\n          return this.className();\n      }\n\n      contains(elt) {\n          for (let element of this) {\n              if (element.contains(elt)) {\n                  return true;\n              }\n          }\n          return false;\n      }\n\n      get length() {\n          return this.selectMatches().length;\n      }\n\n      [Symbol.iterator]() {\n          let query = this.selectMatches();\n          return query [Symbol.iterator]();\n      }\n\n      selectMatches() {\n          let query = Runtime.prototype.getRootNode(this.relativeToElement).querySelectorAll(this.css);\n          return query;\n      }\n  }\n\n  const shouldAutoIterateSymbol = Symbol()\n\n  function getOrInitObject(root, prop) {\n      var value = root[prop];\n      if (value) {\n          return value;\n      } else {\n          var newObj = {};\n          root[prop] = newObj;\n          return newObj;\n      }\n  }\n\n  /**\n   * parseJSON parses a JSON string into a corresponding value.  If the\n   * value passed in is not valid JSON, then it logs an error and returns `null`.\n   *\n   * @param {string} jString\n   * @returns any\n   */\n  function parseJSON(jString) {\n      try {\n          return JSON.parse(jString);\n      } catch (error) {\n          logError(error);\n          return null;\n      }\n  }\n\n  /**\n   * logError writes an error message to the Javascript console.  It can take any\n   * value, but msg should commonly be a simple string.\n   * @param {*} msg\n   */\n  function logError(msg) {\n      if (console.error) {\n          console.error(msg);\n      } else if (console.log) {\n          console.log(\"ERROR: \", msg);\n      }\n  }\n\n  // TODO: JSDoc description of what's happening here\n  function varargConstructor(Cls, args) {\n      return new (Cls.bind.apply(Cls, [Cls].concat(args)))();\n  }\n\n  // Grammar\n\n  /**\n   * @param {Parser} parser\n   */\n  function hyperscriptCoreGrammar(parser) {\n      parser.addLeafExpression(\"parenthesized\", function (parser, _runtime, tokens) {\n          if (tokens.matchOpToken(\"(\")) {\n              var follows = tokens.clearFollows();\n              try {\n                  var expr = parser.requireElement(\"expression\", tokens);\n              } finally {\n                  tokens.restoreFollows(follows);\n              }\n              tokens.requireOpToken(\")\");\n              return expr;\n          }\n      });\n\n      parser.addLeafExpression(\"string\", function (parser, runtime, tokens) {\n          var stringToken = tokens.matchTokenType(\"STRING\");\n          if (!stringToken) return;\n          var rawValue = /** @type {string} */ (stringToken.value);\n          /** @type {any[]} */\n          var args;\n          if (stringToken.template) {\n              var innerTokens = Lexer.tokenize(rawValue, true);\n              args = parser.parseStringTemplate(innerTokens);\n          } else {\n              args = [];\n          }\n          return {\n              type: \"string\",\n              token: stringToken,\n              args: args,\n              op: function (context) {\n                  var returnStr = \"\";\n                  for (var i = 1; i < arguments.length; i++) {\n                      var val = arguments[i];\n                      if (val !== undefined) {\n                          returnStr += val;\n                      }\n                  }\n                  return returnStr;\n              },\n              evaluate: function (context) {\n                  if (args.length === 0) {\n                      return rawValue;\n                  } else {\n                      return runtime.unifiedEval(this, context);\n                  }\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"nakedString\", function (parser, runtime, tokens) {\n          if (tokens.hasMore()) {\n              var tokenArr = tokens.consumeUntilWhitespace();\n              tokens.matchTokenType(\"WHITESPACE\");\n              return {\n                  type: \"nakedString\",\n                  tokens: tokenArr,\n                  evaluate: function (context) {\n                      return tokenArr\n                          .map(function (t) {\n                              return t.value;\n                          })\n                          .join(\"\");\n                  },\n              };\n          }\n      });\n\n      parser.addLeafExpression(\"number\", function (parser, runtime, tokens) {\n          var number = tokens.matchTokenType(\"NUMBER\");\n          if (!number) return;\n          var numberToken = number;\n          var value = parseFloat(/** @type {string} */ (number.value));\n          return {\n              type: \"number\",\n              value: value,\n              numberToken: numberToken,\n              evaluate: function () {\n                  return value;\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"idRef\", function (parser, runtime, tokens) {\n          var elementId = tokens.matchTokenType(\"ID_REF\");\n          if (!elementId) return;\n          if (!elementId.value) return;\n          // TODO - unify these two expression types\n          if (elementId.template) {\n              var templateValue = elementId.value.substring(2);\n              var innerTokens = Lexer.tokenize(templateValue);\n              var innerExpression = parser.requireElement(\"expression\", innerTokens);\n              return {\n                  type: \"idRefTemplate\",\n                  args: [innerExpression],\n                  op: function (context, arg) {\n                      return runtime.getRootNode(context.me).getElementById(arg);\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              const value = elementId.value.substring(1);\n              return {\n                  type: \"idRef\",\n                  css: elementId.value,\n                  value: value,\n                  evaluate: function (context) {\n                      return (\n                          runtime.getRootNode(context.me).getElementById(value)\n                      );\n                  },\n              };\n          }\n      });\n\n      parser.addLeafExpression(\"classRef\", function (parser, runtime, tokens) {\n          var classRef = tokens.matchTokenType(\"CLASS_REF\");\n\n          if (!classRef) return;\n          if (!classRef.value) return;\n\n          // TODO - unify these two expression types\n          if (classRef.template) {\n              var templateValue = classRef.value.substring(2);\n              var innerTokens = Lexer.tokenize(templateValue);\n              var innerExpression = parser.requireElement(\"expression\", innerTokens);\n              return {\n                  type: \"classRefTemplate\",\n                  args: [innerExpression],\n                  op: function (context, arg) {\n                      return new ElementCollection(\".\" + arg, context.me, true)\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              const css = classRef.value;\n              return {\n                  type: \"classRef\",\n                  css: css,\n                  evaluate: function (context) {\n                      return new ElementCollection(css, context.me, true)\n                  },\n              };\n          }\n      });\n\n      class TemplatedQueryElementCollection extends ElementCollection {\n        public templateParts:any[]\n        public elements:any[]\n\n          constructor(css, relativeToElement, templateParts) {\n              super(css, relativeToElement);\n              this.templateParts = templateParts;\n              this.elements = templateParts.filter(elt => elt instanceof Element);\n          }\n\n          get css() {\n              let rv = \"\", i = 0\n              for (const val of this.templateParts) {\n                  if (val instanceof Element) {\n                      rv += \"[data-hs-query-id='\" + i++ + \"']\";\n                  } else rv += val;\n              }\n              return rv;\n          }\n\n          [Symbol.iterator]() {\n              this.elements.forEach((el, i) => el.dataset.hsQueryId = i);\n              const rv = super[Symbol.iterator]();\n              this.elements.forEach(el => el.removeAttribute('data-hs-query-id'));\n              return rv;\n          }\n      }\n\n      parser.addLeafExpression(\"queryRef\", function (parser, runtime, tokens) {\n          var queryStart = tokens.matchOpToken(\"<\");\n          if (!queryStart) return;\n          var queryTokens = tokens.consumeUntil(\"/\");\n          tokens.requireOpToken(\"/\");\n          tokens.requireOpToken(\">\");\n          var queryValue = queryTokens\n              .map(function (t) {\n                  if (t.type === \"STRING\") {\n                      return '\"' + t.value + '\"';\n                  } else {\n                      return t.value;\n                  }\n              })\n              .join(\"\");\n\n          var template, innerTokens, args;\n          if (queryValue.indexOf(\"$\") >= 0) {\n              template = true;\n              innerTokens = Lexer.tokenize(queryValue, true);\n              args = parser.parseStringTemplate(innerTokens);\n          }\n\n          return {\n              type: \"queryRef\",\n              css: queryValue,\n              args: args,\n              op: function (context, ...args) {\n                  if (template) {\n                      return new TemplatedQueryElementCollection(queryValue, context.me, args)\n                  } else {\n                      return new ElementCollection(queryValue, context.me)\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"attributeRef\", function (parser, runtime, tokens) {\n          var attributeRef = tokens.matchTokenType(\"ATTRIBUTE_REF\");\n          if (!attributeRef) return;\n          if (!attributeRef.value) return;\n          var outerVal = attributeRef.value;\n          if (outerVal.indexOf(\"[\") === 0) {\n              var innerValue = outerVal.substring(2, outerVal.length - 1);\n          } else {\n              var innerValue = outerVal.substring(1);\n          }\n          var css = \"[\" + innerValue + \"]\";\n          var split = innerValue.split(\"=\");\n          var name = split[0];\n          var value = split[1];\n          if (value) {\n              // strip quotes\n              if (value.indexOf('\"') === 0) {\n                  value = value.substring(1, value.length - 1);\n              }\n          }\n          return {\n              type: \"attributeRef\",\n              name: name,\n              css: css,\n              value: value,\n              op: function (context) {\n                  var target = context.you || context.me;\n                  if (target) {\n                      return target.getAttribute(name);\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"styleRef\", function (parser, runtime, tokens) {\n          var styleRef = tokens.matchTokenType(\"STYLE_REF\");\n          if (!styleRef) return;\n          if (!styleRef.value) return;\n          var styleProp = styleRef.value.substr(1);\n          if (styleProp.startsWith(\"computed-\")) {\n              styleProp = styleProp.substr(\"computed-\".length);\n              return {\n                  type: \"computedStyleRef\",\n                  name: styleProp,\n                  op: function (context) {\n                      var target = context.you || context.me;\n                      if (target) {\n                          return runtime.resolveComputedStyle(target, styleProp);\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              return {\n                  type: \"styleRef\",\n                  name: styleProp,\n                  op: function (context) {\n                      var target = context.you || context.me;\n                      if (target) {\n                          return runtime.resolveStyle(target, styleProp);\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n      });\n\n      parser.addGrammarElement(\"objectKey\", function (parser, runtime, tokens) {\n          var token;\n          if ((token = tokens.matchTokenType(\"STRING\"))) {\n              return {\n                  type: \"objectKey\",\n                  key: token.value,\n                  evaluate: function () {\n                      return token.value;\n                  },\n              };\n          } else if (tokens.matchOpToken(\"[\")) {\n              var expr = parser.parseElement(\"expression\", tokens);\n              tokens.requireOpToken(\"]\");\n              return {\n                  type: \"objectKey\",\n                  expr: expr,\n                  args: [expr],\n                  op: function (ctx, expr) {\n                      return expr;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              var key = \"\";\n              do {\n                  token = tokens.matchTokenType(\"IDENTIFIER\") || tokens.matchOpToken(\"-\");\n                  if (token) key += token.value;\n              } while (token);\n              return {\n                  type: \"objectKey\",\n                  key: key,\n                  evaluate: function () {\n                      return key;\n                  },\n              };\n          }\n      });\n\n      parser.addLeafExpression(\"objectLiteral\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"{\")) return;\n          var keyExpressions = [];\n          var valueExpressions = [];\n          if (!tokens.matchOpToken(\"}\")) {\n              do {\n                  var name = parser.requireElement(\"objectKey\", tokens);\n                  tokens.requireOpToken(\":\");\n                  var value = parser.requireElement(\"expression\", tokens);\n                  valueExpressions.push(value);\n                  keyExpressions.push(name);\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\"}\");\n          }\n          return {\n              type: \"objectLiteral\",\n              args: [keyExpressions, valueExpressions],\n              op: function (context, keys, values) {\n                  var returnVal = {};\n                  for (var i = 0; i < keys.length; i++) {\n                      returnVal[keys[i]] = values[i];\n                  }\n                  return returnVal;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"nakedNamedArgumentList\", function (parser, runtime, tokens) {\n          var fields = [];\n          var valueExpressions = [];\n          if (tokens.currentToken().type === \"IDENTIFIER\") {\n              do {\n                  var name = tokens.requireTokenType(\"IDENTIFIER\");\n                  tokens.requireOpToken(\":\");\n                  var value = parser.requireElement(\"expression\", tokens);\n                  valueExpressions.push(value);\n                  fields.push({ name: name, value: value });\n              } while (tokens.matchOpToken(\",\"));\n          }\n          return {\n              type: \"namedArgumentList\",\n              fields: fields,\n              args: [valueExpressions],\n              op: function (context, values) {\n                  var returnVal = { _namedArgList_: true };\n                  for (var i = 0; i < values.length; i++) {\n                      var field = fields[i];\n                      returnVal[field.name.value] = values[i];\n                  }\n                  return returnVal;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"namedArgumentList\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"(\")) return;\n          var elt = parser.requireElement(\"nakedNamedArgumentList\", tokens);\n          tokens.requireOpToken(\")\");\n          return elt;\n      });\n\n      parser.addGrammarElement(\"symbol\", function (parser, runtime, tokens) {\n          /** @scope {SymbolScope} */\n          var scope = \"default\";\n          if (tokens.matchToken(\"global\")) {\n              scope = \"global\";\n          } else if (tokens.matchToken(\"element\") || tokens.matchToken(\"module\")) {\n              scope = \"element\";\n              // optional possessive\n              if (tokens.matchOpToken(\"'\")) {\n                  tokens.requireToken(\"s\");\n              }\n          } else if (tokens.matchToken(\"local\")) {\n              scope = \"local\";\n          }\n\n          // TODO better look ahead here\n          let eltPrefix = tokens.matchOpToken(\":\");\n          let identifier = tokens.matchTokenType(\"IDENTIFIER\");\n          if (identifier && identifier.value) {\n              var name = identifier.value;\n              if (eltPrefix) {\n                  name = \":\" + name;\n              }\n              if (scope === \"default\") {\n                  if (name.indexOf(\"$\") === 0) {\n                      scope = \"global\";\n                  }\n                  if (name.indexOf(\":\") === 0) {\n                      scope = \"element\";\n                  }\n              }\n              return {\n                  type: \"symbol\",\n                  token: identifier,\n                  scope: scope,\n                  name: name,\n                  evaluate: function (context) {\n                      return runtime.resolveSymbol(name, context, scope);\n                  },\n              };\n          }\n      });\n\n      parser.addGrammarElement(\"implicitMeTarget\", function (parser, runtime, tokens) {\n          return {\n              type: \"implicitMeTarget\",\n              evaluate: function (context) {\n                  return context.you || context.me;\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"boolean\", function (parser, runtime, tokens) {\n          var booleanLiteral = tokens.matchToken(\"true\") || tokens.matchToken(\"false\");\n          if (!booleanLiteral) return;\n          const value = booleanLiteral.value === \"true\";\n          return {\n              type: \"boolean\",\n              evaluate: function (context) {\n                  return value;\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"null\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"null\")) {\n              return {\n                  type: \"null\",\n                  evaluate: function (context) {\n                      return null;\n                  },\n              };\n          }\n      });\n\n      parser.addLeafExpression(\"arrayLiteral\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"[\")) return;\n          var values = [];\n          if (!tokens.matchOpToken(\"]\")) {\n              do {\n                  var expr = parser.requireElement(\"expression\", tokens);\n                  values.push(expr);\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\"]\");\n          }\n          return {\n              type: \"arrayLiteral\",\n              values: values,\n              args: [values],\n              op: function (context, values) {\n                  return values;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"blockLiteral\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"\\\\\")) return;\n          var args = [];\n          var arg1 = tokens.matchTokenType(\"IDENTIFIER\");\n          if (arg1) {\n              args.push(arg1);\n              while (tokens.matchOpToken(\",\")) {\n                  args.push(tokens.requireTokenType(\"IDENTIFIER\"));\n              }\n          }\n          // TODO compound op token\n          tokens.requireOpToken(\"-\");\n          tokens.requireOpToken(\">\");\n          var expr = parser.requireElement(\"expression\", tokens);\n          return {\n              type: \"blockLiteral\",\n              args: args,\n              expr: expr,\n              evaluate: function (ctx) {\n                  var returnFunc = function () {\n                      //TODO - push scope\n                      for (var i = 0; i < args.length; i++) {\n                          ctx.locals[args[i].value] = arguments[i];\n                      }\n                      return expr.evaluate(ctx); //OK\n                  };\n                  return returnFunc;\n              },\n          };\n      });\n\n      parser.addIndirectExpression(\"propertyAccess\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchOpToken(\".\")) return;\n          var prop = tokens.requireTokenType(\"IDENTIFIER\");\n          var propertyAccess = {\n              type: \"propertyAccess\",\n              root: root,\n              prop: prop,\n              args: [root],\n              op: function (_context, rootVal) {\n                  var value = runtime.resolveProperty(rootVal, prop.value);\n                  return value;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n          return parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n      });\n\n      parser.addIndirectExpression(\"of\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchToken(\"of\")) return;\n          var newRoot = parser.requireElement(\"unaryExpression\", tokens);\n          // find the urroot\n          var childOfUrRoot = null;\n          var urRoot = root;\n          while (urRoot.root) {\n              childOfUrRoot = urRoot;\n              urRoot = urRoot.root;\n          }\n          if (urRoot.type !== \"symbol\" && urRoot.type !== \"attributeRef\" && urRoot.type !== \"styleRef\" && urRoot.type !== \"computedStyleRef\") {\n              parser.raiseParseError(tokens, \"Cannot take a property of a non-symbol: \" + urRoot.type);\n          }\n          var attribute = urRoot.type === \"attributeRef\";\n          var style = urRoot.type === \"styleRef\" || urRoot.type === \"computedStyleRef\";\n          if (attribute || style) {\n              var attributeElt = urRoot\n          }\n          var prop = urRoot.name;\n\n          var propertyAccess = {\n              type: \"ofExpression\",\n              prop: urRoot.token,\n              root: newRoot,\n              attribute: attributeElt,\n              expression: root,\n              args: [newRoot],\n              op: function (context, rootVal) {\n                  if (attribute) {\n                      return runtime.resolveAttribute(rootVal, prop);\n                  } else if (style) {\n                      if (urRoot.type === \"computedStyleRef\") {\n                          return runtime.resolveComputedStyle(rootVal, prop);\n                      } else {\n                          return runtime.resolveStyle(rootVal, prop);\n                      }\n                  } else {\n                      return runtime.resolveProperty(rootVal, prop);\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n\n          if (urRoot.type === \"attributeRef\") {\n              propertyAccess.attribute = urRoot;\n          }\n          if (childOfUrRoot) {\n              childOfUrRoot.root = propertyAccess;\n              childOfUrRoot.args = [propertyAccess];\n          } else {\n              root = propertyAccess;\n          }\n\n          return parser.parseElement(\"indirectExpression\", tokens, root);\n      });\n\n      parser.addIndirectExpression(\"possessive\", function (parser, runtime, tokens, root) {\n          if (parser.possessivesDisabled) {\n              return;\n          }\n          var apostrophe = tokens.matchOpToken(\"'\");\n          if (\n              apostrophe ||\n              (root.type === \"symbol\" &&\n                  (root.name === \"my\" || root.name === \"its\" || root.name === \"your\") &&\n                  (tokens.currentToken().type === \"IDENTIFIER\" || tokens.currentToken().type === \"ATTRIBUTE_REF\" || tokens.currentToken().type === \"STYLE_REF\"))\n          ) {\n              if (apostrophe) {\n                  tokens.requireToken(\"s\");\n              }\n\n              var attribute, style, prop;\n              attribute = parser.parseElement(\"attributeRef\", tokens);\n              if (attribute == null) {\n                  style = parser.parseElement(\"styleRef\", tokens);\n                  if (style == null) {\n                      prop = tokens.requireTokenType(\"IDENTIFIER\");\n                  }\n              }\n              var propertyAccess = {\n                  type: \"possessive\",\n                  root: root,\n                  attribute: attribute || style,\n                  prop: prop,\n                  args: [root],\n                  op: function (context, rootVal) {\n                      if (attribute) {\n                          // @ts-ignore\n                          var value = runtime.resolveAttribute(rootVal, attribute.name);\n                      } else if (style) {\n                          var value\n                          if (style.type === 'computedStyleRef') {\n                              value = runtime.resolveComputedStyle(rootVal, style['name']);\n                          } else {\n                              value = runtime.resolveStyle(rootVal, style['name']);\n                          }\n                      } else {\n                          var value = runtime.resolveProperty(rootVal, prop.value);\n                      }\n                      return value;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n              return parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n          }\n      });\n\n      parser.addIndirectExpression(\"inExpression\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchToken(\"in\")) return;\n          var target = parser.requireElement(\"unaryExpression\", tokens);\n          var propertyAccess = {\n              type: \"inExpression\",\n              root: root,\n              args: [root, target],\n              op: function (context, rootVal, target) {\n                  var returnArr = [];\n                  if (rootVal.css) {\n                      runtime.implicitLoop(target, function (targetElt) {\n                          var results = targetElt.querySelectorAll(rootVal.css);\n                          for (var i = 0; i < results.length; i++) {\n                              returnArr.push(results[i]);\n                          }\n                      });\n                  } else if (rootVal instanceof Element) {\n                      var within = false;\n                      runtime.implicitLoop(target, function (targetElt) {\n                          if (targetElt.contains(rootVal)) {\n                              within = true;\n                          }\n                      });\n                      if(within) {\n                          return rootVal;\n                      }\n                  } else {\n                      runtime.implicitLoop(rootVal, function (rootElt) {\n                          runtime.implicitLoop(target, function (targetElt) {\n                              if (rootElt === targetElt) {\n                                  returnArr.push(rootElt);\n                              }\n                          });\n                      });\n                  }\n                  return returnArr;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n          return parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n      });\n\n      parser.addIndirectExpression(\"asExpression\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchToken(\"as\")) return;\n          tokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n          var conversion = parser.requireElement(\"dotOrColonPath\", tokens).evaluate(); // OK No promise\n          var propertyAccess = {\n              type: \"asExpression\",\n              root: root,\n              args: [root],\n              op: function (context, rootVal) {\n                  return runtime.convertValue(rootVal, conversion);\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n          return parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n      });\n\n      parser.addIndirectExpression(\"functionCall\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchOpToken(\"(\")) return;\n          var args = [];\n          if (!tokens.matchOpToken(\")\")) {\n              do {\n                  args.push(parser.requireElement(\"expression\", tokens));\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\")\");\n          }\n\n          if (root.root) {\n              var functionCall = {\n                  type: \"functionCall\",\n                  root: root,\n                  argExressions: args,\n                  args: [root.root, args],\n                  op: function (context, rootRoot, args) {\n                      runtime.nullCheck(rootRoot, root.root);\n                      var func = rootRoot[root.prop.value];\n                      runtime.nullCheck(func, root);\n                      if (func.hyperfunc) {\n                          args.push(context);\n                      }\n                      return func.apply(rootRoot, args);\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              var functionCall = {\n                  type: \"functionCall\",\n                  root: root,\n                  argExressions: args,\n                  args: [root, args],\n                  op: function (context, func, argVals) {\n                      runtime.nullCheck(func, root);\n                      if (func.hyperfunc) {\n                          argVals.push(context);\n                      }\n                      var apply = func.apply(null, argVals);\n                      return apply;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n          return parser.parseElement(\"indirectExpression\", tokens, functionCall);\n      });\n\n      parser.addIndirectExpression(\"attributeRefAccess\", function (parser, runtime, tokens, root) {\n          var attribute = parser.parseElement(\"attributeRef\", tokens);\n          if (!attribute) return;\n          var attributeAccess = {\n              type: \"attributeRefAccess\",\n              root: root,\n              attribute: attribute,\n              args: [root],\n              op: function (_ctx, rootVal) {\n                  // @ts-ignore\n                  var value = runtime.resolveAttribute(rootVal, attribute.name);\n                  return value;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n          return attributeAccess;\n      });\n\n      parser.addIndirectExpression(\"arrayIndex\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchOpToken(\"[\")) return;\n          var andBefore = false;\n          var andAfter = false;\n          var firstIndex = null;\n          var secondIndex = null;\n\n          if (tokens.matchOpToken(\"..\")) {\n              andBefore = true;\n              firstIndex = parser.requireElement(\"expression\", tokens);\n          } else {\n              firstIndex = parser.requireElement(\"expression\", tokens);\n\n              if (tokens.matchOpToken(\"..\")) {\n                  andAfter = true;\n                  var current = tokens.currentToken();\n                  if (current.type !== \"R_BRACKET\") {\n                      secondIndex = parser.parseElement(\"expression\", tokens);\n                  }\n              }\n          }\n          tokens.requireOpToken(\"]\");\n\n          var arrayIndex = {\n              type: \"arrayIndex\",\n              root: root,\n              prop: firstIndex,\n              firstIndex: firstIndex,\n              secondIndex: secondIndex,\n              args: [root, firstIndex, secondIndex],\n              op: function (_ctx, root, firstIndex, secondIndex) {\n                  if (root == null) {\n                      return null;\n                  }\n                  if (andBefore) {\n                      if (firstIndex < 0) {\n                          firstIndex = root.length + firstIndex;\n                      }\n                      return root.slice(0, firstIndex + 1); // returns all items from beginning to firstIndex (inclusive)\n                  } else if (andAfter) {\n                      if (secondIndex != null) {\n                          if (secondIndex < 0) {\n                              secondIndex = root.length + secondIndex;\n                          }\n                          return root.slice(firstIndex, secondIndex + 1); // returns all items from firstIndex to secondIndex (inclusive)\n                      } else {\n                          return root.slice(firstIndex); // returns from firstIndex to end of array\n                      }\n                  } else {\n                      return root[firstIndex];\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n\n          return parser.parseElement(\"indirectExpression\", tokens, arrayIndex);\n      });\n\n      // taken from https://drafts.csswg.org/css-values-4/#relative-length\n      //        and https://drafts.csswg.org/css-values-4/#absolute-length\n      //        (NB: we do not support `in` dues to conflicts w/ the hyperscript grammar)\n      var STRING_POSTFIXES = [\n          'em', 'ex', 'cap', 'ch', 'ic', 'rem', 'lh', 'rlh', 'vw', 'vh', 'vi', 'vb', 'vmin', 'vmax',\n          'cm', 'mm', 'Q', 'pc', 'pt', 'px'\n      ];\n      parser.addGrammarElement(\"postfixExpression\", function (parser, runtime, tokens) {\n          var root = parser.parseElement(\"primaryExpression\", tokens);\n\n          let stringPosfix = tokens.matchAnyToken.apply(tokens, STRING_POSTFIXES) || tokens.matchOpToken(\"%\");\n          if (stringPosfix) {\n              return {\n                  type: \"stringPostfix\",\n                  postfix: stringPosfix.value,\n                  args: [root],\n                  op: function (context, val) {\n                      return \"\" + val + stringPosfix.value;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n\n          var timeFactor = null;\n          if (tokens.matchToken(\"s\") || tokens.matchToken(\"seconds\")) {\n              timeFactor = 1000;\n          } else if (tokens.matchToken(\"ms\") || tokens.matchToken(\"milliseconds\")) {\n              timeFactor = 1;\n          }\n          if (timeFactor) {\n              return {\n                  type: \"timeExpression\",\n                  time: root,\n                  factor: timeFactor,\n                  args: [root],\n                  op: function (_context, val) {\n                      return val * timeFactor;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n\n          if (tokens.matchOpToken(\":\")) {\n              var typeName = tokens.requireTokenType(\"IDENTIFIER\");\n              if (!typeName.value) return;\n              var nullOk = !tokens.matchOpToken(\"!\");\n              return {\n                  type: \"typeCheck\",\n                  typeName: typeName,\n                  nullOk: nullOk,\n                  args: [root],\n                  op: function (context, val) {\n                      var passed = runtime.typeCheck(val, this.typeName.value, nullOk);\n                      if (passed) {\n                          return val;\n                      } else {\n                          throw new Error(\"Typecheck failed!  Expected: \" + typeName.value);\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              return root;\n          }\n      });\n\n      parser.addGrammarElement(\"logicalNot\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"not\")) return;\n          var root = parser.requireElement(\"unaryExpression\", tokens);\n          return {\n              type: \"logicalNot\",\n              root: root,\n              args: [root],\n              op: function (context, val) {\n                  return !val;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"noExpression\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"no\")) return;\n          var root = parser.requireElement(\"unaryExpression\", tokens);\n          return {\n              type: \"noExpression\",\n              root: root,\n              args: [root],\n              op: function (_context, val) {\n                  return runtime.isEmpty(val);\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"some\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"some\")) return;\n          var root = parser.requireElement(\"expression\", tokens);\n          return {\n              type: \"noExpression\",\n              root: root,\n              args: [root],\n              op: function (_context, val) {\n                  return !runtime.isEmpty(val);\n              },\n              evaluate(context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"negativeNumber\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"-\")) return;\n          var root = parser.requireElement(\"unaryExpression\", tokens);\n          return {\n              type: \"negativeNumber\",\n              root: root,\n              args: [root],\n              op: function (context, value) {\n                  return -1 * value;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"unaryExpression\", function (parser, runtime, tokens) {\n          tokens.matchToken(\"the\"); // optional \"the\"\n          return parser.parseAnyOf(\n              [\"beepExpression\", \"logicalNot\", \"relativePositionalExpression\", \"positionalExpression\", \"noExpression\", \"negativeNumber\", \"postfixExpression\"],\n              tokens\n          );\n      });\n\n      parser.addGrammarElement(\"beepExpression\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"beep!\")) return;\n          var expression = parser.parseElement(\"unaryExpression\", tokens);\n          if (expression) {\n              expression['booped'] = true;\n              var originalEvaluate = expression.evaluate;\n              expression.evaluate = function(ctx){\n                  let value = originalEvaluate.apply(expression, arguments);\n                  let element = ctx.me;\n                  if (runtime.triggerEvent(element, \"hyperscript:beep\", {element, expression, value})) {\n                      var typeName;\n                      if (value) {\n                          if (value instanceof ElementCollection){\n                              typeName = \"ElementCollection\";\n                          } else if (value.constructor) {\n                              typeName = value.constructor.name;\n                          } else {\n                              typeName = \"unknown\";\n                          }\n                      } else {\n                          typeName = \"object (null)\"\n                      }\n                      var logValue = value;\n                      if (typeName === \"String\") {\n                          logValue = '\"' + logValue + '\"';\n                      } else if (value instanceof ElementCollection) {\n                          logValue = Array.from(value);\n                      }\n                      console.log(\"///_ BEEP! The expression (\" + Tokens.sourceFor.call(expression).substr(6) + \") evaluates to:\", logValue,  \"of type \" + typeName);\n                  }\n                  return value;\n              }\n              return expression;\n          }\n      });\n\n      var scanForwardQuery = function(start, root, match, wrap) {\n          var results = root.querySelectorAll(match);\n          for (var i = 0; i < results.length; i++) {\n              var elt = results[i];\n              if (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_PRECEDING) {\n                  return elt;\n              }\n          }\n          if (wrap) {\n              return results[0];\n          }\n      }\n\n      var scanBackwardsQuery = function(start, root, match, wrap) {\n          var results = root.querySelectorAll(match);\n          for (var i = results.length - 1; i >= 0; i--) {\n              var elt = results[i];\n              if (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_FOLLOWING) {\n                  return elt;\n              }\n          }\n          if (wrap) {\n              return results[results.length - 1];\n          }\n      }\n\n      var scanForwardArray = function(start, array, match, wrap) {\n          var matches = [];\n          Runtime.prototype.forEach(array, function(elt){\n              if (elt.matches(match) || elt === start) {\n                  matches.push(elt);\n              }\n          })\n          for (var i = 0; i < matches.length - 1; i++) {\n              var elt = matches[i];\n              if (elt === start) {\n                  return matches[i + 1];\n              }\n          }\n          if (wrap) {\n              var first = matches[0];\n              if (first && first.matches(match)) {\n                  return first;\n              }\n          }\n      }\n\n      var scanBackwardsArray = function(start, array, match, wrap) {\n          return scanForwardArray(start, Array.from(array).reverse(), match, wrap);\n      }\n\n      parser.addGrammarElement(\"relativePositionalExpression\", function (parser, runtime, tokens) {\n          var op = tokens.matchAnyToken(\"next\", \"previous\");\n          if (!op) return;\n          var forwardSearch = op.value === \"next\";\n\n          var thing = parser.parseElement(\"expression\", tokens);\n\n          if (tokens.matchToken(\"from\")) {\n              tokens.pushFollow(\"in\");\n              try {\n                  var from = parser.requireElement(\"unaryExpression\", tokens);\n              } finally {\n                  tokens.popFollow();\n              }\n          } else {\n              var from = parser.requireElement(\"implicitMeTarget\", tokens);\n          }\n\n          var inSearch = false;\n          var withinElt;\n          if (tokens.matchToken(\"in\")) {\n              inSearch = true;\n              var inElt = parser.requireElement(\"unaryExpression\", tokens);\n          } else if (tokens.matchToken(\"within\")) {\n              withinElt = parser.requireElement(\"unaryExpression\", tokens);\n          } else {\n              withinElt = document.body;\n          }\n\n          var wrapping = false;\n          if (tokens.matchToken(\"with\")) {\n              tokens.requireToken(\"wrapping\")\n              wrapping = true;\n          }\n\n          return {\n              type: \"relativePositionalExpression\",\n              from: from,\n              forwardSearch: forwardSearch,\n              inSearch: inSearch,\n              wrapping: wrapping,\n              inElt: inElt,\n              withinElt: withinElt,\n              operator: op.value,\n              args: [thing, from, inElt, withinElt],\n              op: function (context, thing, from, inElt, withinElt) {\n\n                  var css = thing.css;\n                  if (css == null) {\n                      throw \"Expected a CSS value\";\n                  }\n\n                  if(inSearch) {\n                      if (inElt) {\n                          if (forwardSearch) {\n                              return scanForwardArray(from, inElt, css, wrapping);\n                          } else {\n                              return scanBackwardsArray(from, inElt, css, wrapping);\n                          }\n                      }\n                  } else {\n                      if (withinElt) {\n                          if (forwardSearch) {\n                              return scanForwardQuery(from, withinElt, css, wrapping);\n                          } else {\n                              return scanBackwardsQuery(from, withinElt, css, wrapping);\n                          }\n                      }\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          }\n\n      });\n\n      parser.addGrammarElement(\"positionalExpression\", function (parser, runtime, tokens) {\n          var op = tokens.matchAnyToken(\"first\", \"last\", \"random\");\n          if (!op) return;\n          tokens.matchAnyToken(\"in\", \"from\", \"of\");\n          var rhs = parser.requireElement(\"unaryExpression\", tokens);\n          const operator = op.value;\n          return {\n              type: \"positionalExpression\",\n              rhs: rhs,\n              operator: op.value,\n              args: [rhs],\n              op: function (context, rhsVal) {\n                  if (rhsVal && !Array.isArray(rhsVal)) {\n                      if (rhsVal.children) {\n                          rhsVal = rhsVal.children;\n                      } else {\n                          rhsVal = Array.from(rhsVal);\n                      }\n                  }\n                  if (rhsVal) {\n                      if (operator === \"first\") {\n                          return rhsVal[0];\n                      } else if (operator === \"last\") {\n                          return rhsVal[rhsVal.length - 1];\n                      } else if (operator === \"random\") {\n                          return rhsVal[Math.floor(Math.random() * rhsVal.length)];\n                      }\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"mathOperator\", function (parser, runtime, tokens) {\n          var expr = parser.parseElement(\"unaryExpression\", tokens);\n          var mathOp,\n              initialMathOp = null;\n          mathOp = tokens.matchAnyOpToken(\"+\", \"-\", \"*\", \"/\", \"%\");\n          while (mathOp) {\n              initialMathOp = initialMathOp || mathOp;\n              var operator = mathOp.value;\n              if (initialMathOp.value !== operator) {\n                  parser.raiseParseError(tokens, \"You must parenthesize math operations with different operators\");\n              }\n              var rhs = parser.parseElement(\"unaryExpression\", tokens);\n              expr = {\n                  type: \"mathOperator\",\n                  lhs: expr,\n                  rhs: rhs,\n                  operator: operator,\n                  args: [expr, rhs],\n                  op: function (context, lhsVal, rhsVal) {\n                      if (operator === \"+\") {\n                          return lhsVal + rhsVal;\n                      } else if (operator === \"-\") {\n                          return lhsVal - rhsVal;\n                      } else if (operator === \"*\") {\n                          return lhsVal * rhsVal;\n                      } else if (operator === \"/\") {\n                          return lhsVal / rhsVal;\n                      } else if (operator === \"%\") {\n                          return lhsVal % rhsVal;\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n              mathOp = tokens.matchAnyOpToken(\"+\", \"-\", \"*\", \"/\", \"%\");\n          }\n          return expr;\n      });\n\n      parser.addGrammarElement(\"mathExpression\", function (parser, runtime, tokens) {\n          return parser.parseAnyOf([\"mathOperator\", \"unaryExpression\"], tokens);\n      });\n\n      function sloppyContains(src, container, value){\n          if (container['contains']) {\n              return container.contains(value);\n          } else if (container['includes']) {\n              return container.includes(value);\n          } else {\n              throw Error(\"The value of \" + src.sourceFor() + \" does not have a contains or includes method on it\");\n          }\n      }\n      function sloppyMatches(src, target, toMatch){\n          if (target['match']) {\n              return !!target.match(toMatch);\n          } else if (target['matches']) {\n              return target.matches(toMatch);\n          } else {\n              throw Error(\"The value of \" + src.sourceFor() + \" does not have a match or matches method on it\");\n          }\n      }\n\n      parser.addGrammarElement(\"comparisonOperator\", function (parser, runtime, tokens) {\n          var expr = parser.parseElement(\"mathExpression\", tokens);\n          var comparisonToken = tokens.matchAnyOpToken(\"<\", \">\", \"<=\", \">=\", \"==\", \"===\", \"!=\", \"!==\");\n          var operator = comparisonToken ? comparisonToken.value : null;\n          var hasRightValue = true; // By default, most comparisons require two values, but there are some exceptions.\n          var typeCheck = false;\n\n          if (operator == null) {\n              if (tokens.matchToken(\"is\") || tokens.matchToken(\"am\")) {\n                  if (tokens.matchToken(\"not\")) {\n                      if (tokens.matchToken(\"in\")) {\n                          operator = \"not in\";\n                      } else if (tokens.matchToken(\"a\")) {\n                          operator = \"not a\";\n                          typeCheck = true;\n                      } else if (tokens.matchToken(\"empty\")) {\n                          operator = \"not empty\";\n                          hasRightValue = false;\n                      } else {\n                          operator = \"!=\";\n                      }\n                  } else if (tokens.matchToken(\"in\")) {\n                      operator = \"in\";\n                  } else if (tokens.matchToken(\"a\")) {\n                      operator = \"a\";\n                      typeCheck = true;\n                  } else if (tokens.matchToken(\"empty\")) {\n                      operator = \"empty\";\n                      hasRightValue = false;\n                  } else if (tokens.matchToken(\"less\")) {\n                      tokens.requireToken(\"than\");\n                      if (tokens.matchToken(\"or\")) {\n                          tokens.requireToken(\"equal\");\n                          tokens.requireToken(\"to\");\n                          operator = \"<=\";\n                      } else {\n                          operator = \"<\";\n                      }\n                  } else if (tokens.matchToken(\"greater\")) {\n                      tokens.requireToken(\"than\");\n                      if (tokens.matchToken(\"or\")) {\n                          tokens.requireToken(\"equal\");\n                          tokens.requireToken(\"to\");\n                          operator = \">=\";\n                      } else {\n                          operator = \">\";\n                      }\n                  } else {\n                      operator = \"==\";\n                  }\n              } else if (tokens.matchToken(\"exist\") || tokens.matchToken(\"exists\")) {\n                  operator = \"exist\";\n                  hasRightValue = false;\n              } else if (tokens.matchToken(\"matches\") || tokens.matchToken(\"match\")) {\n                  operator = \"match\";\n              } else if (tokens.matchToken(\"contains\") || tokens.matchToken(\"contain\")) {\n                  operator = \"contain\";\n              } else if (tokens.matchToken(\"includes\") || tokens.matchToken(\"include\")) {\n                  operator = \"include\";\n              } else if (tokens.matchToken(\"do\") || tokens.matchToken(\"does\")) {\n                  tokens.requireToken(\"not\");\n                  if (tokens.matchToken(\"matches\") || tokens.matchToken(\"match\")) {\n                      operator = \"not match\";\n                  } else if (tokens.matchToken(\"contains\") || tokens.matchToken(\"contain\")) {\n                      operator = \"not contain\";\n                  } else if (tokens.matchToken(\"exist\") || tokens.matchToken(\"exist\")) {\n                      operator = \"not exist\";\n                      hasRightValue = false;\n                  } else if (tokens.matchToken(\"include\")) {\n                      operator = \"not include\";\n                  } else {\n                      parser.raiseParseError(tokens, \"Expected matches or contains\");\n                  }\n              }\n          }\n\n          if (operator) {\n              // Do not allow chained comparisons, which is dumb\n              var typeName, nullOk, rhs\n              if (typeCheck) {\n                  typeName = tokens.requireTokenType(\"IDENTIFIER\");\n                  nullOk = !tokens.matchOpToken(\"!\");\n              } else if (hasRightValue) {\n                  rhs = parser.requireElement(\"mathExpression\", tokens);\n                  if (operator === \"match\" || operator === \"not match\") {\n                      rhs = rhs.css ? rhs.css : rhs;\n                  }\n              }\n              var lhs = expr;\n              expr = {\n                  type: \"comparisonOperator\",\n                  operator: operator,\n                  typeName: typeName,\n                  nullOk: nullOk,\n                  lhs: expr,\n                  rhs: rhs,\n                  args: [expr, rhs],\n                  op: function (context, lhsVal, rhsVal) {\n                      if (operator === \"==\") {\n                          return lhsVal == rhsVal;\n                      } else if (operator === \"!=\") {\n                          return lhsVal != rhsVal;\n                      }\n                      if (operator === \"match\") {\n                          return lhsVal != null && sloppyMatches(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"not match\") {\n                          return lhsVal == null || !sloppyMatches(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"in\") {\n                          return rhsVal != null && sloppyContains(rhs, rhsVal, lhsVal);\n                      }\n                      if (operator === \"not in\") {\n                          return rhsVal == null || !sloppyContains(rhs, rhsVal, lhsVal);\n                      }\n                      if (operator === \"contain\") {\n                          return lhsVal != null && sloppyContains(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"not contain\") {\n                          return lhsVal == null || !sloppyContains(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"include\") {\n                          return lhsVal != null && sloppyContains(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"not include\") {\n                          return lhsVal == null || !sloppyContains(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"===\") {\n                          return lhsVal === rhsVal;\n                      } else if (operator === \"!==\") {\n                          return lhsVal !== rhsVal;\n                      } else if (operator === \"<\") {\n                          return lhsVal < rhsVal;\n                      } else if (operator === \">\") {\n                          return lhsVal > rhsVal;\n                      } else if (operator === \"<=\") {\n                          return lhsVal <= rhsVal;\n                      } else if (operator === \">=\") {\n                          return lhsVal >= rhsVal;\n                      } else if (operator === \"empty\") {\n                          return runtime.isEmpty(lhsVal);\n                      } else if (operator === \"not empty\") {\n                          return !runtime.isEmpty(lhsVal);\n                      } else if (operator === \"exist\") {\n                          return runtime.doesExist(lhsVal);\n                      } else if (operator === \"not exist\") {\n                          return !runtime.doesExist(lhsVal);\n                      } else if (operator === \"a\") {\n                          return runtime.typeCheck(lhsVal, typeName.value, nullOk);\n                      } else if (operator === \"not a\") {\n                          return !runtime.typeCheck(lhsVal, typeName.value, nullOk);\n                      } else {\n                          throw \"Unknown comparison : \" + operator;\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n          return expr;\n      });\n\n      parser.addGrammarElement(\"comparisonExpression\", function (parser, runtime, tokens) {\n          return parser.parseAnyOf([\"comparisonOperator\", \"mathExpression\"], tokens);\n      });\n\n      parser.addGrammarElement(\"logicalOperator\", function (parser, runtime, tokens) {\n          var expr = parser.parseElement(\"comparisonExpression\", tokens);\n          var logicalOp,\n              initialLogicalOp = null;\n          logicalOp = tokens.matchToken(\"and\") || tokens.matchToken(\"or\");\n          while (logicalOp) {\n              initialLogicalOp = initialLogicalOp || logicalOp;\n              if (initialLogicalOp.value !== logicalOp.value) {\n                  parser.raiseParseError(tokens, \"You must parenthesize logical operations with different operators\");\n              }\n              var rhs = parser.requireElement(\"comparisonExpression\", tokens);\n              const operator = logicalOp.value;\n              expr = {\n                  type: \"logicalOperator\",\n                  operator: operator,\n                  lhs: expr,\n                  rhs: rhs,\n                  args: [expr, rhs],\n                  op: function (context, lhsVal, rhsVal) {\n                      if (operator === \"and\") {\n                          return lhsVal && rhsVal;\n                      } else {\n                          return lhsVal || rhsVal;\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n              logicalOp = tokens.matchToken(\"and\") || tokens.matchToken(\"or\");\n          }\n          return expr;\n      });\n\n      parser.addGrammarElement(\"logicalExpression\", function (parser, runtime, tokens) {\n          return parser.parseAnyOf([\"logicalOperator\", \"mathExpression\"], tokens);\n      });\n\n      parser.addGrammarElement(\"asyncExpression\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"async\")) {\n              var value = parser.requireElement(\"logicalExpression\", tokens);\n              var expr = {\n                  type: \"asyncExpression\",\n                  value: value,\n                  evaluate: function (context) {\n                      return {\n                          asyncWrapper: true,\n                          value: this.value.evaluate(context), //OK\n                      };\n                  },\n              };\n              return expr;\n          } else {\n              return parser.parseElement(\"logicalExpression\", tokens);\n          }\n      });\n\n      parser.addGrammarElement(\"expression\", function (parser, runtime, tokens) {\n          tokens.matchToken(\"the\"); // optional the\n          return parser.parseElement(\"asyncExpression\", tokens);\n      });\n\n      parser.addGrammarElement(\"assignableExpression\", function (parser, runtime, tokens) {\n          tokens.matchToken(\"the\"); // optional the\n\n          // TODO obviously we need to generalize this as a left hand side / targetable concept\n          var expr = parser.parseElement(\"primaryExpression\", tokens);\n          if (expr && (\n              expr.type === \"symbol\" ||\n              expr.type === \"ofExpression\" ||\n              expr.type === \"propertyAccess\" ||\n              expr.type === \"attributeRefAccess\" ||\n              expr.type === \"attributeRef\" ||\n              expr.type === \"styleRef\" ||\n              expr.type === \"arrayIndex\" ||\n              expr.type === \"possessive\")\n          ) {\n              return expr;\n          } else {\n              parser.raiseParseError(\n                  tokens,\n                  \"A target expression must be writable.  The expression type '\" + (expr && expr.type) + \"' is not.\"\n              );\n          }\n          return expr;\n      });\n\n      parser.addGrammarElement(\"hyperscript\", function (parser, runtime, tokens) {\n          var features = [];\n\n          if (tokens.hasMore()) {\n              while (parser.featureStart(tokens.currentToken()) || tokens.currentToken().value === \"(\") {\n                  var feature = parser.requireElement(\"feature\", tokens);\n                  features.push(feature);\n                  tokens.matchToken(\"end\"); // optional end\n              }\n          }\n          return {\n              type: \"hyperscript\",\n              features: features,\n              apply: function (target, source, args) {\n                  // no op\n                  for (const feature of features) {\n                      feature.install(target, source, args);\n                  }\n              },\n          };\n      });\n\n      var parseEventArgs = function (tokens) {\n          var args = [];\n          // handle argument list (look ahead 3)\n          if (\n              tokens.token(0).value === \"(\" &&\n              (tokens.token(1).value === \")\" || tokens.token(2).value === \",\" || tokens.token(2).value === \")\")\n          ) {\n              tokens.matchOpToken(\"(\");\n              do {\n                  args.push(tokens.requireTokenType(\"IDENTIFIER\"));\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\")\");\n          }\n          return args;\n      };\n\n      parser.addFeature(\"on\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"on\")) return;\n          var every = false;\n          if (tokens.matchToken(\"every\")) {\n              every = true;\n          }\n          var events = [];\n          var displayName = null;\n          do {\n              var on = parser.requireElement(\"eventName\", tokens, \"Expected event name\");\n\n              var eventName = on.evaluate(); // OK No Promise\n\n              if (displayName) {\n                  displayName = displayName + \" or \" + eventName;\n              } else {\n                  displayName = \"on \" + eventName;\n              }\n              var args = parseEventArgs(tokens);\n\n              var filter = null;\n              if (tokens.matchOpToken(\"[\")) {\n                  filter = parser.requireElement(\"expression\", tokens);\n                  tokens.requireOpToken(\"]\");\n              }\n\n              var startCount, endCount ,unbounded;\n              if (tokens.currentToken().type === \"NUMBER\") {\n                  var startCountToken = tokens.consumeToken();\n                  if (!startCountToken.value) return;\n                  startCount = parseInt(startCountToken.value);\n                  if (tokens.matchToken(\"to\")) {\n                      var endCountToken = tokens.consumeToken();\n                      if (!endCountToken.value) return;\n                      endCount = parseInt(endCountToken.value);\n                  } else if (tokens.matchToken(\"and\")) {\n                      unbounded = true;\n                      tokens.requireToken(\"on\");\n                  }\n              }\n\n              var intersectionSpec, mutationSpec;\n              if (eventName === \"intersection\") {\n                  intersectionSpec = {};\n                  if (tokens.matchToken(\"with\")) {\n                      intersectionSpec[\"with\"] = parser.requireElement(\"expression\", tokens).evaluate();\n                  }\n                  if (tokens.matchToken(\"having\")) {\n                      do {\n                          if (tokens.matchToken(\"margin\")) {\n                              intersectionSpec[\"rootMargin\"] = parser.requireElement(\"stringLike\", tokens).evaluate();\n                          } else if (tokens.matchToken(\"threshold\")) {\n                              intersectionSpec[\"threshold\"] = parser.requireElement(\"expression\", tokens).evaluate();\n                          } else {\n                              parser.raiseParseError(tokens, \"Unknown intersection config specification\");\n                          }\n                      } while (tokens.matchToken(\"and\"));\n                  }\n              } else if (eventName === \"mutation\") {\n                  mutationSpec = {};\n                  if (tokens.matchToken(\"of\")) {\n                      do {\n                          if (tokens.matchToken(\"anything\")) {\n                              mutationSpec[\"attributes\"] = true;\n                              mutationSpec[\"subtree\"] = true;\n                              mutationSpec[\"characterData\"] = true;\n                              mutationSpec[\"childList\"] = true;\n                          } else if (tokens.matchToken(\"childList\")) {\n                              mutationSpec[\"childList\"] = true;\n                          } else if (tokens.matchToken(\"attributes\")) {\n                              mutationSpec[\"attributes\"] = true;\n                              mutationSpec[\"attributeOldValue\"] = true;\n                          } else if (tokens.matchToken(\"subtree\")) {\n                              mutationSpec[\"subtree\"] = true;\n                          } else if (tokens.matchToken(\"characterData\")) {\n                              mutationSpec[\"characterData\"] = true;\n                              mutationSpec[\"characterDataOldValue\"] = true;\n                          } else if (tokens.currentToken().type === \"ATTRIBUTE_REF\") {\n                              var attribute = tokens.consumeToken();\n                              if (mutationSpec[\"attributeFilter\"] == null) {\n                                  mutationSpec[\"attributeFilter\"] = [];\n                              }\n                              if (attribute.value.indexOf(\"@\") == 0) {\n                                  mutationSpec[\"attributeFilter\"].push(attribute.value.substring(1));\n                              } else {\n                                  parser.raiseParseError(\n                                      tokens,\n                                      \"Only shorthand attribute references are allowed here\"\n                                  );\n                              }\n                          } else {\n                              parser.raiseParseError(tokens, \"Unknown mutation config specification\");\n                          }\n                      } while (tokens.matchToken(\"or\"));\n                  } else {\n                      mutationSpec[\"attributes\"] = true;\n                      mutationSpec[\"characterData\"] = true;\n                      mutationSpec[\"childList\"] = true;\n                  }\n              }\n\n              var from = null;\n              var elsewhere = false;\n              if (tokens.matchToken(\"from\")) {\n                  if (tokens.matchToken(\"elsewhere\")) {\n                      elsewhere = true;\n                  } else {\n                      from = parser.parseElement(\"expression\", tokens);\n                      if (!from) {\n                          parser.raiseParseError(tokens, 'Expected either target value or \"elsewhere\".');\n                      }\n                  }\n              }\n              // support both \"elsewhere\" and \"from elsewhere\"\n              if (from === null && elsewhere === false && tokens.matchToken(\"elsewhere\")) {\n                  elsewhere = true;\n              }\n\n              if (tokens.matchToken(\"in\")) {\n                  var inExpr = parser.parseElement('unaryExpression', tokens);\n              }\n\n              if (tokens.matchToken(\"debounced\")) {\n                  tokens.requireToken(\"at\");\n                  var timeExpr = parser.requireElement(\"expression\", tokens);\n                  // @ts-ignore\n                  var debounceTime = timeExpr.evaluate({}); // OK No promise TODO make a literal time expr\n              } else if (tokens.matchToken(\"throttled\")) {\n                  tokens.requireToken(\"at\");\n                  var timeExpr = parser.requireElement(\"expression\", tokens);\n                  // @ts-ignore\n                  var throttleTime = timeExpr.evaluate({}); // OK No promise TODO make a literal time expr\n              }\n\n              events.push({\n                  execCount: 0,\n                  every: every,\n                  on: eventName,\n                  args: args,\n                  filter: filter,\n                  from: from,\n                  inExpr: inExpr,\n                  elsewhere: elsewhere,\n                  startCount: startCount,\n                  endCount: endCount,\n                  unbounded: unbounded,\n                  debounceTime: debounceTime,\n                  throttleTime: throttleTime,\n                  mutationSpec: mutationSpec,\n                  intersectionSpec: intersectionSpec,\n                  debounced: undefined,\n                  lastExec: undefined,\n              });\n          } while (tokens.matchToken(\"or\"));\n\n          var queueLast = true;\n          if (!every) {\n              if (tokens.matchToken(\"queue\")) {\n                  if (tokens.matchToken(\"all\")) {\n                      var queueAll = true;\n                      var queueLast = false;\n                  } else if (tokens.matchToken(\"first\")) {\n                      var queueFirst = true;\n                  } else if (tokens.matchToken(\"none\")) {\n                      var queueNone = true;\n                  } else {\n                      tokens.requireToken(\"last\");\n                  }\n              }\n          }\n\n          var start = parser.requireElement(\"commandList\", tokens);\n          parser.ensureTerminated(start);\n\n          var errorSymbol, errorHandler;\n          if (tokens.matchToken(\"catch\")) {\n              errorSymbol = tokens.requireTokenType(\"IDENTIFIER\").value;\n              errorHandler = parser.requireElement(\"commandList\", tokens);\n              parser.ensureTerminated(errorHandler);\n          }\n\n          if (tokens.matchToken(\"finally\")) {\n              var finallyHandler = parser.requireElement(\"commandList\", tokens);\n              parser.ensureTerminated(finallyHandler);\n          }\n\n          var onFeature = {\n              displayName: displayName,\n              events: events,\n              start: start,\n              every: every,\n              execCount: 0,\n              errorHandler: errorHandler,\n              errorSymbol: errorSymbol,\n              execute: function (/** @type {Context} */ ctx) {\n                  let eventQueueInfo = runtime.getEventQueueFor(ctx.me, onFeature);\n                  if (eventQueueInfo.executing && every === false) {\n                      if (queueNone || (queueFirst && eventQueueInfo.queue.length > 0)) {\n                          return;\n                      }\n                      if (queueLast) {\n                          eventQueueInfo.queue.length = 0;\n                      }\n                      eventQueueInfo.queue.push(ctx);\n                      return;\n                  }\n                  onFeature.execCount++;\n                  eventQueueInfo.executing = true;\n                  ctx.meta.onHalt = function () {\n                      eventQueueInfo.executing = false;\n                      var queued = eventQueueInfo.queue.shift();\n                      if (queued) {\n                          setTimeout(function () {\n                              onFeature.execute(queued);\n                          }, 1);\n                      }\n                  };\n                  ctx.meta.reject = function (err) {\n                      console.error(err.message ? err.message : err);\n                      var hypertrace = runtime.getHyperTrace(ctx, err);\n                      if (hypertrace) {\n                          hypertrace.print();\n                      }\n                      runtime.triggerEvent(ctx.me, \"exception\", {\n                          error: err,\n                      });\n                  };\n                  start.execute(ctx);\n              },\n              install: function (elt, source) {\n                  for (const eventSpec of onFeature.events) {\n                      var targets;\n                      if (eventSpec.elsewhere) {\n                          targets = [document];\n                      } else if (eventSpec.from) {\n                          targets = eventSpec.from.evaluate(runtime.makeContext(elt, onFeature, elt, null));\n                      } else {\n                          targets = [elt];\n                      }\n                      runtime.implicitLoop(targets, function (target) {\n                          // OK NO PROMISE\n\n                          var eventName = eventSpec.on;\n                          if (target == null) {\n                            console.warn(\"'%s' feature ignored because target does not exists:\", displayName, elt);\n                            return;\n                          }\n                          \n                          if (eventSpec.mutationSpec) {\n                              eventName = \"hyperscript:mutation\";\n                              const observer = new MutationObserver(function (mutationList, observer) {\n                                  if (!onFeature.executing) {\n                                      runtime.triggerEvent(target, eventName, {\n                                          mutationList: mutationList,\n                                          observer: observer,\n                                      });\n                                  }\n                              });\n                              observer.observe(target, eventSpec.mutationSpec);\n                          }\n\n                          if (eventSpec.intersectionSpec) {\n                              eventName = \"hyperscript:insersection\";\n                              const observer = new IntersectionObserver(function (entries) {\n                                  for (const entry of entries) {\n                                      var detail = {\n                                          observer: observer,\n                                      };\n                                      detail = Object.assign(detail, entry);\n                                      detail[\"intersecting\"] = entry.isIntersecting;\n                                      runtime.triggerEvent(target, eventName, detail);\n                                  }\n                              }, eventSpec.intersectionSpec);\n                              observer.observe(target);\n                          }\n\n                          var addEventListener = target.addEventListener || target.on;\n                          addEventListener.call(target, eventName, function listener(evt) {\n                              // OK NO PROMISE\n                              if (typeof Node !== 'undefined' && elt instanceof Node && target !== elt && !elt.isConnected) {\n                                  target.removeEventListener(eventName, listener);\n                                  return;\n                              }\n\n                              var ctx = runtime.makeContext(elt, onFeature, elt, evt);\n                              if (eventSpec.elsewhere && elt.contains(evt.target)) {\n                                  return;\n                              }\n                              if (eventSpec.from) {\n                                  ctx.result = target;\n                              }\n\n                              // establish context\n                              for (const arg of eventSpec.args) {\n                                  let eventValue = ctx.event[arg.value];\n                                  if (eventValue !== undefined) {\n                                      ctx.locals[arg.value] = eventValue;\n                                  } else if ('detail' in ctx.event) {\n                                      ctx.locals[arg.value] = ctx.event['detail'][arg.value];\n                                  }\n                              }\n\n                              // install error handler if any\n                              ctx.meta.errorHandler = errorHandler;\n                              ctx.meta.errorSymbol = errorSymbol;\n                              ctx.meta.finallyHandler = finallyHandler;\n\n                              // apply filter\n                              if (eventSpec.filter) {\n                                  var initialCtx = ctx.meta.context;\n                                  ctx.meta.context = ctx.event;\n                                  try {\n                                      var value = eventSpec.filter.evaluate(ctx); //OK NO PROMISE\n                                      if (value) {\n                                          // match the javascript semantics for if statements\n                                      } else {\n                                          return;\n                                      }\n                                  } finally {\n                                      ctx.meta.context = initialCtx;\n                                  }\n                              }\n\n                              if (eventSpec.inExpr) {\n                                  var inElement = evt.target;\n                                  while (true) {\n                                      if (inElement.matches && inElement.matches(eventSpec.inExpr.css)) {\n                                          ctx.result = inElement;\n                                          break;\n                                      } else {\n                                          inElement = inElement.parentElement;\n                                          if (inElement == null) {\n                                              return; // no match found\n                                          }\n                                      }\n                                  }\n                              }\n\n                              // verify counts\n                              eventSpec.execCount++;\n                              if (eventSpec.startCount) {\n                                  if (eventSpec.endCount) {\n                                      if (\n                                          eventSpec.execCount < eventSpec.startCount ||\n                                          eventSpec.execCount > eventSpec.endCount\n                                      ) {\n                                          return;\n                                      }\n                                  } else if (eventSpec.unbounded) {\n                                      if (eventSpec.execCount < eventSpec.startCount) {\n                                          return;\n                                      }\n                                  } else if (eventSpec.execCount !== eventSpec.startCount) {\n                                      return;\n                                  }\n                              }\n\n                              //debounce\n                              if (eventSpec.debounceTime) {\n                                  if (eventSpec.debounced) {\n                                      clearTimeout(eventSpec.debounced);\n                                  }\n                                  eventSpec.debounced = setTimeout(function () {\n                                      onFeature.execute(ctx);\n                                  }, eventSpec.debounceTime);\n                                  return;\n                              }\n\n                              // throttle\n                              if (eventSpec.throttleTime) {\n                                  if (\n                                      eventSpec.lastExec &&\n                                      Date.now() < (eventSpec.lastExec + eventSpec.throttleTime)\n                                  ) {\n                                      return;\n                                  } else {\n                                      eventSpec.lastExec = Date.now();\n                                  }\n                              }\n\n                              // apply execute\n                              onFeature.execute(ctx);\n                          });\n                      });\n                  }\n              },\n              executing: undefined\n          };\n          parser.setParent(start, onFeature);\n          return onFeature;\n      });\n\n      parser.addFeature(\"def\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"def\")) return;\n          var functionName = parser.requireElement(\"dotOrColonPath\", tokens);\n          var nameVal = functionName.evaluate(); // OK\n          var nameSpace = nameVal.split(\".\");\n          var funcName = nameSpace.pop();\n\n          var args = [];\n          if (tokens.matchOpToken(\"(\")) {\n              if (tokens.matchOpToken(\")\")) {\n                  // emtpy args list\n              } else {\n                  do {\n                      args.push(tokens.requireTokenType(\"IDENTIFIER\"));\n                  } while (tokens.matchOpToken(\",\"));\n                  tokens.requireOpToken(\")\");\n              }\n          }\n\n          var start = parser.requireElement(\"commandList\", tokens);\n\n          var errorSymbol, errorHandler;\n          if (tokens.matchToken(\"catch\")) {\n              errorSymbol = tokens.requireTokenType(\"IDENTIFIER\").value;\n              errorHandler = parser.parseElement(\"commandList\", tokens);\n          }\n\n          if (tokens.matchToken(\"finally\")) {\n              var finallyHandler = parser.requireElement(\"commandList\", tokens);\n              parser.ensureTerminated(finallyHandler);\n          }\n\n          var functionFeature = {\n              displayName:\n                  funcName +\n                  \"(\" +\n                  args\n                      .map(function (arg) {\n                          return arg.value;\n                      })\n                      .join(\", \") +\n                  \")\",\n              name: funcName,\n              args: args,\n              start: start,\n              errorHandler: errorHandler,\n              errorSymbol: errorSymbol,\n              finallyHandler: finallyHandler,\n              install: function (target, source) {\n                  var func = function () {\n                      // null, worker\n                      var ctx = runtime.makeContext(source, functionFeature, target, null);\n\n                      // install error handler if any\n                      ctx.meta.errorHandler = errorHandler;\n                      ctx.meta.errorSymbol = errorSymbol;\n                      ctx.meta.finallyHandler = finallyHandler;\n\n                      for (var i = 0; i < args.length; i++) {\n                          var name = args[i];\n                          var argumentVal = arguments[i];\n                          if (name) {\n                              ctx.locals[name.value] = argumentVal;\n                          }\n                      }\n                      ctx.meta.caller = arguments[args.length];\n                      if (ctx.meta.caller) {\n                          ctx.meta.callingCommand = ctx.meta.caller.meta.command;\n                      }\n                      var resolve,\n                          reject = null;\n                      var promise = new Promise(function (theResolve, theReject) {\n                          resolve = theResolve;\n                          reject = theReject;\n                      });\n                      start.execute(ctx);\n                      if (ctx.meta.returned) {\n                          return ctx.meta.returnValue;\n                      } else {\n                          ctx.meta.resolve = resolve;\n                          ctx.meta.reject = reject;\n                          return promise;\n                      }\n                  };\n                  func['hyperfunc'] = true;\n                  func['hypername'] = nameVal;\n                  runtime.assignToNamespace(target, nameSpace, funcName, func);\n              },\n          };\n\n          parser.ensureTerminated(start);\n\n          // terminate error handler if any\n          if (errorHandler) {\n              parser.ensureTerminated(errorHandler);\n          }\n\n          parser.setParent(start, functionFeature);\n          return functionFeature;\n      });\n\n      parser.addFeature(\"set\", function (parser, runtime, tokens) {\n          let setCmd = parser.parseElement(\"setCommand\", tokens);\n          if (setCmd) {\n              if (setCmd.target.scope !== \"element\") {\n                  parser.raiseParseError(tokens, \"variables declared at the feature level must be element scoped.\");\n              }\n              let setFeature = {\n                  start: setCmd,\n                  install: function (target, source) {\n                      setCmd && setCmd.execute(runtime.makeContext(target, setFeature, target, null));\n                  },\n              };\n              parser.ensureTerminated(setCmd);\n              return setFeature;\n          }\n      });\n\n      parser.addFeature(\"init\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"init\")) return;\n\n          var immediately = tokens.matchToken(\"immediately\");\n\n          var start = parser.requireElement(\"commandList\", tokens);\n          var initFeature = {\n              start: start,\n              install: function (target, source) {\n                  let handler = function () {\n                      start && start.execute(runtime.makeContext(target, initFeature, target, null));\n                  };\n                  if (immediately) {\n                      handler();\n                  } else {\n                      setTimeout(handler, 0);\n                  }\n              },\n          };\n  \n          // terminate body\n          parser.ensureTerminated(start);\n          parser.setParent(start, initFeature);\n          return initFeature;\n      });\n\n      parser.addFeature(\"worker\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"worker\")) {\n              parser.raiseParseError(\n                  tokens,\n                  \"In order to use the 'worker' feature, include \" +\n                      \"the _hyperscript worker plugin. See \" +\n                      \"https://hyperscript.org/features/worker/ for \" +\n                      \"more info.\"\n              );\n              return undefined\n          }\n      });\n\n      parser.addFeature(\"behavior\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"behavior\")) return;\n          var path = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n          var nameSpace = path.split(\".\");\n          var name = nameSpace.pop();\n\n          var formalParams = [];\n          if (tokens.matchOpToken(\"(\") && !tokens.matchOpToken(\")\")) {\n              do {\n                  formalParams.push(tokens.requireTokenType(\"IDENTIFIER\").value);\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\")\");\n          }\n          var hs = parser.requireElement(\"hyperscript\", tokens);\n          for (var i = 0; i < hs.features.length; i++) {\n              var feature = hs.features[i];\n              feature.behavior = path;\n          }\n\n          return {\n              install: function (target, source) {\n                  runtime.assignToNamespace(\n                      globalScope.document && globalScope.document.body,\n                      nameSpace,\n                      name,\n                      function (target, source, innerArgs) {\n                          var internalData = runtime.getInternalData(target);\n                          var elementScope = getOrInitObject(internalData, path + \"Scope\");\n                          for (var i = 0; i < formalParams.length; i++) {\n                              elementScope[formalParams[i]] = innerArgs[formalParams[i]];\n                          }\n                          hs.apply(target, source);\n                      }\n                  );\n              },\n          };\n      });\n\n      parser.addFeature(\"install\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"install\")) return;\n          var behaviorPath = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n          var behaviorNamespace = behaviorPath.split(\".\");\n          var args = parser.parseElement(\"namedArgumentList\", tokens);\n\n          var installFeature;\n          return (installFeature = {\n              install: function (target, source) {\n                  runtime.unifiedEval(\n                      {\n                          args: [args],\n                          op: function (ctx, args) {\n                              var behavior = globalScope;\n                              for (var i = 0; i < behaviorNamespace.length; i++) {\n                                  behavior = behavior[behaviorNamespace[i]];\n                                  if (typeof behavior !== \"object\" && typeof behavior !== \"function\")\n                                      throw new Error(\"No such behavior defined as \" + behaviorPath);\n                              }\n\n                              if (!(behavior instanceof Function))\n                                  throw new Error(behaviorPath + \" is not a behavior\");\n\n                              behavior(target, source, args);\n                          },\n                      },\n                      runtime.makeContext(target, installFeature, target, null)\n                  );\n              },\n          });\n      });\n\n      parser.addGrammarElement(\"jsBody\", function (parser, runtime, tokens) {\n          var jsSourceStart = tokens.currentToken().start;\n          var jsLastToken = tokens.currentToken();\n\n          var funcNames = [];\n          var funcName = \"\";\n          var expectFunctionDeclaration = false;\n          while (tokens.hasMore()) {\n              jsLastToken = tokens.consumeToken();\n              var peek = tokens.token(0, true);\n              if (peek.type === \"IDENTIFIER\" && peek.value === \"end\") {\n                  break;\n              }\n              if (expectFunctionDeclaration) {\n                  if (jsLastToken.type === \"IDENTIFIER\" || jsLastToken.type === \"NUMBER\") {\n                      funcName += jsLastToken.value;\n                  } else {\n                      if (funcName !== \"\") funcNames.push(funcName);\n                      funcName = \"\";\n                      expectFunctionDeclaration = false;\n                  }\n              } else if (jsLastToken.type === \"IDENTIFIER\" && jsLastToken.value === \"function\") {\n                  expectFunctionDeclaration = true;\n              }\n          }\n          var jsSourceEnd = jsLastToken.end + 1;\n\n          return {\n              type: \"jsBody\",\n              exposedFunctionNames: funcNames,\n              jsSource: tokens.source.substring(jsSourceStart, jsSourceEnd),\n          };\n      });\n\n      parser.addFeature(\"js\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"js\")) return;\n          var jsBody = parser.requireElement(\"jsBody\", tokens);\n\n          var jsSource =\n              jsBody.jsSource +\n              \"\\nreturn { \" +\n              jsBody.exposedFunctionNames\n                  .map(function (name) {\n                      return name + \":\" + name;\n                  })\n                  .join(\",\") +\n              \" } \";\n          var func = new Function(jsSource);\n\n          return {\n              jsSource: jsSource,\n              function: func,\n              exposedFunctionNames: jsBody.exposedFunctionNames,\n              install: function () {\n                  Object.assign(globalScope, func());\n              },\n          };\n      });\n\n      parser.addCommand(\"js\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"js\")) return;\n          // Parse inputs\n          var inputs = [];\n          if (tokens.matchOpToken(\"(\")) {\n              if (tokens.matchOpToken(\")\")) {\n                  // empty input list\n              } else {\n                  do {\n                      var inp = tokens.requireTokenType(\"IDENTIFIER\");\n                      inputs.push(inp.value);\n                  } while (tokens.matchOpToken(\",\"));\n                  tokens.requireOpToken(\")\");\n              }\n          }\n\n          var jsBody = parser.requireElement(\"jsBody\", tokens);\n          tokens.matchToken(\"end\");\n\n          var func = varargConstructor(Function, inputs.concat([jsBody.jsSource]));\n\n          var command = {\n              jsSource: jsBody.jsSource,\n              function: func,\n              inputs: inputs,\n              op: function (context) {\n                  var args = [];\n                  inputs.forEach(function (input) {\n                      args.push(runtime.resolveSymbol(input, context, 'default'));\n                  });\n                  var result = func.apply(globalScope, args);\n                  if (result && typeof result.then === \"function\") {\n                      return new Promise(function (resolve) {\n                          result.then(function (actualResult) {\n                              context.result = actualResult;\n                              resolve(runtime.findNext(this, context));\n                          });\n                      });\n                  } else {\n                      context.result = result;\n                      return runtime.findNext(this, context);\n                  }\n              },\n          };\n          return command;\n      });\n\n      parser.addCommand(\"async\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"async\")) return;\n          if (tokens.matchToken(\"do\")) {\n              var body = parser.requireElement(\"commandList\", tokens);\n\n              // Append halt\n              var end = body;\n              while (end.next) end = end.next;\n              end.next = runtime.HALT;\n\n              tokens.requireToken(\"end\");\n          } else {\n              var body = parser.requireElement(\"command\", tokens);\n          }\n          var command = {\n              body: body,\n              op: function (context) {\n                  setTimeout(function () {\n                      body.execute(context);\n                  });\n                  return runtime.findNext(this, context);\n              },\n          };\n          parser.setParent(body, command);\n          return command;\n      });\n\n      parser.addCommand(\"tell\", function (parser, runtime, tokens) {\n          var startToken = tokens.currentToken();\n          if (!tokens.matchToken(\"tell\")) return;\n          var value = parser.requireElement(\"expression\", tokens);\n          var body = parser.requireElement(\"commandList\", tokens);\n          if (tokens.hasMore() && !parser.featureStart(tokens.currentToken())) {\n              tokens.requireToken(\"end\");\n          }\n          var slot = \"tell_\" + startToken.start;\n          var tellCmd = {\n              value: value,\n              body: body,\n              args: [value],\n              resolveNext: function (context) {\n                  var iterator = context.meta.iterators[slot];\n                  if (iterator.index < iterator.value.length) {\n                      context.you = iterator.value[iterator.index++];\n                      return body;\n                  } else {\n                      // restore original me\n                      context.you = iterator.originalYou;\n                      if (this.next) {\n                          return this.next;\n                      } else {\n                          return runtime.findNext(this.parent, context);\n                      }\n                  }\n              },\n              op: function (context, value) {\n                  if (value == null) {\n                      value = [];\n                  } else if (!(Array.isArray(value) || value instanceof NodeList)) {\n                      value = [value];\n                  }\n                  context.meta.iterators[slot] = {\n                      originalYou: context.you,\n                      index: 0,\n                      value: value,\n                  };\n                  return this.resolveNext(context);\n              },\n          };\n          parser.setParent(body, tellCmd);\n          return tellCmd;\n      });\n\n      parser.addCommand(\"wait\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"wait\")) return;\n          var command;\n\n          // wait on event\n          if (tokens.matchToken(\"for\")) {\n              tokens.matchToken(\"a\"); // optional \"a\"\n              var events = [];\n              do {\n                  var lookahead = tokens.token(0);\n                  if (lookahead.type === 'NUMBER' || lookahead.type === 'L_PAREN') {\n                      events.push({\n                          time: parser.requireElement('expression', tokens).evaluate() // TODO: do we want to allow async here?\n                      })\n                  } else {\n                      events.push({\n                          name: parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\").evaluate(),\n                          args: parseEventArgs(tokens),\n                      });\n                  }\n              } while (tokens.matchToken(\"or\"));\n\n              if (tokens.matchToken(\"from\")) {\n                  var on = parser.requireElement(\"expression\", tokens);\n              }\n\n              // wait on event\n              command = {\n                  event: events,\n                  on: on,\n                  args: [on],\n                  op: function (context, on) {\n                      var target = on ? on : context.me;\n                      if (!(target instanceof EventTarget))\n                          throw new Error(\"Not a valid event target: \" + this.on.sourceFor());\n                      return new Promise((resolve) => {\n                          var resolved = false;\n                          for (const eventInfo of events) {\n                              var listener = (event) => {\n                                  context.result = event;\n                                  if (eventInfo.args) {\n                                      for (const arg of eventInfo.args) {\n                                          context.locals[arg.value] =\n                                              event[arg.value] || (event.detail ? event.detail[arg.value] : null);\n                                      }\n                                  }\n                                  if (!resolved) {\n                                      resolved = true;\n                                      resolve(runtime.findNext(this, context));\n                                  }\n                              };\n                              if (eventInfo.name){\n                                  target.addEventListener(eventInfo.name, listener, {once: true});\n                              } else if (eventInfo.time != null) {\n                                  setTimeout(listener, eventInfo.time, eventInfo.time)\n                              }\n                          }\n                      });\n                  },\n              };\n              return command;\n          } else {\n              var time;\n              if (tokens.matchToken(\"a\")) {\n                  tokens.requireToken(\"tick\");\n                  time = 0;\n              } else {\n                  time = parser.requireElement(\"expression\", tokens);\n              }\n\n              command = {\n                  type: \"waitCmd\",\n                  time: time,\n                  args: [time],\n                  op: function (context, timeValue) {\n                      return new Promise((resolve) => {\n                          setTimeout(() => {\n                              resolve(runtime.findNext(this, context));\n                          }, timeValue);\n                      });\n                  },\n                  execute: function (context) {\n                      return runtime.unifiedExec(this, context);\n                  },\n              };\n              return command;\n          }\n      });\n\n      // TODO  - colon path needs to eventually become part of ruby-style symbols\n      parser.addGrammarElement(\"dotOrColonPath\", function (parser, runtime, tokens) {\n          var root = tokens.matchTokenType(\"IDENTIFIER\");\n          if (root) {\n              var path = [root.value];\n\n              var separator = tokens.matchOpToken(\".\") || tokens.matchOpToken(\":\");\n              if (separator) {\n                  do {\n                      path.push(tokens.requireTokenType(\"IDENTIFIER\", \"NUMBER\").value);\n                  } while (tokens.matchOpToken(separator.value));\n              }\n\n              return {\n                  type: \"dotOrColonPath\",\n                  path: path,\n                  evaluate: function () {\n                      return path.join(separator ? separator.value : \"\");\n                  },\n              };\n          }\n      });\n\n\n      parser.addGrammarElement(\"eventName\", function (parser, runtime, tokens) {\n          var token;\n          if ((token = tokens.matchTokenType(\"STRING\"))) {\n              return {\n                  evaluate: function() {\n                      return token.value;\n                  },\n              };\n          }\n\n          return parser.parseElement(\"dotOrColonPath\", tokens);\n      });\n\n      function parseSendCmd(cmdType, parser, runtime, tokens) {\n          var eventName = parser.requireElement(\"eventName\", tokens);\n\n          var details = parser.parseElement(\"namedArgumentList\", tokens);\n          if ((cmdType === \"send\" && tokens.matchToken(\"to\")) ||\n              (cmdType === \"trigger\" && tokens.matchToken(\"on\"))) {\n              var toExpr = parser.requireElement(\"expression\", tokens);\n          } else {\n              var toExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n          }\n\n          var sendCmd = {\n              eventName: eventName,\n              details: details,\n              to: toExpr,\n              args: [toExpr, eventName, details],\n              op: function (context, to, eventName, details) {\n                  runtime.nullCheck(to, toExpr);\n                  runtime.forEach(to, function (target) {\n                      runtime.triggerEvent(target, eventName, details, context.me);\n                  });\n                  return runtime.findNext(sendCmd, context);\n              },\n          };\n          return sendCmd;\n      }\n\n      parser.addCommand(\"trigger\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"trigger\")) {\n              return parseSendCmd(\"trigger\", parser, runtime, tokens);\n          }\n      });\n\n      parser.addCommand(\"send\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"send\")) {\n              return parseSendCmd(\"send\", parser, runtime, tokens);\n          }\n      });\n\n      var parseReturnFunction = function (parser, runtime, tokens, returnAValue) {\n          if (returnAValue) {\n              if (parser.commandBoundary(tokens.currentToken())) {\n                  parser.raiseParseError(tokens, \"'return' commands must return a value.  If you do not wish to return a value, use 'exit' instead.\");\n              } else {\n                  var value = parser.requireElement(\"expression\", tokens);\n              }\n          }\n\n          var returnCmd = {\n              value: value,\n              args: [value],\n              op: function (context, value) {\n                  var resolve = context.meta.resolve;\n                  context.meta.returned = true;\n                  context.meta.returnValue = value;\n                  if (resolve) {\n                      if (value) {\n                          resolve(value);\n                      } else {\n                          resolve();\n                      }\n                  }\n                  return runtime.HALT;\n              },\n          };\n          return returnCmd;\n      };\n\n      parser.addCommand(\"return\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"return\")) {\n              return parseReturnFunction(parser, runtime, tokens, true);\n          }\n      });\n\n      parser.addCommand(\"exit\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"exit\")) {\n              return parseReturnFunction(parser, runtime, tokens, false);\n          }\n      });\n\n      parser.addCommand(\"halt\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"halt\")) {\n              if (tokens.matchToken(\"the\")) {\n                  tokens.requireToken(\"event\");\n                  // optional possessive\n                  if (tokens.matchOpToken(\"'\")) {\n                      tokens.requireToken(\"s\");\n                  }\n                  var keepExecuting = true;\n              }\n              if (tokens.matchToken(\"bubbling\")) {\n                  var bubbling = true;\n              } else if (tokens.matchToken(\"default\")) {\n                  var haltDefault = true;\n              }\n              var exit = parseReturnFunction(parser, runtime, tokens, false);\n\n              var haltCmd = {\n                  keepExecuting: true,\n                  bubbling: bubbling,\n                  haltDefault: haltDefault,\n                  exit: exit,\n                  op: function (ctx) {\n                      if (ctx.event) {\n                          if (bubbling) {\n                              ctx.event.stopPropagation();\n                          } else if (haltDefault) {\n                              ctx.event.preventDefault();\n                          } else {\n                              ctx.event.stopPropagation();\n                              ctx.event.preventDefault();\n                          }\n                          if (keepExecuting) {\n                              return runtime.findNext(this, ctx);\n                          } else {\n                              return exit;\n                          }\n                      }\n                  },\n              };\n              return haltCmd;\n          }\n      });\n\n      parser.addCommand(\"log\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"log\")) return;\n          var exprs = [parser.parseElement(\"expression\", tokens)];\n          while (tokens.matchOpToken(\",\")) {\n              exprs.push(parser.requireElement(\"expression\", tokens));\n          }\n          if (tokens.matchToken(\"with\")) {\n              var withExpr = parser.requireElement(\"expression\", tokens);\n          }\n          var logCmd = {\n              exprs: exprs,\n              withExpr: withExpr,\n              args: [withExpr, exprs],\n              op: function (ctx, withExpr, values) {\n                  if (withExpr) {\n                      withExpr.apply(null, values);\n                  } else {\n                      console.log.apply(null, values);\n                  }\n                  return runtime.findNext(this, ctx);\n              },\n          };\n          return logCmd;\n      });\n\n      parser.addCommand(\"throw\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"throw\")) return;\n          var expr = parser.requireElement(\"expression\", tokens);\n          var throwCmd = {\n              expr: expr,\n              args: [expr],\n              op: function (ctx, expr) {\n                  runtime.registerHyperTrace(ctx, expr);\n                  throw expr;\n              },\n          };\n          return throwCmd;\n      });\n\n      var parseCallOrGet = function (parser, runtime, tokens) {\n          var expr = parser.requireElement(\"expression\", tokens);\n          var callCmd = {\n              expr: expr,\n              args: [expr],\n              op: function (context, result) {\n                  context.result = result;\n                  return runtime.findNext(callCmd, context);\n              },\n          };\n          return callCmd;\n      };\n      parser.addCommand(\"call\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"call\")) return;\n          var call = parseCallOrGet(parser, runtime, tokens);\n          if (call.expr && call.expr.type !== \"functionCall\") {\n              parser.raiseParseError(tokens, \"Must be a function invocation\");\n          }\n          return call;\n      });\n      parser.addCommand(\"get\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"get\")) {\n              return parseCallOrGet(parser, runtime, tokens);\n          }\n      });\n\n      parser.addCommand(\"make\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"make\")) return;\n          tokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n\n          var expr = parser.requireElement(\"expression\", tokens);\n\n          var args = [];\n          if (expr.type !== \"queryRef\" && tokens.matchToken(\"from\")) {\n              do {\n                  args.push(parser.requireElement(\"expression\", tokens));\n              } while (tokens.matchOpToken(\",\"));\n          }\n\n          if (tokens.matchToken(\"called\")) {\n              var target = parser.requireElement(\"symbol\", tokens);\n          }\n\n          var command;\n          if (expr.type === \"queryRef\") {\n              command = {\n                  op: function (ctx) {\n                      var match,\n                          tagname = \"div\",\n                          id,\n                          classes = [];\n                      var re = /(?:(^|#|\\.)([^#\\. ]+))/g;\n                      while ((match = re.exec(expr.css))) {\n                          if (match[1] === \"\") tagname = match[2].trim();\n                          else if (match[1] === \"#\") id = match[2].trim();\n                          else classes.push(match[2].trim());\n                      }\n\n                      var result = document.createElement(tagname);\n                      if (id !== undefined) result.id = id;\n                      for (var i = 0; i < classes.length; i++) {\n                          var cls = classes[i];\n                          result.classList.add(cls)\n                      }\n\n                      ctx.result = result;\n                      if (target){\n                          runtime.setSymbol(target.name, ctx, target.scope, result);\n                      }\n\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n              return command;\n          } else {\n              command = {\n                  args: [expr, args],\n                  op: function (ctx, expr, args) {\n                      ctx.result = varargConstructor(expr, args);\n                      if (target){\n                          runtime.setSymbol(target.name, ctx, target.scope, ctx.result);\n                      }\n\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n              return command;\n          }\n      });\n\n      parser.addGrammarElement(\"pseudoCommand\", function (parser, runtime, tokens) {\n\n          let lookAhead = tokens.token(1);\n          if (!(lookAhead && lookAhead.op && (lookAhead.value === '.' || lookAhead.value === \"(\"))) {\n              return null;\n          }\n\n          var expr = parser.requireElement(\"primaryExpression\", tokens);\n\n          var rootRoot = expr.root;\n          var root = expr;\n          while (rootRoot.root != null) {\n              root = root.root;\n              rootRoot = rootRoot.root;\n          }\n\n          if (expr.type !== \"functionCall\") {\n              parser.raiseParseError(tokens, \"Pseudo-commands must be function calls\");\n          }\n\n          if (root.type === \"functionCall\" && root.root.root == null) {\n              if (tokens.matchAnyToken(\"the\", \"to\", \"on\", \"with\", \"into\", \"from\", \"at\")) {\n                  var realRoot = parser.requireElement(\"expression\", tokens);\n              } else if (tokens.matchToken(\"me\")) {\n                  var realRoot = parser.requireElement(\"implicitMeTarget\", tokens);\n              }\n          }\n\n          /** @type {ASTNode} */\n\n          var pseudoCommand\n          if(realRoot){\n              pseudoCommand = {\n                  type: \"pseudoCommand\",\n                  root: realRoot,\n                  argExressions: root.argExressions,\n                  args: [realRoot, root.argExressions],\n                  op: function (context, rootRoot, args) {\n                      runtime.nullCheck(rootRoot, realRoot);\n                      var func = rootRoot[root.root.name];\n                      runtime.nullCheck(func, root);\n                      if (func.hyperfunc) {\n                          args.push(context);\n                      }\n                      context.result = func.apply(rootRoot, args);\n                      return runtime.findNext(pseudoCommand, context);\n                  },\n                  execute: function (context) {\n                      return runtime.unifiedExec(this, context);\n                  },\n              }\n          } else {\n              pseudoCommand = {\n                  type: \"pseudoCommand\",\n                  expr: expr,\n                  args: [expr],\n                  op: function (context, result) {\n                      context.result = result;\n                      return runtime.findNext(pseudoCommand, context);\n                  },\n                  execute: function (context) {\n                      return runtime.unifiedExec(this, context);\n                  },\n              };\n          }\n\n          return pseudoCommand;\n      });\n\n      /**\n      * @param {Parser} parser\n      * @param {Runtime} runtime\n      * @param {Tokens} tokens\n      * @param {*} target\n      * @param {*} value\n      * @returns\n      */\n      var makeSetter = function (parser, runtime, tokens, target, value) {\n          var symbolWrite = target.type === \"symbol\";\n          var attributeWrite = target.type === \"attributeRef\";\n          var styleWrite = target.type === \"styleRef\";\n          var arrayWrite = target.type === \"arrayIndex\";\n\n          if (!(attributeWrite || styleWrite || symbolWrite) && target.root == null) {\n              parser.raiseParseError(tokens, \"Can only put directly into symbols, not references\");\n          }\n\n          var rootElt = null;\n          var prop = null;\n          if (symbolWrite) {\n              // rootElt is null\n          } else if (attributeWrite || styleWrite) {\n              rootElt = parser.requireElement(\"implicitMeTarget\", tokens);\n              var attribute = target;\n          } else if(arrayWrite) {\n              prop = target.firstIndex;\n              rootElt = target.root;\n          } else {\n              prop = target.prop ? target.prop.value : null;\n              var attribute = target.attribute;\n              rootElt = target.root;\n          }\n\n          /** @type {ASTNode} */\n          var setCmd = {\n              target: target,\n              symbolWrite: symbolWrite,\n              value: value,\n              args: [rootElt, prop, value],\n              op: function (context, root, prop, valueToSet) {\n                  if (symbolWrite) {\n                      runtime.setSymbol(target.name, context, target.scope, valueToSet);\n                  } else {\n                      runtime.nullCheck(root, rootElt);\n                      if (arrayWrite) {\n                          root[prop] = valueToSet;\n                      } else {\n                          runtime.implicitLoop(root, function (elt) {\n                              if (attribute) {\n                                  if (attribute.type === \"attributeRef\") {\n                                      if (valueToSet == null) {\n                                          elt.removeAttribute(attribute.name);\n                                      } else {\n                                          elt.setAttribute(attribute.name, valueToSet);\n                                      }\n                                  } else {\n                                      elt.style[attribute.name] = valueToSet;\n                                  }\n                              } else {\n                                  elt[prop] = valueToSet;\n                              }\n                          });\n                      }\n                  }\n                  return runtime.findNext(this, context);\n              },\n              parent: undefined\n          };\n          return setCmd;\n      };\n\n      parser.addCommand(\"default\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"default\")) return;\n          var target = parser.requireElement(\"assignableExpression\", tokens);\n          tokens.requireToken(\"to\");\n\n          var value = parser.requireElement(\"expression\", tokens);\n\n          /** @type {ASTNode} */\n          var setter = makeSetter(parser, runtime, tokens, target, value);\n          var defaultCmd = {\n              target: target,\n              value: value,\n              setter: setter,\n              args: [target],\n              op: function (context, target) {\n                  if (target) {\n                      return runtime.findNext(this, context);\n                  } else {\n                      return setter;\n                  }\n              },\n          };\n          setter.parent = defaultCmd;\n          return defaultCmd;\n      });\n\n      parser.addCommand(\"set\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"set\")) return;\n          if (tokens.currentToken().type === \"L_BRACE\") {\n              var obj = parser.requireElement(\"objectLiteral\", tokens);\n              tokens.requireToken(\"on\");\n              var target = parser.requireElement(\"expression\", tokens);\n\n              var command = {\n                  objectLiteral: obj,\n                  target: target,\n                  args: [obj, target],\n                  op: function (ctx, obj, target) {\n                      Object.assign(target, obj);\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n              return command;\n          }\n\n          try {\n              tokens.pushFollow(\"to\");\n              var target = parser.requireElement(\"assignableExpression\", tokens);\n          } finally {\n              tokens.popFollow();\n          }\n          tokens.requireToken(\"to\");\n          var value = parser.requireElement(\"expression\", tokens);\n          return makeSetter(parser, runtime, tokens, target, value);\n      });\n\n      parser.addCommand(\"if\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"if\")) return;\n          var expr = parser.requireElement(\"expression\", tokens);\n          tokens.matchToken(\"then\"); // optional 'then'\n          var trueBranch = parser.parseElement(\"commandList\", tokens);\n          if (tokens.matchToken(\"else\") || tokens.matchToken(\"otherwise\")) {\n              var falseBranch = parser.parseElement(\"commandList\", tokens);\n          }\n          if (tokens.hasMore()) {\n              tokens.requireToken(\"end\");\n          }\n\n          /** @type {ASTNode} */\n          var ifCmd = {\n              expr: expr,\n              trueBranch: trueBranch,\n              falseBranch: falseBranch,\n              args: [expr],\n              op: function (context, exprValue) {\n                  if (exprValue) {\n                      return trueBranch;\n                  } else if (falseBranch) {\n                      return falseBranch;\n                  } else {\n                      return runtime.findNext(this, context);\n                  }\n              },\n          };\n          parser.setParent(trueBranch, ifCmd);\n          parser.setParent(falseBranch, ifCmd);\n          return ifCmd;\n      });\n\n      var parseRepeatExpression = function (parser, tokens, runtime, startedWithForToken) {\n          var innerStartToken = tokens.currentToken();\n          var identifier;\n          if (tokens.matchToken(\"for\") || startedWithForToken) {\n              var identifierToken = tokens.requireTokenType(\"IDENTIFIER\");\n              identifier = identifierToken.value;\n              tokens.requireToken(\"in\");\n              var expression = parser.requireElement(\"expression\", tokens);\n          } else if (tokens.matchToken(\"in\")) {\n              identifier = \"it\";\n              var expression = parser.requireElement(\"expression\", tokens);\n          } else if (tokens.matchToken(\"while\")) {\n              var whileExpr = parser.requireElement(\"expression\", tokens);\n          } else if (tokens.matchToken(\"until\")) {\n              var isUntil = true;\n              if (tokens.matchToken(\"event\")) {\n                  var evt = parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\");\n                  if (tokens.matchToken(\"from\")) {\n                      var on = parser.requireElement(\"expression\", tokens);\n                  }\n              } else {\n                  var whileExpr = parser.requireElement(\"expression\", tokens);\n              }\n          } else {\n              if (!parser.commandBoundary(tokens.currentToken()) &&\n                  tokens.currentToken().value !== 'forever') {\n                  var times = parser.requireElement(\"expression\", tokens);\n                  tokens.requireToken(\"times\");\n              } else {\n                  tokens.matchToken(\"forever\"); // consume optional forever\n                  var forever = true;\n              }\n          }\n\n          if (tokens.matchToken(\"index\")) {\n              var identifierToken = tokens.requireTokenType(\"IDENTIFIER\");\n              var indexIdentifier = identifierToken.value;\n          }\n\n          var loop = parser.parseElement(\"commandList\", tokens);\n          if (loop && evt) {\n              // if this is an event based loop, wait a tick at the end of the loop so that\n              // events have a chance to trigger in the loop condition o_O)))\n              var last = loop;\n              while (last.next) {\n                  last = last.next;\n              }\n              var waitATick = {\n                  type: \"waitATick\",\n                  op: function () {\n                      return new Promise(function (resolve) {\n                          setTimeout(function () {\n                              resolve(runtime.findNext(waitATick));\n                          }, 0);\n                      });\n                  },\n              };\n              last.next = waitATick;\n          }\n          if (tokens.hasMore()) {\n              tokens.requireToken(\"end\");\n          }\n\n          if (identifier == null) {\n              identifier = \"_implicit_repeat_\" + innerStartToken.start;\n              var slot:string = identifier;\n          } else {\n              var slot:string = identifier + \"_\" + innerStartToken.start;\n          }\n\n          var repeatCmd = {\n              identifier: identifier,\n              indexIdentifier: indexIdentifier,\n              slot: slot,\n              expression: expression,\n              forever: forever,\n              times: times,\n              until: isUntil,\n              event: evt,\n              on: on,\n              whileExpr: whileExpr,\n              resolveNext: function () {\n                  return this;\n              },\n              loop: loop,\n              args: [whileExpr, times],\n              op: function (context, whileValue, times) {\n                  var iteratorInfo = context.meta.iterators[slot];\n                  var keepLooping = false;\n                  var loopVal = null;\n                  if (this.forever) {\n                      keepLooping = true;\n                  } else if (this.until) {\n                      if (evt) {\n                          keepLooping = context.meta.iterators[slot].eventFired === false;\n                      } else {\n                          keepLooping = whileValue !== true;\n                      }\n                  } else if (whileExpr) {\n                      keepLooping = whileValue;\n                  } else if (times) {\n                      keepLooping = iteratorInfo.index < times;\n                  } else {\n                      var nextValFromIterator = iteratorInfo.iterator.next();\n                      keepLooping = !nextValFromIterator.done;\n                      loopVal = nextValFromIterator.value;\n                  }\n\n                  if (keepLooping) {\n                      if (iteratorInfo.value) {\n                          context.result = context.locals[identifier] = loopVal;\n                      } else {\n                          context.result = iteratorInfo.index;\n                      }\n                      if (indexIdentifier) {\n                          context.locals[indexIdentifier] = iteratorInfo.index;\n                      }\n                      iteratorInfo.index++;\n                      return loop;\n                  } else {\n                      context.meta.iterators[slot] = null;\n                      return runtime.findNext(this.parent, context);\n                  }\n              },\n          };\n          parser.setParent(loop, repeatCmd);\n          var repeatInit = {\n              name: \"repeatInit\",\n              args: [expression, evt, on],\n              op: function (context, value, event, on) {\n                  var iteratorInfo = {\n                    iterator: undefined,\n                      index: 0,\n                      value: value,\n                      eventFired: false,\n                  };\n                  context.meta.iterators[slot] = iteratorInfo;\n                  if (value && value[Symbol.iterator]) {\n                      iteratorInfo.iterator = value[Symbol.iterator]();\n                  }\n                  if (evt) {\n                      var target = on || context.me;\n                      target.addEventListener(\n                          event,\n                          function (e) {\n                              context.meta.iterators[slot].eventFired = true;\n                          },\n                          { once: true }\n                      );\n                  }\n                  return repeatCmd; // continue to loop\n              },\n              execute: function (context) {\n                  return runtime.unifiedExec(this, context);\n              },\n          };\n          parser.setParent(repeatCmd, repeatInit);\n          return repeatInit;\n      };\n\n      parser.addCommand(\"repeat\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"repeat\")) {\n              return parseRepeatExpression(parser, tokens, runtime, false);\n          }\n      });\n\n      parser.addCommand(\"for\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"for\")) {\n              return parseRepeatExpression(parser, tokens, runtime, true);\n          }\n      });\n\n    parser.addCommand(\"continue\", function (parser, runtime, tokens) {\n\n      if (!tokens.matchToken(\"continue\")) return;\n\n      var command = {\n        op: function (context) {\n\n          // scan for the closest repeat statement\n          for (var parent = this.parent ; true ; parent = parent.parent) {\n\n            if (parent == undefined) {\n              parser.raiseParseError(tokens, \"Command `continue` cannot be used outside of a `repeat` loop.\")\n            }\n            if (parent.loop != undefined) {\n              return parent.resolveNext(context)\n            }\n          }\n        }\n      };\n      return command;\n    });\n\n    parser.addCommand(\"break\", function (parser, runtime, tokens) {\n\n      if (!tokens.matchToken(\"break\")) return;\n\n      var command = {\n        op: function (context) {\n\n          // scan for the closest repeat statement\n          for (var parent = this.parent ; true ; parent = parent.parent) {\n\n            if (parent == undefined) {\n              parser.raiseParseError(tokens, \"Command `continue` cannot be used outside of a `repeat` loop.\")\n            }\n            if (parent.loop != undefined) {\n                return runtime.findNext(parent.parent, context);\n            }\n          }\n        }\n      };\n      return command;\n    });\n\n      parser.addGrammarElement(\"stringLike\", function (parser, runtime, tokens) {\n          return parser.parseAnyOf([\"string\", \"nakedString\"], tokens);\n      });\n\n      parser.addCommand(\"append\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"append\")) return;\n          var targetExpr = null;\n\n          var value = parser.requireElement(\"expression\", tokens);\n\n          /** @type {ASTNode} */\n          var implicitResultSymbol = {\n              type: \"symbol\",\n              evaluate: function (context) {\n                  return runtime.resolveSymbol(\"result\", context);\n              },\n          };\n\n          if (tokens.matchToken(\"to\")) {\n              targetExpr = parser.requireElement(\"expression\", tokens);\n          } else {\n              targetExpr = implicitResultSymbol;\n          }\n\n          var setter = null;\n          if (targetExpr.type === \"symbol\" || targetExpr.type === \"attributeRef\" || targetExpr.root != null) {\n              setter = makeSetter(parser, runtime, tokens, targetExpr, implicitResultSymbol);\n          }\n\n          var command = {\n              value: value,\n              target: targetExpr,\n              args: [targetExpr, value],\n              op: function (context, target, value) {\n                  if (Array.isArray(target)) {\n                      target.push(value);\n                      return runtime.findNext(this, context);\n                  } else if (target instanceof Element) {\n                      target.innerHTML += value;\n                      return runtime.findNext(this, context);\n                  } else if(setter) {\n                      context.result = (target || \"\") + value;\n                      return setter;\n                  } else {\n                      throw Error(\"Unable to append a value!\")\n                  }\n              },\n              execute: function (context) {\n                  return runtime.unifiedExec(this, context/*, value, target*/);\n              },\n          };\n\n          if (setter != null) {\n              setter.parent = command;\n          }\n\n          return command;\n      });\n\n      function parsePickRange(parser, runtime, tokens) {\n          tokens.matchToken(\"at\") || tokens.matchToken(\"from\");\n          const rv = { from:undefined, to:undefined, includeStart:true, includeEnd:false, toEnd:undefined }\n\n          rv.from = tokens.matchToken(\"start\") ? 0 : parser.requireElement(\"expression\", tokens)\n\n          if (tokens.matchToken(\"to\") || tokens.matchOpToken(\"..\")) {\n            if (tokens.matchToken(\"end\")) {\n              rv.toEnd = true;\n            } else {\n              rv.to = parser.requireElement(\"expression\", tokens);\n            }\n          }\n\n          if (tokens.matchToken(\"inclusive\")) rv.includeEnd = true;\n          else if (tokens.matchToken(\"exclusive\")) rv.includeStart = false;\n\n          return rv;\n      }\n\n      class RegExpIterator {\n        public re:RegExp\n        public flags:string\n        public str:string\n\n        constructor(re, str) {\n          this.re = re;\n          this.str = str;\n        }\n\n        next() {\n          const match = this.re.exec(this.str);\n          if (match === null) return { done: true };\n          else return { value: match };\n        }\n      }\n\n      class RegExpIterable {\n        public re:RegExp\n        public flags:string\n        public str:string\n\n        constructor(re, flags, str) {\n          this.re = re;\n          this.flags = flags;\n          this.str = str;\n        }\n\n        [Symbol.iterator]() {\n          return new RegExpIterator(new RegExp(this.re, this.flags), this.str);\n        }\n      }\n\n      parser.addCommand(\"pick\", (parser, runtime, tokens) => {\n        if (!tokens.matchToken(\"pick\")) return;\n\n        tokens.matchToken(\"the\");\n\n        if (tokens.matchToken(\"item\") || tokens.matchToken(\"items\")\n         || tokens.matchToken(\"character\") || tokens.matchToken(\"characters\")) {\n          const range = parsePickRange(parser, runtime, tokens);\n\n          tokens.requireToken(\"from\");\n          const root = parser.requireElement(\"expression\", tokens);\n\n          return {\n            args: [root, range.from, range.to],\n            op(ctx, root, from, to) {\n              if (range.toEnd) to = root.length;\n              if (!range.includeStart) from++;\n              if (range.includeEnd) to++;\n              if (to == null || to == undefined) to = from + 1;\n              ctx.result = root.slice(from, to);\n              return runtime.findNext(this, ctx);\n            }\n          }\n        }\n\n        if (tokens.matchToken(\"match\")) {\n          tokens.matchToken(\"of\");\n          const re = parser.parseElement(\"expression\", tokens);\n          let flags = \"\"\n          if (tokens.matchOpToken(\"|\")) {\n            flags = tokens.requireToken(\"identifier\").value;\n          }\n\n          tokens.requireToken(\"from\");\n          const root = parser.parseElement(\"expression\", tokens);\n\n          return {\n            args: [root, re],\n            op(ctx, root, re) {\n              ctx.result = new RegExp(re, flags).exec(root);\n              return runtime.findNext(this, ctx);\n            }\n          }\n        }\n\n        if (tokens.matchToken(\"matches\")) {\n          tokens.matchToken(\"of\");\n          const re = parser.parseElement(\"expression\", tokens);\n          let flags = \"gu\"\n          if (tokens.matchOpToken(\"|\")) {\n            flags = 'g' + tokens.requireToken(\"identifier\").value.replace('g', '');\n          }\n          console.log('flags', flags)\n\n          tokens.requireToken(\"from\");\n          const root = parser.parseElement(\"expression\", tokens);\n\n          return {\n            args: [root, re],\n            op(ctx, root, re) {\n              ctx.result = new RegExpIterable(re, flags, root);\n              return runtime.findNext(this, ctx);\n            }\n          }\n        }\n      });\n  \n      parser.addCommand(\"increment\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"increment\")) return;\n          var amountExpr;\n  \n          // This is optional.  Defaults to \"result\"\n          var target = parser.parseElement(\"assignableExpression\", tokens);\n  \n          // This is optional. Defaults to 1.\n          if (tokens.matchToken(\"by\")) {\n              amountExpr = parser.requireElement(\"expression\", tokens);\n          }\n  \n          var implicitIncrementOp = {\n              type: \"implicitIncrementOp\",\n              target: target,\n              args: [target, amountExpr],\n              op: function (context, targetValue, amount) {\n                  targetValue = targetValue ? parseFloat(targetValue) : 0;\n                  amount = amountExpr ? parseFloat(amount) : 1;\n                  var newValue = targetValue + amount;\n                  context.result = newValue;\n                  return newValue;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              }\n          };\n\n          return makeSetter(parser, runtime, tokens, target, implicitIncrementOp);\n      });\n  \n      parser.addCommand(\"decrement\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"decrement\")) return;\n          var amountExpr;\n  \n          // This is optional.  Defaults to \"result\"\n          var target = parser.parseElement(\"assignableExpression\", tokens);\n  \n          // This is optional. Defaults to 1.\n          if (tokens.matchToken(\"by\")) {\n              amountExpr = parser.requireElement(\"expression\", tokens);\n          }\n  \n          var implicitDecrementOp = {\n              type: \"implicitDecrementOp\",\n              target: target,\n              args: [target, amountExpr],\n              op: function (context, targetValue, amount) {\n                  targetValue = targetValue ? parseFloat(targetValue) : 0;\n                  amount = amountExpr ? parseFloat(amount) : 1;\n                  var newValue = targetValue - amount;\n                  context.result = newValue;\n                  return newValue;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              }\n          };\n\n          return makeSetter(parser, runtime, tokens, target, implicitDecrementOp);\n      });\n\n      function parseConversionInfo(tokens, parser) {\n          var type = \"text\";\n          var conversion;\n          tokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n          if (tokens.matchToken(\"json\") || tokens.matchToken(\"Object\")) {\n              type = \"json\";\n          } else if (tokens.matchToken(\"response\")) {\n              type = \"response\";\n          } else if (tokens.matchToken(\"html\")) {\n              type = \"html\";\n          } else if (tokens.matchToken(\"text\")) {\n              // default, ignore\n          } else {\n              conversion = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n          }\n          return {type, conversion};\n      }\n\n      parser.addCommand(\"fetch\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"fetch\")) return;\n          var url = parser.requireElement(\"stringLike\", tokens);\n\n          if (tokens.matchToken(\"as\")) {\n              var conversionInfo = parseConversionInfo(tokens, parser);\n          }\n\n          if (tokens.matchToken(\"with\") && tokens.currentToken().value !== \"{\") {\n              var args = parser.parseElement(\"nakedNamedArgumentList\", tokens);\n          } else {\n              var args = parser.parseElement(\"objectLiteral\", tokens);\n          }\n\n          if (conversionInfo == null && tokens.matchToken(\"as\")) {\n              conversionInfo = parseConversionInfo(tokens, parser);\n          }\n\n          var type = conversionInfo ? conversionInfo.type : \"text\";\n          var conversion = conversionInfo ? conversionInfo.conversion : null\n\n          /** @type {ASTNode} */\n          var fetchCmd = {\n              url: url,\n              argExpressions: args,\n              args: [url, args],\n              op: function (context, url, args) {\n                  var detail = args || {};\n                  detail[\"sender\"] = context.me;\n                  detail[\"headers\"] = detail[\"headers\"] || {}\n                  var abortController = new AbortController();\n                  let abortListener = context.me.addEventListener('fetch:abort', function(){\n                      abortController.abort();\n                  }, {once: true});\n                  detail['signal'] = abortController.signal;\n                  runtime.triggerEvent(context.me, \"hyperscript:beforeFetch\", detail);\n                  runtime.triggerEvent(context.me, \"fetch:beforeRequest\", detail);\n                  args = detail;\n                  var finished = false;\n                  if (args.timeout) {\n                      setTimeout(function () {\n                          if (!finished) {\n                              abortController.abort();\n                          }\n                      }, args.timeout);\n                  }\n                  return fetch(url, args)\n                      .then(function (resp) {\n                          let resultDetails = {response:resp};\n                          runtime.triggerEvent(context.me, \"fetch:afterResponse\", resultDetails);\n                          resp = resultDetails.response;\n\n                          if (type === \"response\") {\n                              context.result = resp;\n                              runtime.triggerEvent(context.me, \"fetch:afterRequest\", {result:resp});\n                              finished = true;\n                              return runtime.findNext(fetchCmd, context);\n                          }\n                          if (type === \"json\") {\n                              return resp.json().then(function (result) {\n                                  context.result = result;\n                                  runtime.triggerEvent(context.me, \"fetch:afterRequest\", {result});\n                                  finished = true;\n                                  return runtime.findNext(fetchCmd, context);\n                              });\n                          }\n                          return resp.text().then(function (result) {\n                              if (conversion) result = runtime.convertValue(result, conversion);\n\n                              if (type === \"html\") result = runtime.convertValue(result, \"Fragment\");\n\n                              context.result = result;\n                              runtime.triggerEvent(context.me, \"fetch:afterRequest\", {result});\n                              finished = true;\n                              return runtime.findNext(fetchCmd, context);\n                          });\n                      })\n                      .catch(function (reason) {\n                          runtime.triggerEvent(context.me, \"fetch:error\", {\n                              reason: reason,\n                          });\n                          throw reason;\n                      }).finally(function(){\n                          context.me.removeEventListener('fetch:abort', abortListener);\n                      });\n              },\n          };\n          return fetchCmd;\n      });\n  }\n\n  function hyperscriptWebGrammar(parser) {\n      parser.addCommand(\"settle\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"settle\")) {\n              if (!parser.commandBoundary(tokens.currentToken())) {\n                  var onExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  var onExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              }\n\n              var settleCommand = {\n                  type: \"settleCmd\",\n                  args: [onExpr],\n                  op: function (context, on) {\n                      runtime.nullCheck(on, onExpr);\n                      var resolve = null;\n                      var resolved = false;\n                      var transitionStarted = false;\n\n                      var promise = new Promise(function (r) {\n                          resolve = r;\n                      });\n\n                      // listen for a transition begin\n                      on.addEventListener(\n                          \"transitionstart\",\n                          function () {\n                              transitionStarted = true;\n                          },\n                          { once: true }\n                      );\n\n                      // if no transition begins in 500ms, cancel\n                      setTimeout(function () {\n                          if (!transitionStarted && !resolved) {\n                              resolve(runtime.findNext(settleCommand, context));\n                          }\n                      }, 500);\n\n                      // continue on a transition emd\n                      on.addEventListener(\n                          \"transitionend\",\n                          function () {\n                              if (!resolved) {\n                                  resolve(runtime.findNext(settleCommand, context));\n                              }\n                          },\n                          { once: true }\n                      );\n                      return promise;\n                  },\n                  execute: function (context) {\n                      return runtime.unifiedExec(this, context);\n                  },\n              };\n              return settleCommand;\n          }\n      });\n\n      parser.addCommand(\"add\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"add\")) {\n              var classRef = parser.parseElement(\"classRef\", tokens);\n              var attributeRef = null;\n              var cssDeclaration = null;\n              if (classRef == null) {\n                  attributeRef = parser.parseElement(\"attributeRef\", tokens);\n                  if (attributeRef == null) {\n                      cssDeclaration = parser.parseElement(\"styleLiteral\", tokens);\n                      if (cssDeclaration == null) {\n                          parser.raiseParseError(tokens, \"Expected either a class reference or attribute expression\");\n                      }\n                  }\n              } else {\n                  var classRefs = [classRef];\n                  while ((classRef = parser.parseElement(\"classRef\", tokens))) {\n                      classRefs.push(classRef);\n                  }\n              }\n\n              if (tokens.matchToken(\"to\")) {\n                  var toExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  var toExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              }\n\n              if (tokens.matchToken(\"when\")) {\n                  if (cssDeclaration) {\n                      parser.raiseParseError(tokens, \"Only class and properties are supported with a when clause\")\n                  }\n                  var when = parser.requireElement(\"expression\", tokens);\n              }\n\n              if (classRefs) {\n                  return {\n                      classRefs: classRefs,\n                      to: toExpr,\n                      args: [toExpr, classRefs],\n                      op: function (context, to, classRefs) {\n                          runtime.nullCheck(to, toExpr);\n                          runtime.forEach(classRefs, function (classRef) {\n                              runtime.implicitLoop(to, function (target) {\n                                  if (when) {\n                                      context.result = target;\n                                      let whenResult = runtime.evaluateNoPromise(when, context);\n                                      if (whenResult) {\n                                          if (target instanceof Element) target.classList.add(classRef.className);\n                                      } else {\n                                          if (target instanceof Element) target.classList.remove(classRef.className);\n                                      }\n                                      context.result = null;\n                                  } else {\n                                      if (target instanceof Element) target.classList.add(classRef.className);\n                                  }\n                              });\n                          });\n                          return runtime.findNext(this, context);\n                      },\n                  };\n              } else if (attributeRef) {\n                  return {\n                      type: \"addCmd\",\n                      attributeRef: attributeRef,\n                      to: toExpr,\n                      args: [toExpr],\n                      op: function (context, to, attrRef) {\n                          runtime.nullCheck(to, toExpr);\n                          runtime.implicitLoop(to, function (target) {\n                              if (when) {\n                                  context.result = target;\n                                  let whenResult = runtime.evaluateNoPromise(when, context);\n                                  if (whenResult) {\n                                      target.setAttribute(attributeRef.name, attributeRef.value);\n                                  } else {\n                                      target.removeAttribute(attributeRef.name);\n                                  }\n                                  context.result = null;\n                              } else {\n                                  target.setAttribute(attributeRef.name, attributeRef.value);\n                              }\n                          });\n                          return runtime.findNext(this, context);\n                      },\n                      execute: function (ctx) {\n                          return runtime.unifiedExec(this, ctx);\n                      },\n                  };\n              } else {\n                  return {\n                      type: \"addCmd\",\n                      cssDeclaration: cssDeclaration,\n                      to: toExpr,\n                      args: [toExpr, cssDeclaration],\n                      op: function (context, to, css) {\n                          runtime.nullCheck(to, toExpr);\n                          runtime.implicitLoop(to, function (target) {\n                              target.style.cssText += css;\n                          });\n                          return runtime.findNext(this, context);\n                      },\n                      execute: function (ctx) {\n                          return runtime.unifiedExec(this, ctx);\n                      },\n                  };\n              }\n          }\n      });\n\n      parser.addGrammarElement(\"styleLiteral\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"{\")) return;\n\n          var stringParts = [\"\"]\n          var exprs = []\n\n          while (tokens.hasMore()) {\n              if (tokens.matchOpToken(\"\\\\\")) {\n                  tokens.consumeToken();\n              } else if (tokens.matchOpToken(\"}\")) {\n                  break;\n              } else if (tokens.matchToken(\"$\")) {\n                  var opencurly = tokens.matchOpToken(\"{\");\n                  var expr = parser.parseElement(\"expression\", tokens);\n                  if (opencurly) tokens.requireOpToken(\"}\");\n\n                  exprs.push(expr)\n                  stringParts.push(\"\")\n              } else {\n                  var tok = tokens.consumeToken();\n                  stringParts[stringParts.length-1] += tokens.source.substring(tok.start, tok.end);\n              }\n\n              stringParts[stringParts.length-1] += tokens.lastWhitespace();\n          }\n\n          return {\n              type: \"styleLiteral\",\n              args: [exprs],\n              op: function (ctx, exprs) {\n                  var rv = \"\";\n\n                  stringParts.forEach(function (part, idx) {\n                      rv += part;\n                      if (idx in exprs) rv += exprs[idx];\n                  });\n\n                  return rv;\n              },\n              evaluate: function(ctx) {\n                  return runtime.unifiedEval(this, ctx);\n              }\n          }\n      })\n\n      parser.addCommand(\"remove\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"remove\")) {\n              var classRef = parser.parseElement(\"classRef\", tokens);\n              var attributeRef = null;\n              var elementExpr = null;\n              if (classRef == null) {\n                  attributeRef = parser.parseElement(\"attributeRef\", tokens);\n                  if (attributeRef == null) {\n                      elementExpr = parser.parseElement(\"expression\", tokens);\n                      if (elementExpr == null) {\n                          parser.raiseParseError(\n                              tokens,\n                              \"Expected either a class reference, attribute expression or value expression\"\n                          );\n                      }\n                  }\n              } else {\n                  var classRefs = [classRef];\n                  while ((classRef = parser.parseElement(\"classRef\", tokens))) {\n                      classRefs.push(classRef);\n                  }\n              }\n\n              if (tokens.matchToken(\"from\")) {\n                  var fromExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  if (elementExpr == null) {\n                      var fromExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n                  }\n              }\n\n              if (elementExpr) {\n                  return {\n                      elementExpr: elementExpr,\n                      from: fromExpr,\n                      args: [elementExpr, fromExpr],\n                      op: function (context, element, from) {\n                          runtime.nullCheck(element, elementExpr);\n                          runtime.implicitLoop(element, function (target) {\n                              if (target.parentElement && (from == null || from.contains(target))) {\n                                  target.parentElement.removeChild(target);\n                              }\n                          });\n                          return runtime.findNext(this, context);\n                      },\n                  };\n              } else {\n                  return {\n                      classRefs: classRefs,\n                      attributeRef: attributeRef,\n                      elementExpr: elementExpr,\n                      from: fromExpr,\n                      args: [classRefs, fromExpr],\n                      op: function (context, classRefs, from) {\n                          runtime.nullCheck(from, fromExpr);\n                          if (classRefs) {\n                              runtime.forEach(classRefs, function (classRef) {\n                                  runtime.implicitLoop(from, function (target) {\n                                      target.classList.remove(classRef.className);\n                                  });\n                              });\n                          } else {\n                              runtime.implicitLoop(from, function (target) {\n                                  target.removeAttribute(attributeRef.name);\n                              });\n                          }\n                          return runtime.findNext(this, context);\n                      },\n                  };\n              }\n          }\n      });\n\n      parser.addCommand(\"toggle\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"toggle\")) {\n              tokens.matchAnyToken(\"the\", \"my\");\n              if (tokens.currentToken().type === \"STYLE_REF\") {\n                  let styleRef = tokens.consumeToken();\n                  var name = styleRef.value.substr(1);\n                  var visibility = true;\n                  var hideShowStrategy = resolveStrategy(parser, tokens, name);\n                  if (tokens.matchToken(\"of\")) {\n                      tokens.pushFollow(\"with\");\n                      try {\n                          var onExpr = parser.requireElement(\"expression\", tokens);\n                      } finally {\n                          tokens.popFollow();\n                      }\n                  } else {\n                      var onExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n                  }\n              } else if (tokens.matchToken(\"between\")) {\n                  var between = true;\n                  var classRef = parser.parseElement(\"classRef\", tokens);\n                  tokens.requireToken(\"and\");\n                  var classRef2 = parser.requireElement(\"classRef\", tokens);\n              } else {\n                  var classRef = parser.parseElement(\"classRef\", tokens);\n                  var attributeRef = null;\n                  if (classRef == null) {\n                      attributeRef = parser.parseElement(\"attributeRef\", tokens);\n                      if (attributeRef == null) {\n                          parser.raiseParseError(tokens, \"Expected either a class reference or attribute expression\");\n                      }\n                  } else {\n                      var classRefs = [classRef];\n                      while ((classRef = parser.parseElement(\"classRef\", tokens))) {\n                          classRefs.push(classRef);\n                      }\n                  }\n              }\n\n              if (visibility !== true) {\n                  if (tokens.matchToken(\"on\")) {\n                      var onExpr = parser.requireElement(\"expression\", tokens);\n                  } else {\n                      var onExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n                  }\n              }\n\n              if (tokens.matchToken(\"for\")) {\n                  var time = parser.requireElement(\"expression\", tokens);\n              } else if (tokens.matchToken(\"until\")) {\n                  var evt = parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\");\n                  if (tokens.matchToken(\"from\")) {\n                      var from = parser.requireElement(\"expression\", tokens);\n                  }\n              }\n\n              var toggleCmd = {\n                  classRef: classRef,\n                  classRef2: classRef2,\n                  classRefs: classRefs,\n                  attributeRef: attributeRef,\n                  on: onExpr,\n                  time: time,\n                  evt: evt,\n                  from: from,\n                  toggle: function (on, classRef, classRef2, classRefs) {\n                      runtime.nullCheck(on, onExpr);\n                      if (visibility) {\n                          runtime.implicitLoop(on, function (target) {\n                              hideShowStrategy(\"toggle\", target);\n                          });\n                      } else if (between) {\n                          runtime.implicitLoop(on, function (target) {\n                              if (target.classList.contains(classRef.className)) {\n                                  target.classList.remove(classRef.className);\n                                  target.classList.add(classRef2.className);\n                              } else {\n                                  target.classList.add(classRef.className);\n                                  target.classList.remove(classRef2.className);\n                              }\n                          });\n                      } else if (classRefs) {\n                          runtime.forEach(classRefs, function (classRef) {\n                              runtime.implicitLoop(on, function (target) {\n                                  target.classList.toggle(classRef.className);\n                              });\n                          });\n                      } else {\n                          runtime.forEach(on, function (target) {\n                              if (target.hasAttribute(attributeRef.name)) {\n                                  target.removeAttribute(attributeRef.name);\n                              } else {\n                                  target.setAttribute(attributeRef.name, attributeRef.value);\n                              }\n                          });\n                      }\n                  },\n                  args: [onExpr, time, evt, from, classRef, classRef2, classRefs],\n                  op: function (context, on, time, evt, from, classRef, classRef2, classRefs) {\n                      if (time) {\n                          return new Promise(function (resolve) {\n                              toggleCmd.toggle(on, classRef, classRef2, classRefs);\n                              setTimeout(function () {\n                                  toggleCmd.toggle(on, classRef, classRef2, classRefs);\n                                  resolve(runtime.findNext(toggleCmd, context));\n                              }, time);\n                          });\n                      } else if (evt) {\n                          return new Promise(function (resolve) {\n                              var target = from || context.me;\n                              target.addEventListener(\n                                  evt,\n                                  function () {\n                                      toggleCmd.toggle(on, classRef, classRef2, classRefs);\n                                      resolve(runtime.findNext(toggleCmd, context));\n                                  },\n                                  { once: true }\n                              );\n                              toggleCmd.toggle(on, classRef, classRef2, classRefs);\n                          });\n                      } else {\n                          this.toggle(on, classRef, classRef2, classRefs);\n                          return runtime.findNext(toggleCmd, context);\n                      }\n                  },\n              };\n              return toggleCmd;\n          }\n      });\n\n      var HIDE_SHOW_STRATEGIES = {\n          display: function (op, element, arg) {\n              if (arg) {\n                  element.style.display = arg;\n              } else if (op === \"toggle\") {\n                  if (getComputedStyle(element).display === \"none\") {\n                      HIDE_SHOW_STRATEGIES.display(\"show\", element, arg);\n                  } else {\n                      HIDE_SHOW_STRATEGIES.display(\"hide\", element, arg);\n                  }\n              } else if (op === \"hide\") {\n                  const internalData = parser.runtime.getInternalData(element);\n                  if (internalData.originalDisplay == null) {\n                      internalData.originalDisplay = element.style.display;\n                  }\n                  element.style.display = \"none\";\n              } else {\n                  const internalData = parser.runtime.getInternalData(element);\n                  if (internalData.originalDisplay && internalData.originalDisplay !== 'none') {\n                      element.style.display = internalData.originalDisplay;\n                  } else {\n                      element.style.removeProperty('display');\n                  }\n              }\n          },\n          visibility: function (op, element, arg) {\n              if (arg) {\n                  element.style.visibility = arg;\n              } else if (op === \"toggle\") {\n                  if (getComputedStyle(element).visibility === \"hidden\") {\n                      HIDE_SHOW_STRATEGIES.visibility(\"show\", element, arg);\n                  } else {\n                      HIDE_SHOW_STRATEGIES.visibility(\"hide\", element, arg);\n                  }\n              } else if (op === \"hide\") {\n                  element.style.visibility = \"hidden\";\n              } else {\n                  element.style.visibility = \"visible\";\n              }\n          },\n          opacity: function (op, element, arg) {\n              if (arg) {\n                  element.style.opacity = arg;\n              } else if (op === \"toggle\") {\n                  if (getComputedStyle(element).opacity === \"0\") {\n                      HIDE_SHOW_STRATEGIES.opacity(\"show\", element, arg);\n                  } else {\n                      HIDE_SHOW_STRATEGIES.opacity(\"hide\", element, arg);\n                  }\n              } else if (op === \"hide\") {\n                  element.style.opacity = \"0\";\n              } else {\n                  element.style.opacity = \"1\";\n              }\n          },\n      };\n\n      var parseShowHideTarget = function (parser, runtime, tokens) {\n          var target;\n          var currentTokenValue = tokens.currentToken();\n          if (currentTokenValue.value === \"when\" || currentTokenValue.value === \"with\" || parser.commandBoundary(currentTokenValue)) {\n              target = parser.parseElement(\"implicitMeTarget\", tokens);\n          } else {\n              target = parser.parseElement(\"expression\", tokens);\n          }\n          return target;\n      };\n\n      var resolveStrategy = function (parser, tokens, name) {\n          var configDefault = config.defaultHideShowStrategy;\n          var strategies = HIDE_SHOW_STRATEGIES;\n          if (config.hideShowStrategies) {\n              strategies = Object.assign(strategies, config.hideShowStrategies); // merge in user provided strategies\n          }\n          name = name || configDefault || \"display\";\n          var value = strategies[name];\n          if (value == null) {\n              parser.raiseParseError(tokens, \"Unknown show/hide strategy : \" + name);\n          }\n          return value;\n      };\n\n      parser.addCommand(\"hide\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"hide\")) {\n              var targetExpr = parseShowHideTarget(parser, runtime, tokens);\n\n              var name = null;\n              if (tokens.matchToken(\"with\")) {\n                  name = tokens.requireTokenType(\"IDENTIFIER\", \"STYLE_REF\").value;\n                  if (name.indexOf(\"*\") === 0) {\n                      name = name.substr(1);\n                  }\n              }\n              var hideShowStrategy = resolveStrategy(parser, tokens, name);\n\n              return {\n                  target: targetExpr,\n                  args: [targetExpr],\n                  op: function (ctx, target) {\n                      runtime.nullCheck(target, targetExpr);\n                      runtime.implicitLoop(target, function (elt) {\n                          hideShowStrategy(\"hide\", elt);\n                      });\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n          }\n      });\n\n      parser.addCommand(\"show\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"show\")) {\n              var targetExpr = parseShowHideTarget(parser, runtime, tokens);\n\n              var name = null;\n              if (tokens.matchToken(\"with\")) {\n                  name = tokens.requireTokenType(\"IDENTIFIER\", \"STYLE_REF\").value;\n                  if (name.indexOf(\"*\") === 0) {\n                      name = name.substr(1);\n                  }\n              }\n              var arg = null;\n              if (tokens.matchOpToken(\":\")) {\n                  var tokenArr = tokens.consumeUntilWhitespace();\n                  tokens.matchTokenType(\"WHITESPACE\");\n                  arg = tokenArr\n                      .map(function (t) {\n                          return t.value;\n                      })\n                      .join(\"\");\n              }\n\n              if (tokens.matchToken(\"when\")) {\n                  var when = parser.requireElement(\"expression\", tokens);\n              }\n\n              var hideShowStrategy = resolveStrategy(parser, tokens, name);\n\n              return {\n                  target: targetExpr,\n                  when: when,\n                  args: [targetExpr],\n                  op: function (ctx, target) {\n                      runtime.nullCheck(target, targetExpr);\n                      runtime.implicitLoop(target, function (elt) {\n                          if (when) {\n                              ctx.result = elt;\n                              let whenResult = runtime.evaluateNoPromise(when, ctx);\n                              if (whenResult) {\n                                  hideShowStrategy(\"show\", elt, arg);\n                              } else {\n                                  hideShowStrategy(\"hide\", elt);\n                              }\n                              ctx.result = null;\n                          } else {\n                              hideShowStrategy(\"show\", elt, arg);\n                          }\n                      });\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n          }\n      });\n\n      parser.addCommand(\"take\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"take\")) {\n              var classRef = parser.requireElement(\"classRef\", tokens);\n\n              if (tokens.matchToken(\"from\")) {\n                  var fromExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  var fromExpr = classRef;\n              }\n\n              if (tokens.matchToken(\"for\")) {\n                  var forExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  var forExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              }\n\n              var takeCmd = {\n                  classRef: classRef,\n                  from: fromExpr,\n                  forElt: forExpr,\n                  args: [classRef, fromExpr, forExpr],\n                  op: function (context, eltColl, from, forElt) {\n                      runtime.nullCheck(from, fromExpr);\n                      runtime.nullCheck(forElt, forExpr);\n                      var clazz = eltColl.className;\n                      runtime.implicitLoop(from, function (target) {\n                          target.classList.remove(clazz);\n                      });\n                      runtime.implicitLoop(forElt, function (target) {\n                          target.classList.add(clazz);\n                      });\n                      return runtime.findNext(this, context);\n                  },\n              };\n              return takeCmd;\n          }\n      });\n\n      function putInto(runtime, context, prop, valueToPut) {\n          if (prop != null) {\n              var value = runtime.resolveSymbol(prop, context);\n          } else {\n              var value = context;\n          }\n          if (value instanceof Element || value instanceof HTMLDocument) {\n              while (value.firstChild) value.removeChild(value.firstChild);\n              value.append(parser.runtime.convertValue(valueToPut, \"Fragment\"));\n              runtime.processNode(value);\n          } else {\n              if (prop != null) {\n                  runtime.setSymbol(prop, context, null, valueToPut);\n              } else {\n                  throw \"Don't know how to put a value into \" + typeof context;\n              }\n          }\n      }\n\n      parser.addCommand(\"put\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"put\")) {\n              var value = parser.requireElement(\"expression\", tokens);\n\n              var operationToken = tokens.matchAnyToken(\"into\", \"before\", \"after\");\n\n              if (operationToken == null && tokens.matchToken(\"at\")) {\n                  tokens.matchToken(\"the\"); // optional \"the\"\n                  operationToken = tokens.matchAnyToken(\"start\", \"end\");\n                  tokens.requireToken(\"of\");\n              }\n\n              if (operationToken == null) {\n                  parser.raiseParseError(tokens, \"Expected one of 'into', 'before', 'at start of', 'at end of', 'after'\");\n              }\n              var target = parser.requireElement(\"expression\", tokens);\n\n              var operation = operationToken.value;\n\n              var arrayIndex = false;\n              var symbolWrite = false;\n              var rootExpr = null;\n              var prop = null;\n\n              if (target.type === \"arrayIndex\" && operation === \"into\") {\n                  arrayIndex = true;\n                  prop = target.prop;\n                  rootExpr = target.root;\n              }  else if (target.prop && target.root && operation === \"into\") {\n                  prop = target.prop.value;\n                  rootExpr = target.root;\n              } else if (target.type === \"symbol\" && operation === \"into\") {\n                  symbolWrite = true;\n                  prop = target.name;\n              } else if (target.type === \"attributeRef\" && operation === \"into\") {\n                  var attributeWrite = true;\n                  prop = target.name;\n                  rootExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              } else if (target.type === \"styleRef\" && operation === \"into\") {\n                  var styleWrite = true;\n                  prop = target.name;\n                  rootExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              } else if (target.attribute && operation === \"into\") {\n                  var attributeWrite = target.attribute.type === \"attributeRef\";\n                  var styleWrite = target.attribute.type === \"styleRef\";\n                  prop = target.attribute.name;\n                  rootExpr = target.root;\n              } else {\n                  rootExpr = target;\n              }\n\n              var putCmd = {\n                  target: target,\n                  operation: operation,\n                  symbolWrite: symbolWrite,\n                  value: value,\n                  args: [rootExpr, prop, value],\n                  op: function (context, root, prop, valueToPut) {\n                      if (symbolWrite) {\n                          putInto(runtime, context, prop, valueToPut);\n                      } else {\n                          runtime.nullCheck(root, rootExpr);\n                          if (operation === \"into\") {\n                              if (attributeWrite) {\n                                  runtime.implicitLoop(root, function (elt) {\n                                      elt.setAttribute(prop, valueToPut);\n                                  });\n                              } else if (styleWrite) {\n                                  runtime.implicitLoop(root, function (elt) {\n                                      elt.style[prop] = valueToPut;\n                                  });\n                              } else if (arrayIndex) {\n                                  root[prop] = valueToPut;\n                              } else {\n                                  runtime.implicitLoop(root, function (elt) {\n                                      putInto(runtime, elt, prop, valueToPut);\n                                  });\n                              }\n                          } else {\n                              var op =\n                                  operation === \"before\"\n                                      ? Element.prototype.before\n                                      : operation === \"after\"\n                                      ? Element.prototype.after\n                                      : operation === \"start\"\n                                      ? Element.prototype.prepend\n                                      : operation === \"end\"\n                                      ? Element.prototype.append\n                                      : Element.prototype.append; // unreachable\n\n                              runtime.implicitLoop(root, function (elt) {\n                                  op.call(\n                                      elt,\n                                      valueToPut instanceof Node\n                                          ? valueToPut\n                                          : runtime.convertValue(valueToPut, \"Fragment\")\n                                  );\n                                  // process any new content\n                                  if (elt.parentElement) {\n                                      runtime.processNode(elt.parentElement);\n                                  } else {\n                                      runtime.processNode(elt);\n                                  }\n                              });\n                          }\n                      }\n                      return runtime.findNext(this, context);\n                  },\n              };\n              return putCmd;\n          }\n      });\n\n      function parsePseudopossessiveTarget(parser, runtime, tokens) {\n          var targets;\n          if (\n              tokens.matchToken(\"the\") ||\n              tokens.matchToken(\"element\") ||\n              tokens.matchToken(\"elements\") ||\n              tokens.currentToken().type === \"CLASS_REF\" ||\n              tokens.currentToken().type === \"ID_REF\" ||\n              (tokens.currentToken().op && tokens.currentToken().value === \"<\")\n          ) {\n              parser.possessivesDisabled = true;\n              try {\n                  targets = parser.parseElement(\"expression\", tokens);\n              } finally {\n                  delete parser.possessivesDisabled;\n              }\n              // optional possessive\n              if (tokens.matchOpToken(\"'\")) {\n                  tokens.requireToken(\"s\");\n              }\n          } else if (tokens.currentToken().type === \"IDENTIFIER\" && tokens.currentToken().value === \"its\") {\n              var identifier = tokens.matchToken(\"its\");\n              targets = {\n                  type: \"pseudopossessiveIts\",\n                  token: identifier,\n                  name: identifier.value,\n                  evaluate: function (context) {\n                      return runtime.resolveSymbol(\"it\", context);\n                  },\n              };\n          } else {\n              tokens.matchToken(\"my\") || tokens.matchToken(\"me\"); // consume optional 'my'\n              targets = parser.parseElement(\"implicitMeTarget\", tokens);\n          }\n          return targets;\n      }\n\n      parser.addCommand(\"transition\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"transition\")) {\n              var targetsExpr = parsePseudopossessiveTarget(parser, runtime, tokens);\n\n              var properties = [];\n              var from = [];\n              var to = [];\n              var currentToken = tokens.currentToken();\n              while (\n                  !parser.commandBoundary(currentToken) &&\n                  currentToken.value !== \"over\" &&\n                  currentToken.value !== \"using\"\n              ) {\n                  if (tokens.currentToken().type === \"STYLE_REF\") {\n                      let styleRef = tokens.consumeToken();\n                      let styleProp = styleRef.value.substr(1);\n                      properties.push({\n                          type: \"styleRefValue\",\n                          evaluate: function () {\n                              return styleProp;\n                          },\n                      });\n                  } else {\n                      properties.push(parser.requireElement(\"stringLike\", tokens));\n                  }\n\n                  if (tokens.matchToken(\"from\")) {\n                      from.push(parser.requireElement(\"expression\", tokens));\n                  } else {\n                      from.push(null);\n                  }\n                  tokens.requireToken(\"to\");\n                  if (tokens.matchToken(\"initial\")) {\n                      to.push({\n                          type: \"initial_literal\",\n                          evaluate : function(){\n                              return \"initial\";\n                          }\n                      });\n                  } else {\n                      to.push(parser.requireElement(\"expression\", tokens));\n                  }\n                  currentToken = tokens.currentToken();\n              }\n              if (tokens.matchToken(\"over\")) {\n                  var over = parser.requireElement(\"expression\", tokens);\n              } else if (tokens.matchToken(\"using\")) {\n                  var using = parser.requireElement(\"expression\", tokens);\n              }\n\n              var transition = {\n                  to: to,\n                  args: [targetsExpr, properties, from, to, using, over],\n                  op: function (context, targets, properties, from, to, using, over) {\n                      runtime.nullCheck(targets, targetsExpr);\n                      var promises = [];\n                      runtime.implicitLoop(targets, function (target) {\n                          var promise = new Promise(function (resolve, reject) {\n                              var initialTransition = target.style.transition;\n                              if (over) {\n                                  target.style.transition = \"all \" + over + \"ms ease-in\";\n                              } else if (using) {\n                                  target.style.transition = using;\n                              } else {\n                                  target.style.transition = config.defaultTransition;\n                              }\n                              var internalData = runtime.getInternalData(target);\n                              var computedStyles = getComputedStyle(target);\n\n                              var initialStyles = {};\n                              for (var i = 0; i < computedStyles.length; i++) {\n                                  var name = computedStyles[i];\n                                  var initialValue = computedStyles[name];\n                                  initialStyles[name] = initialValue;\n                              }\n\n                              // store intitial values\n                              if (!internalData.initalStyles) {\n                                  internalData.initalStyles = initialStyles;\n                              }\n\n                              for (var i = 0; i < properties.length; i++) {\n                                  var property = properties[i];\n                                  var fromVal = from[i];\n                                  if (fromVal === \"computed\" || fromVal == null) {\n                                      target.style[property] = initialStyles[property];\n                                  } else {\n                                      target.style[property] = fromVal;\n                                  }\n                              }\n                              //console.log(\"transition started\", transition);\n\n                              var transitionStarted = false;\n                              var resolved = false;\n\n                              target.addEventListener(\n                                  \"transitionend\",\n                                  function () {\n                                      if (!resolved) {\n                                          //console.log(\"transition ended\", transition);\n                                          target.style.transition = initialTransition;\n                                          resolved = true;\n                                          resolve(undefined);\n                                      }\n                                  },\n                                  { once: true }\n                              );\n\n                              target.addEventListener(\n                                  \"transitionstart\",\n                                  function () {\n                                      transitionStarted = true;\n                                  },\n                                  { once: true }\n                              );\n\n                              // it no transition has started in 100ms, continue\n                              setTimeout(function () {\n                                  if (!resolved && !transitionStarted) {\n                                      //console.log(\"transition ended\", transition);\n                                      target.style.transition = initialTransition;\n                                      resolved = true;\n                                      resolve(undefined);\n                                  }\n                              }, 100);\n\n                              setTimeout(function () {\n                                  var autoProps = [];\n                                  for (var i = 0; i < properties.length; i++) {\n                                      var property = properties[i];\n                                      var toVal = to[i];\n                                      if (toVal === \"initial\") {\n                                          var propertyValue = internalData.initalStyles[property];\n                                          target.style[property] = propertyValue;\n                                      } else {\n                                          target.style[property] = toVal;\n                                      }\n                                      //console.log(\"set\", property, \"to\", target.style[property], \"on\", target, \"value passed in : \", toVal);\n                                  }\n                              }, 0);\n                          });\n                          promises.push(promise);\n                      });\n                      return Promise.all(promises).then(function () {\n                          return runtime.findNext(transition, context);\n                      });\n                  },\n              };\n              return transition;\n          }\n      });\n\n      parser.addCommand(\"measure\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"measure\")) return;\n\n          var targetExpr = parsePseudopossessiveTarget(parser, runtime, tokens);\n\n          var propsToMeasure = [];\n          if (!parser.commandBoundary(tokens.currentToken()))\n              do {\n                  propsToMeasure.push(tokens.matchTokenType(\"IDENTIFIER\").value);\n              } while (tokens.matchOpToken(\",\"));\n\n          return {\n              properties: propsToMeasure,\n              args: [targetExpr],\n              op: function (ctx, target) {\n                  runtime.nullCheck(target, targetExpr);\n                  if (0 in target) target = target[0]; // not measuring multiple elts\n                  var rect = target.getBoundingClientRect();\n                  var scroll = {\n                      top: target.scrollTop,\n                      left: target.scrollLeft,\n                      topMax: target.scrollTopMax,\n                      leftMax: target.scrollLeftMax,\n                      height: target.scrollHeight,\n                      width: target.scrollWidth,\n                  };\n\n                  ctx.result = {\n                      x: rect.x,\n                      y: rect.y,\n                      left: rect.left,\n                      top: rect.top,\n                      right: rect.right,\n                      bottom: rect.bottom,\n                      width: rect.width,\n                      height: rect.height,\n                      bounds: rect,\n\n                      scrollLeft: scroll.left,\n                      scrollTop: scroll.top,\n                      scrollLeftMax: scroll.leftMax,\n                      scrollTopMax: scroll.topMax,\n                      scrollWidth: scroll.width,\n                      scrollHeight: scroll.height,\n                      scroll: scroll,\n                  };\n\n                  runtime.forEach(propsToMeasure, function (prop) {\n                      if (prop in ctx.result) ctx.locals[prop] = ctx.result[prop];\n                      else throw \"No such measurement as \" + prop;\n                  });\n\n                  return runtime.findNext(this, ctx);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"closestExpr\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"closest\")) {\n              if (tokens.matchToken(\"parent\")) {\n                  var parentSearch = true;\n              }\n\n              var css = null;\n              if (tokens.currentToken().type === \"ATTRIBUTE_REF\") {\n                  var attributeRef = parser.requireElement(\"attributeRefAccess\", tokens, null);\n                  css = \"[\" + attributeRef.attribute.name + \"]\";\n              }\n\n              if (css == null) {\n                  var expr = parser.requireElement(\"expression\", tokens);\n                  if (expr.css == null) {\n                      parser.raiseParseError(tokens, \"Expected a CSS expression\");\n                  } else {\n                      css = expr.css;\n                  }\n              }\n\n              if (tokens.matchToken(\"to\")) {\n                  var to = parser.parseElement(\"expression\", tokens);\n              } else {\n                  var to = parser.parseElement(\"implicitMeTarget\", tokens);\n              }\n\n              var closestExpr = {\n                  type: \"closestExpr\",\n                  parentSearch: parentSearch,\n                  expr: expr,\n                  css: css,\n                  to: to,\n                  args: [to],\n                  op: function (ctx, to) {\n                      if (to == null) {\n                          return null;\n                      } else {\n                          let result = [];\n                          runtime.implicitLoop(to, function(to){\n                              if (parentSearch) {\n                                  result.push(to.parentElement ? to.parentElement.closest(css) : null);\n                              } else {\n                                  result.push(to.closest(css));\n                              }\n                          })\n                          if (runtime.shouldAutoIterate(to)) {\n                              return result;\n                          } else {\n                              return result[0];\n                          }\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n\n              if (attributeRef) {\n                  attributeRef.root = closestExpr;\n                  attributeRef.args = [closestExpr];\n                  return attributeRef;\n              } else {\n                  return closestExpr;\n              }\n          }\n      });\n\n      parser.addCommand(\"go\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"go\")) {\n              if (tokens.matchToken(\"back\")) {\n                  var back = true;\n              } else {\n                  tokens.matchToken(\"to\");\n                  if (tokens.matchToken(\"url\")) {\n                      var target = parser.requireElement(\"stringLike\", tokens);\n                      var url = true;\n                      if (tokens.matchToken(\"in\")) {\n                          tokens.requireToken(\"new\");\n                          tokens.requireToken(\"window\");\n                          var newWindow = true;\n                      }\n                  } else {\n                      tokens.matchToken(\"the\"); // optional the\n                      var verticalPosition = tokens.matchAnyToken(\"top\", \"middle\", \"bottom\");\n                      var horizontalPosition = tokens.matchAnyToken(\"left\", \"center\", \"right\");\n                      if (verticalPosition || horizontalPosition) {\n                          tokens.requireToken(\"of\");\n                      }\n                      var target = parser.requireElement(\"unaryExpression\", tokens);\n\n                      var plusOrMinus = tokens.matchAnyOpToken(\"+\", \"-\");\n                      if (plusOrMinus) {\n                          tokens.pushFollow(\"px\");\n                          try {\n                              var offset = parser.requireElement(\"expression\", tokens);\n                          } finally {\n                              tokens.popFollow();\n                          }\n                      }\n                      tokens.matchToken(\"px\"); // optional px\n\n                      var smoothness = tokens.matchAnyToken(\"smoothly\", \"instantly\");\n\n                      var scrollOptions:ScrollOptions & { block?:string, inline?:string} = {};\n                      if (verticalPosition) {\n                          if (verticalPosition.value === \"top\") {\n                              scrollOptions.block = \"start\";\n                          } else if (verticalPosition.value === \"bottom\") {\n                              scrollOptions.block = \"end\";\n                          } else if (verticalPosition.value === \"middle\") {\n                              scrollOptions.block = \"center\";\n                          }\n                      }\n\n                      if (horizontalPosition) {\n                          if (horizontalPosition.value === \"left\") {\n                              scrollOptions.inline = \"start\";\n                          } else if (horizontalPosition.value === \"center\") {\n                              scrollOptions.inline = \"center\";\n                          } else if (horizontalPosition.value === \"right\") {\n                              scrollOptions.inline = \"end\";\n                          }\n                      }\n\n                      if (smoothness) {\n                          if (smoothness.value === \"smoothly\") {\n                              scrollOptions.behavior = \"smooth\";\n                          } else if (smoothness.value === \"instantly\") {\n// @ts-ignore *C* is the following correct?\n                              scrollOptions.behavior = \"instant\";\n                          }\n                      }\n                  }\n              }\n\n              var goCmd = {\n                  target: target,\n                  args: [target, offset],\n                  op: function (ctx, to, offset) {\n                      if (back) {\n                          window.history.back();\n                      } else if (url) {\n                          if (to) {\n                              if (newWindow) {\n                                  window.open(to);\n                              } else {\n                                  window.location.href = to;\n                              }\n                          }\n                      } else {\n                          runtime.implicitLoop(to, function (target) {\n\n                              if (target === window) {\n                                  target = document.body;\n                              }\n\n                              if(plusOrMinus) {\n                                  // a top scroll w/ an offset of some sort\n                                  var boundingRect = target.getBoundingClientRect();\n                                  let scrollShim = document.createElement('div');\n\n                                  if (plusOrMinus.value === \"-\") {\n                                      var finalOffset = -offset;\n                                  } else {\n                                      var finalOffset = - -offset;\n                                  }\n\n                                  scrollShim.style.position = 'absolute';\n                                  scrollShim.style.top = (boundingRect.x + finalOffset) + \"px\";\n                                  scrollShim.style.left = (boundingRect.y + finalOffset) + \"px\";\n                                  scrollShim.style.height = (boundingRect.height + (2 * finalOffset)) + \"px\";\n                                  scrollShim.style.width = (boundingRect.width + (2 * finalOffset)) + \"px\";\n                                  scrollShim.style.zIndex = \"\" + Number.MIN_SAFE_INTEGER;\n                                  scrollShim.style.opacity = \"0\";\n\n                                  document.body.appendChild(scrollShim);\n                                  setTimeout(function () {\n                                      document.body.removeChild(scrollShim);\n                                  }, 100);\n\n                                  target = scrollShim;\n                              }\n\n                              target.scrollIntoView(scrollOptions);\n                          });\n                      }\n                      return runtime.findNext(goCmd, ctx);\n                  },\n              };\n              return goCmd;\n          }\n      });\n\n      config.conversions.dynamicResolvers.push(function (str, node) {\n          if (!(str === \"Values\" || str.indexOf(\"Values:\") === 0)) {\n              return;\n          }\n          var conversion = str.split(\":\")[1];\n          /** @type Object<string,string | string[]> */\n          var result = {};\n\n          var implicitLoop = parser.runtime.implicitLoop.bind(parser.runtime);\n\n          implicitLoop(node, function (/** @type HTMLInputElement */ node) {\n              // Try to get a value directly from this node\n              var input = getInputInfo(node);\n\n              if (input !== undefined) {\n                  result[input.name] = input.value;\n                  return;\n              }\n\n              // Otherwise, try to query all child elements of this node that *should* contain values.\n              if (node.querySelectorAll != undefined) {\n                  /** @type {NodeListOf<HTMLInputElement>} */\n                  var children = node.querySelectorAll(\"input,select,textarea\");\n                  children.forEach(appendValue);\n              }\n          });\n\n          if (conversion) {\n              if (conversion === \"JSON\") {\n                  return JSON.stringify(result);\n              } else if (conversion === \"Form\") {\n                  /** @ts-ignore */\n                  // TODO: does this work with multiple inputs of the same name?\n                  return new URLSearchParams(result).toString();\n              } else {\n                  throw \"Unknown conversion: \" + conversion;\n              }\n          } else {\n              return result;\n          }\n\n          /**\n           * @param {HTMLInputElement} node\n           */\n          function appendValue(node) {\n              var info = getInputInfo(node);\n\n              if (info == undefined) {\n                  return;\n              }\n\n              // If there is no value already stored in this space.\n              if (result[info.name] == undefined) {\n                  result[info.name] = info.value;\n                  return;\n              }\n\n              if (Array.isArray(result[info.name]) && Array.isArray(info.value)) {\n                  result[info.name] = [].concat(result[info.name], info.value);\n                  return;\n              }\n          }\n\n          /**\n           * @param {HTMLInputElement} node\n           * @returns {{name:string, value:string | string[]} | undefined}\n           */\n          function getInputInfo(node) {\n              try {\n                  /** @type {{name: string, value: string | string[]}}*/\n                  var result = {\n                      name: node.name,\n                      value: node.value,\n                  };\n\n                  if (result.name == undefined || result.value == undefined) {\n                      return undefined;\n                  }\n\n                  if (node.type == \"radio\" && node.checked == false) {\n                      return undefined;\n                  }\n\n                  if (node.type == \"checkbox\") {\n                      if (node.checked == false) {\n                          result.value = undefined;\n                      } else if (typeof result.value === \"string\") {\n                          result.value = [result.value];\n                      }\n                  }\n\n                  if (node.type == \"select-multiple\") {\n                      /** @type {NodeListOf<HTMLSelectElement>} */\n                      var selected = node.querySelectorAll(\"option[selected]\");\n\n                      result.value = [];\n                      for (var index = 0; index < selected.length; index++) {\n                          result.value.push(selected[index].value);\n                      }\n                  }\n                  return result;\n              } catch (e) {\n                  return undefined;\n              }\n          }\n      });\n\n      config.conversions[\"HTML\"] = function (value) {\n          var toHTML = /** @returns {string}*/ function (/** @type any*/ value) {\n              if (value instanceof Array) {\n                  return value\n                      .map(function (item) {\n                          return toHTML(item);\n                      })\n                      .join(\"\");\n              }\n\n              if (value instanceof HTMLElement) {\n                  return value.outerHTML;\n              }\n\n              if (value instanceof NodeList) {\n                  var result = \"\";\n                  for (var i = 0; i < value.length; i++) {\n                      var node = value[i];\n                      if (node instanceof HTMLElement) {\n                          result += node.outerHTML;\n                      }\n                  }\n                  return result;\n              }\n\n              if (value.toString) {\n                  return value.toString();\n              }\n\n              return \"\";\n          };\n\n          return toHTML(value);\n      };\n\n      config.conversions[\"Fragment\"] = function (val) {\n          var frag = document.createDocumentFragment();\n          parser.runtime.implicitLoop(val, function (val) {\n              if (val instanceof Node) frag.append(val);\n              else {\n                  var temp = document.createElement(\"template\");\n                  temp.innerHTML = val;\n                  frag.append(temp.content);\n              }\n          });\n          return frag;\n      };\n  }\n\n\n  // Public API\n\n  const runtime_ = new Runtime(), lexer_ = runtime_.lexer, parser_ = runtime_.parser\n\n  /**\n   *\n   * @param {string} src\n   * @param {Partial<Context>} [ctx]\n   */\n  function run(src, ctx = undefined) {\n      return runtime_.evaluate(src, ctx)\n  }\n\n  function browserInit() {\n      /** @type {HTMLScriptElement[]} */\n      var scripts = Array.from(globalScope.document.querySelectorAll(\"script[type='text/hyperscript'][src]\"))\n      Promise.all(\n          scripts.map(function (script:any) {\n              return fetch(script.src)\n                  .then(function (res) {\n                      return res.text();\n                  });\n          })\n      )\n      .then(script_values => script_values.forEach(sc => _hyperscript(sc)))\n      .then(() => ready(function () {\n          mergeMetaConfig();\n          runtime_.processNode(document.documentElement);\n          globalScope.document.addEventListener(\"htmx:load\", function (/** @type {CustomEvent} */ evt) {\n              runtime_.processNode(evt.detail.elt);\n          });\n      }));\n\n      function ready(fn) {\n          if (document.readyState !== \"loading\") {\n              setTimeout(fn);\n          } else {\n              document.addEventListener(\"DOMContentLoaded\", fn);\n          }\n      }\n\n      function getMetaConfig() {\n          /** @type {HTMLMetaElement} */\n          var element = document.querySelector('meta[name=\"htmx-config\"]');\n          if (element) {\n              return parseJSON(element['content']);\n          } else {\n              return null;\n          }\n      }\n\n      function mergeMetaConfig() {\n          var metaConfig = getMetaConfig();\n          if (metaConfig) {\n              Object.assign(config, metaConfig);\n          }\n      }\n  }\n\n  /**\n   * @typedef {Object} HyperscriptAPI\n   *\n   * @property {Object} config\n   * @property {string} config.attributes\n   * @property {string} config.defaultTransition\n   * @property {string} config.disableSelector\n   * @property {typeof conversions} config.conversions\n   *\n   * @property {Object} internals\n   * @property {Lexer} internals.lexer\n   * @property {typeof Lexer} internals.Lexer\n   * @property {Parser} internals.parser\n   * @property {typeof Parser} internals.Parser\n   * @property {Runtime} internals.runtime\n   * @property {typeof Runtime} internals.Runtime\n   *\n   * @property {typeof ElementCollection} ElementCollection\n   *\n   * @property {(keyword: string, definition: ParseRule) => void} addFeature\n   * @property {(keyword: string, definition: ParseRule) => void} addCommand\n   * @property {(keyword: string, definition: ParseRule) => void} addLeafExpression\n   * @property {(keyword: string, definition: ParseRule) => void} addIndirectExpression\n   *\n   * @property {(src: string, ctx?: Partial<Context>) => any} evaluate\n   * @property {(src: string) => ASTNode} parse\n   * @property {(node: Element) => void} processNode\n   *\n   * @property {() => void} browserInit\n   *\n   *\n   * @typedef {HyperscriptAPI & ((src: string, ctx?: Partial<Context>) => any)} Hyperscript\n   */\n\n  /**\n   * @type {Hyperscript}\n   */\n  const _hyperscript = Object.assign(\n      run,\n      {\n          config,\n\n          use(plugin) { plugin(_hyperscript) },\n\n          internals: {\n              lexer: lexer_, parser: parser_, runtime: runtime_,\n              Lexer, Tokens, Parser, Runtime,\n          },\n          ElementCollection,\n\n          addFeature:            parser_.addFeature.bind(parser_),\n          addCommand:            parser_.addCommand.bind(parser_),\n          addLeafExpression:     parser_.addLeafExpression.bind(parser_),\n          addIndirectExpression: parser_.addIndirectExpression.bind(parser_),\n\n          evaluate:    runtime_.evaluate.bind(runtime_),\n          parse:       runtime_.parse.bind(runtime_),\n          processNode: runtime_.processNode.bind(runtime_),\n\n          browserInit,\n      }\n  )\n\n  return _hyperscript\n})\n"],"names":["self","factory","_hyperscript","globalScope","conversions","dynamicResolvers","str","value","Number","toFixed","indexOf","num","split","parseInt","String","val","toString","Int","Float","parseFloat","Date","Array","from","JSON","stringify","Object","parse","assign","config","attributes","hideShowStrategies","undefined","defaultHideShowStrategy","defaultTransition","disableSelector","Lexer","isValidCSSClassChar","c","isAlpha","isNumeric","isValidCSSIDChar","isWhitespace","isNewline","positionString","token","line","column","isIdentifierChar","isReservedChar","isValidSingleQuoteStringStart","tokens","length","previousToken","type","op","tokenize","string","template","source","position","lastToken","templateBraceCount","inTemplate","currentChar","nextChar","nextCharAt","consumeComment","consumeCommentMultiline","push","consumeWhitespace","possiblePrecedingSymbol","consumeAttributeReference","consumeShortAttributeReference","consumeStyleReference","consumeIdentifier","consumeNumber","OP_TABLE","consumeOp","makeToken","consumeChar","Error","consumeString","consumeIdReference","consumeClassReference","Tokens","makeOpToken","start","end","classRef","attributeRef","styleRef","idRef","identifier","number","startChar","nextChar_1","charAt","whitespace","prototype","$","consumed","this","_lastConsumed","follows","defineProperty","get","shift","raiseError","error","Parser","raiseParseError","requireOpToken","matchOpToken","currentToken","matchAnyOpToken","op1","op2","op3","i","arguments","opToken","match","matchAnyToken","matchToken","consumeToken","requireTokenType","type1","type2","type3","type4","matchTokenType","requireToken","peekToken","peek","consumeUntil","tokenList","lastWhitespace","consumeUntilWhitespace","hasMore","n","dontIgnoreWhitespace","lastMatch","pushFollow","popFollow","pop","clearFollows","tmp","restoreFollows","f","sourceFor","programSource","substring","startToken","endToken","lineFor","runtime","GRAMMAR","COMMANDS","FEATURES","LEAF_EXPRESSIONS","INDIRECT_EXPRESSIONS","possessivesDisabled","addGrammarElement","parser","featureElement","requireElement","featureDefinition","commandElement_1","commandElement","commandDefinition","parseElement","cmd","next","result","parseAnyOf","root","indirect","unless","args","context","conditional","execute","unifiedExec","parent","leaf","use","plugin","initElt","elementDefinition","message","types","expression","name","definition","addCommand","keyword","commandGrammarType","commandDefinitionWrapper","meta","command","addFeature","featureGrammarType","featureDefinitionWrapper","isFeature","addLeafExpression","addIndirectExpression","createParserContext","lines","contextLine","offset","repeat","parseHyperScript","setParent","elt","children","Set","add","commandStart","featureStart","commandBoundary","parseStringTemplate","returnArr","startingBrace","ensureTerminated","commandList","implicitReturn","returned","resolve","HALT","ctx","Runtime","lexer","_scriptAttrs","hyperscriptFeaturesMap","WeakMap","internalDataMap","hyperscriptUrl","document","currentScript","src","hyperscriptCoreGrammar","hyperscriptWebGrammar","matchesSelector","selector","matchesFunction","matches","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","call","makeEvent","eventName","detail","evt","Event","bubbles","cancelable","createEvent","initCustomEvent","triggerEvent","sender","event","dispatchEvent","isArrayLike","isArray","NodeList","HTMLCollection","isIterable","Symbol","iterator","shouldAutoIterate","shouldAutoIterateSymbol","forEach","func","value_1","__values","value_1_1","done","implicitLoop","value_2","value_2_1","wrapArrays","arr","arg","Promise","all","unwrapAsyncs","values","asyncWrapper","j","valueElement","_this","unifiedEval","e","handlingFinally","console","registerHyperTrace","errorHandler","handlingError","locals","errorSymbol","currentException","then","resolvedNext","catch","reason","finallyHandler","onHalt","reject","async","wrappedAsyncs","argument","element","evaluate","apply","getScriptAttributes","replace","getScript","scriptAttribute","hasAttribute","getAttribute","HTMLScriptElement","innerText","getHyperscriptFeatures","hyperscriptFeatures","set","addFeatures","owner","parentElement","makeContext","feature","hyperscriptTarget","Context","getScriptSelector","map","attribute","join","convertValue","converted","dynamicResolver","converter","hyperscript","evaluateNoPromise","HyperscriptModule","_super","mod","module","__extends","id","EventTarget","body","processNode","initElement","querySelectorAll","target","closest","internalData","getInternalData","initialized","script","hyperScript","setTimeout","stack","typeCheck","typeString","nullOk","slice","getElementScope","scopeName","behavior","getOrInitObject","isReservedWord","includes","isHyperscriptContext","resolveSymbol","me","you","fromMetaContext","fromContext","setSymbol","elementScope","findNext","resolveNext","flatGet","property","getter","root_1","root_1_1","componentValue","resolveProperty","resolveAttribute","resolveStyle","style","resolveComputedStyle","getComputedStyle","getPropertyValue","assignToNamespace","nameSpace","propertyName","newRoot","getHyperTrace","thrown","trace","caller","traceMap","Map","traceEntry","print","logger","maxLen","Math","max","displayName","traceElt","padEnd","escapeSelector","nullCheck","isEmpty","doesExist","value_3","value_3_1","getRootNode","node","Node","rv","Document","ShadowRoot","getEventQueueFor","onFeature","eventQueuesForElt","eventQueues","eventQueueForFeature","queue","executing","iterators","ElementCollection","css","relativeToElement","escape","_css","substr","className","contains","_b","_c","selectMatches","prop","newObj","parseJSON","jString","logError","msg","log","varargConstructor","Cls","bind","concat","_runtime","expr","stringToken","rawValue","innerTokens","returnStr","tokenArr","t","numberToken","elementId","templateValue","getElementById","value_4","css_1","TemplatedQueryElementCollection","templateParts","elements","filter","Element","el","dataset","hsQueryId","removeAttribute","queryTokens","queryValue","_i","outerVal","innerValue","styleProp","startsWith","key","keyExpressions","valueExpressions","keys","returnVal","fields","_namedArgList_","scope","eltPrefix","booleanLiteral","arg1","returnFunc","propertyAccess","_context","rootVal","childOfUrRoot","urRoot","attributeElt","apostrophe","targetElt","results","within","rootElt","conversion","functionCall","argExressions","rootRoot","hyperfunc","argVals","_ctx","andBefore","andAfter","firstIndex","secondIndex","arrayIndex","STRING_POSTFIXES","stringPosfix","postfix","timeFactor","time","factor","typeName","originalEvaluate","logValue","constructor","scanForwardQuery","wrap","compareDocumentPosition","DOCUMENT_POSITION_PRECEDING","scanBackwardsQuery","DOCUMENT_POSITION_FOLLOWING","scanForwardArray","array","first","scanBackwardsArray","reverse","sloppyContains","container","sloppyMatches","toMatch","forwardSearch","thing","withinElt","inSearch","inElt","wrapping","operator","rhs","rhsVal","floor","random","mathOp","initialMathOp","lhs","lhsVal","comparisonToken","hasRightValue","logicalOp","initialLogicalOp","features","features_1","features_1_1","install","parseEventArgs","parseSendCmd","cmdType","details","toExpr","sendCmd","to","every","events","startCount","endCount","unbounded","intersectionSpec","mutationSpec","startCountToken","endCountToken","elsewhere","inExpr","debounceTime","throttleTime","execCount","on","debounced","lastExec","queueLast","queueFirst","queueNone","eventQueueInfo","queued","err","hypertrace","targets","eventSpec","MutationObserver","mutationList","observer","observe","observer_1","IntersectionObserver","entries","entries_1","entries_1_1","entry","isIntersecting","addEventListener","listener","isConnected","removeEventListener","eventValue","initialCtx","inElement","clearTimeout","now","warn","nameVal","funcName","functionFeature","argumentVal","callingCommand","promise","theResolve","theReject","returnValue","setCmd","setFeature_1","immediately","initFeature","handler","path","formalParams","hs","innerArgs","installFeature","behaviorPath","behaviorNamespace","Function","jsSourceStart","jsLastToken","funcNames","expectFunctionDeclaration","jsSourceEnd","exposedFunctionNames","jsSource","jsBody","function","inputs","inp","input","actualResult","slot","tellCmd","index","originalYou","lookahead","resolved","eventInfo","once","events_1","events_1_1","timeValue","separator","parseReturnFunction","returnAValue","returnCmd","keepExecuting","bubbling","haltDefault","exit","stopPropagation","preventDefault","exprs","withExpr","logCmd","throwCmd","parseCallOrGet","callCmd","tagname","classes","re","exec","trim","createElement","cls","classList","lookAhead","pseudoCommand","realRoot","makeSetter","symbolWrite","attributeWrite","styleWrite","arrayWrite","valueToSet","setAttribute","setter","defaultCmd","obj","objectLiteral","trueBranch","falseBranch","ifCmd","exprValue","parseRepeatExpression","startedWithForToken","innerStartToken","identifierToken","whileExpr","isUntil","forever","times","indexIdentifier","loop","last","waitATick","repeatCmd","until","whileValue","iteratorInfo","keepLooping","loopVal","eventFired","nextValFromIterator","repeatInit","parsePickRange","includeStart","includeEnd","toEnd","targetExpr","implicitResultSymbol","innerHTML","RegExpIterator","RegExpIterable","flags","RegExp","parseConversionInfo","range_1","flags_1","flags_2","amountExpr","implicitIncrementOp","targetValue","amount","newValue","implicitDecrementOp","url","conversionInfo","fetchCmd","argExpressions","abortController","AbortController","abortListener","abort","signal","finished","timeout","fetch","resp","resultDetails","response","json","text","finally","onExpr","settleCommand","transitionStarted","r","cssDeclaration","classRefs","when","remove","attrRef","cssText","stringParts","opencurly","tok","part","idx","elementExpr","fromExpr","removeChild","visibility","hideShowStrategy","resolveStrategy","between","classRef2","toggleCmd","toggle","HIDE_SHOW_STRATEGIES","display","originalDisplay","removeProperty","opacity","parseShowHideTarget","currentTokenValue","configDefault","strategies","putInto","valueToPut","HTMLDocument","firstChild","append","parsePseudopossessiveTarget","forExpr","forElt","eltColl","clazz","operationToken","operation","rootExpr","putCmd","before","after","prepend","targetsExpr","properties","styleProp_1","over","using","transition","promises","initialTransition","computedStyles","initialStyles","initialValue","initalStyles","fromVal","toVal","propertyValue","propsToMeasure","rect","getBoundingClientRect","scroll","top","scrollTop","left","scrollLeft","topMax","scrollTopMax","leftMax","scrollLeftMax","height","scrollHeight","width","scrollWidth","x","y","right","bottom","bounds","parentSearch","closestExpr","result_1","back","newWindow","verticalPosition","horizontalPosition","plusOrMinus","smoothness","scrollOptions","block","inline","goCmd","window","history","open","location","href","boundingRect","scrollShim_1","finalOffset","zIndex","MIN_SAFE_INTEGER","appendChild","scrollIntoView","getInputInfo","appendValue","URLSearchParams","info","checked","selected","toHTML","item","HTMLElement","outerHTML","frag","createDocumentFragment","temp","content","runtime_","lexer_","parser_","run","browserInit","scripts","ready","fn","readyState","getMetaConfig","querySelector","mergeMetaConfig","metaConfig","res","script_values","sc","documentElement","internals","exports"],"mappings":"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"}