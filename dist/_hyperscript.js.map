{"version":3,"file":"_hyperscript.js","sources":["../src/_hyperscript.ts"],"sourcesContent":["/**\n * @typedef {Object} Hyperscript\n */\n\n (function (self, factory) {\n  const _hyperscript = factory(self)\n\n  if (typeof exports === 'object' && typeof exports['nodeName'] !== 'string') {\n      module.exports = _hyperscript\n  } else {\n      self['_hyperscript'] = _hyperscript\n      if ('document' in self) self['_hyperscript'].browserInit()\n  }\n})(typeof self !== 'undefined' ? self : undefined, (globalScope) => {\n\n  'use strict';\n\n  /**\n   * @type {Object}\n   * @property {DynamicConverter[]} dynamicResolvers\n   * \n   * @callback DynamicConverter\n   * @param {String} str\n   * @param {*} value\n   * @returns {*}\n   */\n  const conversions = {\n      dynamicResolvers: [\n          function (str:string, value:any):any {\n              if (str === \"Fixed\") {\n                  return Number(value).toFixed();\n              } else if (str.indexOf(\"Fixed:\") === 0) {\n                  let num = str.split(\":\")[1];\n                  return Number(value).toFixed(parseInt(num));\n              }\n          }\n      ],\n      String: function (val:any):string {\n          if (val.toString) {\n              return val.toString();\n          } else {\n              return \"\" + val;\n          }\n      },\n      Int: function (val:any):number {\n          return parseInt(val);\n      },\n      Float: function (val:any):number {\n          return parseFloat(val);\n      },\n      Number: function (val:any):number {\n          return Number(val);\n      },\n      Date: function (val:any):Date {\n          return new Date(val);\n      },\n      Array: function (val:any):any[] {\n          return Array.from(val);\n      },\n      JSON: function (val:any):string {\n          return JSON.stringify(val);\n      },\n      Object: function (val:any):any {\n          if (val instanceof String) {\n              val = val.toString();\n          }\n          if (typeof val === \"string\") {\n              return JSON.parse(val);\n          } else {\n              return Object.assign({}, val);\n          }\n      },\n  }\n\n  const config = {\n      attributes: \"_, script, data-script\",\n      hideShowStrategies: undefined,\n      defaultHideShowStrategy: undefined,\n      defaultTransition: \"all 500ms ease-in\",\n      disableSelector: \"[disable-scripting], [data-disable-scripting]\",\n      conversions,\n  }\n\n  /**\n   * @typedef {Object} Token\n   * @property {string} [type]\n   * @property {string} value\n   * @property {number} [start]\n   * @property {number} [end]\n   * @property {number} [column]\n   * @property {number} [line]\n   * @property {boolean} [op] `true` if this token represents an operator\n   * @property {boolean} [template] `true` if this token is a template, for class refs, id refs, strings\n   */\n\n  type Token = {\n    type?:string, value:string,\n    start?:number, end?:number, column?:number, line?:number,\n    op?:boolean, template?:boolean,\n  }\n\n  class Lexer {\n      static OP_TABLE = {\n          \"+\": \"PLUS\",\n          \"-\": \"MINUS\",\n          \"*\": \"MULTIPLY\",\n          \"/\": \"DIVIDE\",\n          \".\": \"PERIOD\",\n          \"..\": \"ELLIPSIS\",\n          \"\\\\\": \"BACKSLASH\",\n          \":\": \"COLON\",\n          \"%\": \"PERCENT\",\n          \"|\": \"PIPE\",\n          \"!\": \"EXCLAMATION\",\n          \"?\": \"QUESTION\",\n          \"#\": \"POUND\",\n          \"&\": \"AMPERSAND\",\n          $: \"DOLLAR\",\n          \";\": \"SEMI\",\n          \",\": \"COMMA\",\n          \"(\": \"L_PAREN\",\n          \")\": \"R_PAREN\",\n          \"<\": \"L_ANG\",\n          \">\": \"R_ANG\",\n          \"<=\": \"LTE_ANG\",\n          \">=\": \"GTE_ANG\",\n          \"==\": \"EQ\",\n          \"===\": \"EQQ\",\n          \"!=\": \"NEQ\",\n          \"!==\": \"NEQQ\",\n          \"{\": \"L_BRACE\",\n          \"}\": \"R_BRACE\",\n          \"[\": \"L_BRACKET\",\n          \"]\": \"R_BRACKET\",\n          \"=\": \"EQUALS\",\n      };\n  \n      /**\n       * isValidCSSClassChar returns `true` if the provided character is valid in a CSS class.\n       * @param {string} c\n       * @returns boolean\n       */\n      static isValidCSSClassChar(c:string):boolean {\n          return Lexer.isAlpha(c) || Lexer.isNumeric(c) || c === \"-\" || c === \"_\" || c === \":\";\n      }\n  \n      /**\n       * isValidCSSIDChar returns `true` if the provided character is valid in a CSS ID\n       * @param {string} c\n       * @returns boolean\n       */\n      static isValidCSSIDChar(c:string):boolean {\n          return Lexer.isAlpha(c) || Lexer.isNumeric(c) || c === \"-\" || c === \"_\" || c === \":\";\n      }\n  \n      /**\n       * isWhitespace returns `true` if the provided character is whitespace.\n       * @param {string} c\n       * @returns boolean\n       */\n      static isWhitespace(c:string):boolean {\n          return c === \" \" || c === \"\\t\" || Lexer.isNewline(c);\n      }\n  \n      /**\n       * positionString returns a string representation of a Token's line and column details.\n       * @param {Token} token\n       * @returns string\n       */\n      static positionString(token:Token):string {\n          return \"[Line: \" + token.line + \", Column: \" + token.column + \"]\";\n      }\n  \n      /**\n       * isNewline returns `true` if the provided character is a carrage return or newline\n       * @param {string} c\n       * @returns boolean\n       */\n      static isNewline(c:string):boolean {\n          return c === \"\\r\" || c === \"\\n\";\n      }\n  \n      /**\n       * isNumeric returns `true` if the provided character is a number (0-9)\n       * @param {string} c\n       * @returns boolean\n       */\n      static isNumeric(c:string):boolean {\n          return c >= \"0\" && c <= \"9\";\n      }\n  \n      /**\n       * isAlpha returns `true` if the provided character is a letter in the alphabet\n       * @param {string} c\n       * @returns boolean\n       */\n      static isAlpha(c:string):boolean {\n          return (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\");\n      }\n  \n      /**\n       * @param {string} c\n       * @returns boolean\n       */\n      static isIdentifierChar(c:string):boolean {\n          return c === \"_\" || c === \"$\";\n      }\n  \n      /**\n       * @param {string} c\n       * @returns boolean\n       */\n      static isReservedChar(c:string):boolean {\n          return c === \"`\" || c === \"^\";\n      }\n  \n      /**\n       * @param {Token[]} tokens\n       * @returns {boolean}\n       */\n      static isValidSingleQuoteStringStart(tokens:Token[]):boolean {\n          if (tokens.length > 0) {\n              var previousToken = tokens[tokens.length - 1];\n              if (\n                  previousToken.type === \"IDENTIFIER\" ||\n                  previousToken.type === \"CLASS_REF\" ||\n                  previousToken.type === \"ID_REF\"\n              ) {\n                  return false;\n              }\n              if (previousToken.op && (previousToken.value === \">\" || previousToken.value === \")\")) {\n                  return false;\n              }\n          }\n          return true;\n      }\n  \n      /**\n       * @param {string} string\n       * @param {boolean} [template]\n       * @returns {Tokens}\n       */\n      static tokenize(string:string, template?:boolean):Tokens {\n          var tokens = /** @type {Token[]}*/ [];\n          var source = string;\n          var position = 0;\n          var column = 0;\n          var line = 1;\n          var lastToken = \"<START>\";\n          var templateBraceCount = 0;\n  \n          function inTemplate ():boolean {\n              return template && templateBraceCount === 0;\n          }\n  \n          while (position < source.length) {\n              if ((currentChar() === \"-\" && nextChar() === \"-\" && (Lexer.isWhitespace(nextCharAt(2)) || nextCharAt(2) === \"\" || nextCharAt(2) === \"-\"))\n                  || (currentChar() === \"/\" && nextChar() === \"/\")) {\n                  consumeComment();\n              } else if (currentChar() === \"/\" && nextChar() === \"*\") {\n                  consumeCommentMultiline();\n              } else {\n                  if (Lexer.isWhitespace(currentChar())) {\n                      tokens.push(consumeWhitespace());\n                  } else if (\n                      !possiblePrecedingSymbol() &&\n                      currentChar() === \".\" &&\n                      (Lexer.isAlpha(nextChar()) || nextChar() === \"{\")\n                  ) {\n                      tokens.push(consumeClassReference());\n                  } else if (\n                      !possiblePrecedingSymbol() &&\n                      currentChar() === \"#\" &&\n                      (Lexer.isAlpha(nextChar()) || nextChar() === \"{\")\n                  ) {\n                      tokens.push(consumeIdReference());\n                  } else if (currentChar() === \"[\" && nextChar() === \"@\") {\n                      tokens.push(consumeAttributeReference());\n                  } else if (currentChar() === \"@\") {\n                      tokens.push(consumeShortAttributeReference());\n                  } else if (currentChar() === \"*\" && Lexer.isAlpha(nextChar())) {\n                      tokens.push(consumeStyleReference());\n                  } else if (Lexer.isAlpha(currentChar()) || (!inTemplate() && Lexer.isIdentifierChar(currentChar()))) {\n                      tokens.push(consumeIdentifier());\n                  } else if (Lexer.isNumeric(currentChar())) {\n                      tokens.push(consumeNumber());\n                  } else if (!inTemplate() && (currentChar() === '\"' || currentChar() === \"`\")) {\n                      tokens.push(consumeString());\n                  } else if (!inTemplate() && currentChar() === \"'\") {\n                      if (Lexer.isValidSingleQuoteStringStart(tokens)) {\n                          tokens.push(consumeString());\n                      } else {\n                          tokens.push(consumeOp());\n                      }\n                  } else if (Lexer.OP_TABLE[currentChar()]) {\n                      if (lastToken === \"$\" && currentChar() === \"{\") {\n                          templateBraceCount++;\n                      }\n                      if (currentChar() === \"}\") {\n                          templateBraceCount--;\n                      }\n                      tokens.push(consumeOp());\n                  } else if (inTemplate() || Lexer.isReservedChar(currentChar())) {\n                      tokens.push(makeToken(\"RESERVED\", consumeChar()));\n                  } else {\n                      if (position < source.length) {\n                          throw Error(\"Unknown token: \" + currentChar() + \" \");\n                      }\n                  }\n              }\n          }\n\n          return new Tokens(tokens, [], source);\n\n          /**\n           * @param {string} [type]\n           * @param {string} [value]\n           * @returns {Token}\n           */\n          function makeOpToken(type?:string, value?:string):Token {\n              var token = makeToken(type, value);\n              token.op = true;\n              return token;\n          }\n\n          /**\n           * @param {string} [type]\n           * @param {string} [value]\n           * @returns {Token}\n           */\n          function makeToken(type:string, value?:string):Token {\n              return {\n                  type: type,\n                  value: value || \"\",\n                  start: position,\n                  end: position + 1,\n                  column: column,\n                  line: line,\n              };\n          }\n\n          function consumeComment ():void {\n              while (currentChar() && !Lexer.isNewline(currentChar())) {\n                  consumeChar();\n              }\n              consumeChar(); // Consume newline\n          }\n\n          function consumeCommentMultiline ():void {\n              while (currentChar() && !(currentChar() === '*' && nextChar() === '/')) {\n                  consumeChar();\n              }\n              consumeChar(); // Consume \"*/\"\n              consumeChar();\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeClassReference ():Token {\n              var classRef = makeToken(\"CLASS_REF\");\n              var value = consumeChar();\n              if (currentChar() === \"{\") {\n                  classRef.template = true;\n                  value += consumeChar();\n                  while (currentChar() && currentChar() !== \"}\") {\n                      value += consumeChar();\n                  }\n                  if (currentChar() !== \"}\") {\n                      throw Error(\"Unterminated class reference\");\n                  } else {\n                      value += consumeChar(); // consume final curly\n                  }\n              } else {\n                  while (Lexer.isValidCSSClassChar(currentChar())) {\n                      value += consumeChar();\n                  }\n              }\n              classRef.value = value;\n              classRef.end = position;\n              return classRef;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeAttributeReference ():Token {\n              var attributeRef = makeToken(\"ATTRIBUTE_REF\");\n              var value = consumeChar();\n              while (position < source.length && currentChar() !== \"]\") {\n                  value += consumeChar();\n              }\n              if (currentChar() === \"]\") {\n                  value += consumeChar();\n              }\n              attributeRef.value = value;\n              attributeRef.end = position;\n              return attributeRef;\n          }\n\n          function consumeShortAttributeReference ():Token {\n              var attributeRef = makeToken(\"ATTRIBUTE_REF\");\n              var value = consumeChar();\n              while (Lexer.isValidCSSIDChar(currentChar())) {\n                  value += consumeChar();\n              }\n              attributeRef.value = value;\n              attributeRef.end = position;\n              return attributeRef;\n          }\n\n          function consumeStyleReference ():Token {\n              var styleRef = makeToken(\"STYLE_REF\");\n              var value = consumeChar();\n              while (Lexer.isAlpha(currentChar()) || currentChar() === \"-\") {\n                  value += consumeChar();\n              }\n              styleRef.value = value;\n              styleRef.end = position;\n              return styleRef;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeIdReference ():Token {\n              var idRef = makeToken(\"ID_REF\");\n              var value = consumeChar();\n              if (currentChar() === \"{\") {\n                  idRef.template = true;\n                  value += consumeChar();\n                  while (currentChar() && currentChar() !== \"}\") {\n                      value += consumeChar();\n                  }\n                  if (currentChar() !== \"}\") {\n                      throw Error(\"Unterminated id reference\");\n                  } else {\n                      consumeChar(); // consume final quote\n                  }\n              } else {\n                  while (Lexer.isValidCSSIDChar(currentChar())) {\n                      value += consumeChar();\n                  }\n              }\n              idRef.value = value;\n              idRef.end = position;\n              return idRef;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeIdentifier ():Token {\n              var identifier = makeToken(\"IDENTIFIER\");\n              var value = consumeChar();\n              while (Lexer.isAlpha(currentChar()) ||\n                     Lexer.isNumeric(currentChar()) ||\n                     Lexer.isIdentifierChar(currentChar())) {\n                  value += consumeChar();\n              }\n              if (currentChar() === \"!\" && value === \"beep\") {\n                  value += consumeChar();\n              }\n              identifier.value = value;\n              identifier.end = position;\n              return identifier;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeNumber ():Token {\n              var number = makeToken(\"NUMBER\");\n              var value = consumeChar();\n              while (Lexer.isNumeric(currentChar())) {\n                  value += consumeChar();\n              }\n              if (currentChar() === \".\" && Lexer.isNumeric(nextChar())) {\n                  value += consumeChar();\n              }\n              while (Lexer.isNumeric(currentChar())) {\n                  value += consumeChar();\n              }\n              number.value = value;\n              number.end = position;\n              return number;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeOp ():Token {\n              var op = makeOpToken();\n              var value = consumeChar(); // consume leading char\n              while (currentChar() && Lexer.OP_TABLE[value + currentChar()]) {\n                  value += consumeChar();\n              }\n              op.type = Lexer.OP_TABLE[value];\n              op.value = value;\n              op.end = position;\n              return op;\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeString ():Token {\n              var string = makeToken(\"STRING\");\n              var startChar = consumeChar(); // consume leading quote\n              var value = \"\";\n              while (currentChar() && currentChar() !== startChar) {\n                  if (currentChar() === \"\\\\\") {\n                      consumeChar(); // consume escape char and get the next one\n                      let nextChar = consumeChar();\n                      if (nextChar === \"b\") {\n                          value += \"\\b\";\n                      } else if (nextChar === \"f\") {\n                          value += \"\\f\";\n                      } else if (nextChar === \"n\") {\n                          value += \"\\n\";\n                      } else if (nextChar === \"r\") {\n                          value += \"\\r\";\n                      } else if (nextChar === \"t\") {\n                          value += \"\\t\";\n                      } else if (nextChar === \"v\") {\n                          value += \"\\v\";\n                      } else {\n                          value += nextChar;\n                      }\n                  } else {\n                      value += consumeChar();\n                  }\n              }\n              if (currentChar() !== startChar) {\n                  throw Error(\"Unterminated string at \" + Lexer.positionString(string));\n              } else {\n                  consumeChar(); // consume final quote\n              }\n              string.value = value;\n              string.end = position;\n              string.template = startChar === \"`\";\n              return string;\n          }\n\n          /**\n           * @returns string\n           */\n          function currentChar ():string {\n              return source.charAt(position);\n          }\n\n          /**\n           * @returns string\n           */\n          function nextChar ():string {\n              return source.charAt(position + 1);\n          }\n\n          function nextCharAt (number:number = 1) {\n              return source.charAt(position + number);\n          }\n\n          /**\n           * @returns string\n           */\n          function consumeChar ():string {\n              lastToken = currentChar();\n              position++;\n              column++;\n              return lastToken;\n          }\n\n          /**\n           * @returns boolean\n           */\n          function possiblePrecedingSymbol ():boolean {\n              return (\n                  Lexer.isAlpha(lastToken) ||\n                  Lexer.isNumeric(lastToken) ||\n                  lastToken === \")\" ||\n                  lastToken === \"\\\"\" ||\n                  lastToken === \"'\" ||\n                  lastToken === \"`\" ||\n                  lastToken === \"}\" ||\n                  lastToken === \"]\"\n              );\n          }\n\n          /**\n           * @returns Token\n           */\n          function consumeWhitespace ():Token {\n              var whitespace = makeToken(\"WHITESPACE\");\n              var value = \"\";\n              while (currentChar() && Lexer.isWhitespace(currentChar())) {\n                  if (Lexer.isNewline(currentChar())) {\n                      column = 0;\n                      line++;\n                  }\n                  value += consumeChar();\n              }\n              whitespace.value = value;\n              whitespace.end = position;\n              return whitespace;\n          }\n      }\n\n      /**\n       * @param {string} string\n       * @param {boolean} [template]\n       * @returns {Tokens}\n       */\n      tokenize (string:string, template?:boolean):Tokens {\n          return Lexer.tokenize(string, template)\n      }\n  }\n\n  class Tokens {\n    public tokens:Token[]\n    public consumed:any[]\n    public source:any\n\n      constructor(tokens, consumed, source) {\n          this.tokens = tokens\n          this.consumed = consumed\n          this.source = source\n\n          this.consumeWhitespace (); // consume initial whitespace\n      }\n\n      get list () {\n          return this.tokens\n      }\n\n      /** @type Token | null */\n      _lastConsumed:Token | null = null;\n\n      consumeWhitespace ():void {\n          while (this.token(0, true).type === \"WHITESPACE\") {\n              this.consumed.push(this.tokens.shift());\n          }\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @param {*} error\n       * @returns {never}\n       */\n      raiseError (tokens:Tokens, error:any):void {\n          Parser.raiseParseError(tokens, error);\n      }\n\n      /**\n       * @param {string} value\n       * @returns {Token}\n       */\n      requireOpToken (value:string):Token {\n          var token = this.matchOpToken(value);\n          if (token) {\n              return token;\n          } else {\n              this.raiseError(this, \"Expected '\" + value + \"' but found '\" + this.currentToken().value + \"'\");\n          }\n      }\n\n      /**\n       * @param {string} op1\n       * @param {string} [op2]\n       * @param {string} [op3]\n       * @returns {Token | void}\n       */\n      matchAnyOpToken (/* op1:string, op2:string, op3:string */):Token|undefined {\n          for (var i = 0; i < arguments.length; i++) {\n              var opToken = arguments[i];\n              var match = this.matchOpToken(opToken);\n              if (match) {\n                  return match;\n              }\n          }\n      }\n\n      /**\n       * @param {string} op1\n       * @param {string} [op2]\n       * @param {string} [op3]\n       * @returns {Token | void}\n       */\n      matchAnyToken (/* op1:string, op2:string, op3:string */):Token|undefined {\n          for (var i = 0; i < arguments.length; i++) {\n              var opToken = arguments[i];\n              var match = this.matchToken(opToken);\n              if (match) {\n                  return match;\n              }\n          }\n      }\n\n      /**\n       * @param {string} value\n       * @returns {Token | void}\n       */\n      matchOpToken (value:string):Token|undefined {\n          if (this.currentToken() && this.currentToken().op && this.currentToken().value === value) {\n              return this.consumeToken();\n          }\n      }\n\n      /**\n       * @param {string} type1\n       * @param {string} [type2]\n       * @param {string} [type3]\n       * @param {string} [type4]\n       * @returns {Token}\n       */\n      requireTokenType (type1:string, type2:string, type3:string, type4:string):Token {\n          var token = this.matchTokenType(type1, type2, type3, type4);\n          if (token) {\n              return token;\n          } else {\n              this.raiseError(this, \"Expected one of \" + JSON.stringify([type1, type2, type3]));\n          }\n      }\n\n      /**\n       * @param {string} type1\n       * @param {string} [type2]\n       * @param {string} [type3]\n       * @param {string} [type4]\n       * @returns {Token | void}\n       */\n      matchTokenType (type1:string, type2:string, type3:string, type4:string):Token {\n          if (\n              this.currentToken() &&\n              this.currentToken().type &&\n              [type1, type2, type3, type4].indexOf(this.currentToken().type) >= 0\n          ) {\n              return this.consumeToken();\n          }\n      }\n\n      /**\n       * @param {string} value\n       * @param {string} [type]\n       * @returns {Token}\n       */\n      requireToken(value:string, type:string):Token {\n          var token = this.matchToken(value, type);\n          if (token) {\n              return token;\n          } else {\n              this.raiseError(this, \"Expected '\" + value + \"' but found '\" + this.currentToken().value + \"'\");\n          }\n      }\n\n      peekToken (value:string, peek:string, type:string):boolean {\n          return this.tokens[peek] && this.tokens[peek].value === value && this.tokens[peek].type === type\n      }\n\n      /**\n       * @param {string} value\n       * @param {string} [type]\n       * @returns {Token | void}\n       */\n      matchToken(value:string, type:string = 'IDENTIFIER'):Token | undefined {\n          if (this.follows.indexOf(value) !== -1) {\n              return; // disallowed token here\n          }\n          type = type || \"IDENTIFIER\";\n          if (this.currentToken() && this.currentToken().value === value && this.currentToken().type === type) {\n              return this.consumeToken();\n          }\n      }\n\n      /**\n       * @returns {Token}\n       */\n      consumeToken ():Token {\n          var match = this.tokens.shift();\n          this.consumed.push(match);\n          this._lastConsumed = match;\n          this.consumeWhitespace(); // consume any whitespace\n          return match;\n      }\n\n      /**\n       * @param {string | null} value\n       * @param {string | null} [type]\n       * @returns {Token[]}\n       */\n      consumeUntil (value:string | null, type:string | null):Token[] {\n          /** @type Token[] */\n          var tokenList = [];\n          var currentToken = this.token(0, true);\n\n          while (\n              (type == null || currentToken.type !== type) &&\n              (value == null || currentToken.value !== value) &&\n              currentToken.type !== \"EOF\"\n          ) {\n              var match = this.tokens.shift();\n              this.consumed.push(match);\n              tokenList.push(currentToken);\n              currentToken = this.token(0, true);\n          }\n          this.consumeWhitespace(); // consume any whitespace\n          return tokenList;\n      }\n\n      /**\n       * @returns {string}\n       */\n      lastWhitespace ():string {\n          if (this.consumed[this.consumed.length - 1] && this.consumed[this.consumed.length - 1].type === \"WHITESPACE\") {\n              return this.consumed[this.consumed.length - 1].value;\n          } else {\n              return \"\";\n          }\n      }\n\n      consumeUntilWhitespace ():Token[] {\n          return this.consumeUntil(null, \"WHITESPACE\");\n      }\n\n      /**\n       * @returns {boolean}\n       */\n      hasMore ():boolean {\n          return this.tokens.length > 0;\n      }\n\n      /**\n       * @param {number} n\n       * @param {boolean} [dontIgnoreWhitespace]\n       * @returns {Token}\n       */\n      token(n:number, dontIgnoreWhitespace:boolean = false):Token {\n          var /**@type {Token}*/ token;\n          var i = 0;\n          do {\n              if (!dontIgnoreWhitespace) {\n                  while (this.tokens[i] && this.tokens[i].type === \"WHITESPACE\") {\n                      i++;\n                  }\n              }\n              token = this.tokens[i];\n              n--;\n              i++;\n          } while (n > -1);\n          if (token) {\n              return token;\n          } else {\n              return {\n                  type: \"EOF\",\n                  value: \"<<<EOF>>>\",\n              } as Token;\n          }\n      }\n\n      /**\n       * @returns {Token}\n       */\n      currentToken ():Token {\n          return this.token(0);\n      }\n\n      /**\n       * @returns {Token | null}\n       */\n      lastMatch ():Token | null {\n          return this._lastConsumed;\n      }\n\n      /**\n       * @returns {string}\n       */\n      static sourceFor = function ():string {\n          return this.programSource.substring(this.startToken.start, this.endToken.end);\n      }\n\n      /**\n       * @returns {string}\n       */\n      static lineFor = function ():string {\n          return this.programSource.split(\"\\n\")[this.startToken.line - 1];\n      }\n\n      follows = [];\n\n      pushFollow (str):void {\n          this.follows.push(str);\n      }\n\n      popFollow ():void {\n          this.follows.pop();\n      }\n\n      clearFollows ():any[] {\n          var tmp = this.follows;\n          this.follows = [];\n          return tmp;\n      }\n\n      restoreFollows (f:any[]):void {\n          this.follows = f;\n      }\n  }\n\n  /**\n   * @callback ParseRule\n   * @param {Parser} parser\n   * @param {Runtime} runtime\n   * @param {Tokens} tokens\n   * @param {*} [root]\n   * @returns {ASTNode | undefined}\n   */\n\n  type ParseRule = (parser:Parser, runtime:Runtime, tokens:Tokens, root?:any) => ASTNode | undefined\n\n  /**\n   * @typedef {Object} ASTNode\n   * @member {boolean} isFeature\n   * @member {string} type\n   * @member {any[]} args\n   * @member {(this: ASTNode, ctx:Context, root:any, ...args:any) => any} op\n   * @member {(this: ASTNode, context?:Context) => any} evaluate\n   * @member {ASTNode} parent\n   * @member {Set<ASTNode>} children\n   * @member {ASTNode} root\n   * @member {String} keyword\n   * @member {Token} endToken\n   * @member {ASTNode} next\n   * @member {(context:Context) => ASTNode} resolveNext\n   * @member {EventSource} eventSource\n   * @member {(this: ASTNode) => void} install\n   * @member {(this: ASTNode, context:Context) => void} execute\n   * @member {(this: ASTNode, target: object, source: object, args?: Object) => void} apply\n   */\n\n  type ASTNode = {\n    isFeature?:boolean,\n    type?:string, args?:any[],\n    op:(this: ASTNode, ctx:Context, root:any, ...args:any) => any,\n    evaluate?:(this:ASTNode, context?:Context) => any,\n    parent?:ASTNode, children?:Set<ASTNode>, root?:ASTNode,\n    keyword?:string, endToken?:Token,\n    next?:ASTNode, resolveNext?:(context:Context) => ASTNode,\n    eventSource?:EventSource,\n    install?:(this:ASTNode) => void,\n    execute?:(this:ASTNode, context:Context) => void,\n    apply?:(this:ASTNode, target:object, source:object, args?:Object) => void\n  }\n\n  class Parser {\n    public parser:Parser\n    public runtime:Runtime\n    public possessivesDisabled:boolean\n\n      /**\n       *\n       * @param {Runtime} runtime\n       */\n      constructor (runtime:Runtime) {\n          this.runtime = runtime\n\n          this.possessivesDisabled = false\n\n          /* ============================================================================================ */\n          /* Core hyperscript Grammar Elements                                                            */\n          /* ============================================================================================ */\n          this.addGrammarElement(\"feature\", function (parser:Parser, runtime:Runtime, tokens:Tokens):ASTNode {\n              if (tokens.matchOpToken(\"(\")) {\n                  var featureElement = parser.requireElement(\"feature\", tokens);\n                  tokens.requireOpToken(\")\");\n                  return featureElement;\n              }\n\n              var featureDefinition = parser.FEATURES[tokens.currentToken().value || \"\"];\n              if (featureDefinition) {\n                  return featureDefinition(parser, runtime, tokens);\n              }\n          });\n\n          this.addGrammarElement(\"command\", function (parser:Parser, runtime:Runtime, tokens:Tokens):ASTNode {\n              if (tokens.matchOpToken(\"(\")) {\n                  const commandElement = parser.requireElement(\"command\", tokens);\n                  tokens.requireOpToken(\")\");\n                  return commandElement;\n              }\n\n              var commandDefinition = parser.COMMANDS[tokens.currentToken().value || \"\"];\n              let commandElement;\n              if (commandDefinition) {\n                  commandElement = commandDefinition(parser, runtime, tokens);\n              } else if (tokens.currentToken().type === \"IDENTIFIER\") {\n                  commandElement = parser.parseElement(\"pseudoCommand\", tokens);\n              }\n              if (commandElement) {\n                  return parser.parseElement(\"indirectStatement\", tokens, commandElement);\n              }\n\n              return commandElement;\n          });\n\n          this.addGrammarElement(\"commandList\", function (parser:Parser, runtime:Runtime, tokens:Tokens):ASTNode {\n              var cmd = parser.parseElement(\"command\", tokens);\n              if (cmd) {\n                  tokens.matchToken(\"then\");\n                  const next = parser.parseElement(\"commandList\", tokens);\n                  if (next) cmd.next = next;\n                  return cmd;\n              }\n          });\n\n          this.addGrammarElement(\"leaf\", function (parser:Parser, runtime:Runtime, tokens:Tokens):ASTNode {\n              var result = parser.parseAnyOf(parser.LEAF_EXPRESSIONS, tokens);\n              // symbol is last so it doesn't consume any constants\n              if (result == null) {\n                  return parser.parseElement(\"symbol\", tokens);\n              }\n\n              return result;\n          });\n\n          this.addGrammarElement(\"indirectExpression\", function (parser:Parser, runtime:Runtime, tokens:Tokens, root:ASTNode):ASTNode {\n              for (var i = 0; i < parser.INDIRECT_EXPRESSIONS.length; i++) {\n                  var indirect = parser.INDIRECT_EXPRESSIONS[i];\n                  root.endToken = tokens.lastMatch();\n                  var result = parser.parseElement(indirect, tokens, root);\n                  if (result) {\n                      return result;\n                  }\n              }\n              return root;\n          });\n\n          this.addGrammarElement(\"indirectStatement\", function (parser:Parser, runtime:Runtime, tokens:Tokens, root:ASTNode):ASTNode {\n              if (tokens.matchToken(\"unless\")) {\n                  root.endToken = tokens.lastMatch();\n                  var conditional = parser.requireElement(\"expression\", tokens);\n                  var unless = {\n                      type: \"unlessStatementModifier\",\n                      args: [conditional],\n                      op: function (context, conditional) {\n                          if (conditional) {\n                              return this.next;\n                          } else {\n                              return root;\n                          }\n                      },\n                      execute: function (context) {\n                          return runtime.unifiedExec(this, context);\n                      },\n                  };\n                  root.parent = unless;\n                  return unless;\n              }\n              return root;\n          });\n\n          this.addGrammarElement(\"primaryExpression\", function (parser:Parser, runtime:Runtime, tokens:Tokens):ASTNode {\n              var leaf = parser.parseElement(\"leaf\", tokens);\n              if (leaf) {\n                  return parser.parseElement(\"indirectExpression\", tokens, leaf);\n              }\n              parser.raiseParseError(tokens, \"Unexpected value: \" + tokens.currentToken().value);\n          });\n      }\n\n      use (plugin):this {\n          plugin(this)\n          return this\n      }\n\n      /** @type {Object<string,ParseRule>} */\n      GRAMMAR:{ [Key:string]:ParseRule } = {};\n\n      /** @type {Object<string,ParseRule>} */\n      COMMANDS:{ [Key:string]:ParseRule } = {};\n\n      /** @type {Object<string,ParseRule>} */\n      FEATURES:{ [Key:string]:ParseRule } = {};\n\n      /** @type {string[]} */\n      LEAF_EXPRESSIONS:string[] = [];\n      /** @type {string[]} */\n      INDIRECT_EXPRESSIONS:string[] = [];\n\n      /**\n       * @param {*} parseElement\n       * @param {*} start\n       * @param {Tokens} tokens\n       */\n      initElt (parseElement:any, start:any, tokens:Tokens):void {\n          parseElement.startToken = start;\n          parseElement.sourceFor = Tokens.sourceFor;\n          parseElement.lineFor = Tokens.lineFor;\n          parseElement.programSource = tokens.source;\n      }\n\n      /**\n       * @param {string} type\n       * @param {Tokens} tokens\n       * @param {ASTNode?} root\n       * @returns {ASTNode}\n       */\n      parseElement (type:string, tokens:Tokens, root?:ASTNode):ASTNode {\n          var elementDefinition = this.GRAMMAR[type];\n          if (elementDefinition) {\n              var start = tokens.currentToken();\n              var parseElement = elementDefinition(this, this.runtime, tokens, root);\n              if (parseElement) {\n                  this.initElt(parseElement, start, tokens);\n                  parseElement.endToken = parseElement.endToken || tokens.lastMatch();\n                  var root = parseElement.root;\n                  while (root != null) {\n                      this.initElt(root, start, tokens);\n                      root = root.root;\n                  }\n              }\n              return parseElement;\n          }\n      }\n\n      /**\n       * @param {string} type\n       * @param {Tokens} tokens\n       * @param {string} [message]\n       * @param {*} [root]\n       * @returns {ASTNode}\n       */\n      requireElement (type:string, tokens:Tokens, message?:string, root?:any):ASTNode {\n          var result = this.parseElement(type, tokens, root);\n          if (!result) Parser.raiseParseError(tokens, message || \"Expected \" + type);\n          // @ts-ignore\n          return result;\n      }\n\n      /**\n       * @param {string[]} types\n       * @param {Tokens} tokens\n       * @returns {ASTNode}\n       */\n      parseAnyOf (types:string[], tokens:Tokens):ASTNode {\n          for (var i = 0; i < types.length; i++) {\n              var type = types[i];\n              var expression = this.parseElement(type, tokens);\n              if (expression) {\n                  return expression;\n              }\n          }\n      }\n\n      /**\n       * @param {string} name\n       * @param {ParseRule} definition\n       */\n      addGrammarElement (name:string, definition:ParseRule):void {\n          this.GRAMMAR[name] = definition;\n      }\n\n      /**\n       * @param {string} keyword\n       * @param {ParseRule} definition\n       */\n      addCommand (keyword:string, definition:ParseRule):void {\n          var commandGrammarType = keyword + \"Command\";\n          var commandDefinitionWrapper = function (parser, runtime, tokens) {\n              const commandElement = definition(parser, runtime, tokens);\n              if (commandElement) {\n                  commandElement.type = commandGrammarType;\n                  commandElement.execute = function (context) {\n                      context.meta.command = commandElement;\n                      return runtime.unifiedExec(this, context);\n                  };\n                  return commandElement;\n              }\n          };\n          this.GRAMMAR[commandGrammarType] = commandDefinitionWrapper;\n          this.COMMANDS[keyword] = commandDefinitionWrapper;\n      }\n\n      /**\n       * @param {string} keyword\n       * @param {ParseRule} definition\n       */\n      addFeature (keyword:string, definition:ParseRule):void {\n          var featureGrammarType = keyword + \"Feature\";\n\n          /** @type {ParseRule} */\n          var featureDefinitionWrapper = function (parser, runtime, tokens) {\n              var featureElement = definition(parser, runtime, tokens);\n              if (featureElement) {\n                  featureElement.isFeature = true;\n                  featureElement.keyword = keyword;\n                  featureElement.type = featureGrammarType;\n                  return featureElement;\n              }\n          };\n          this.GRAMMAR[featureGrammarType] = featureDefinitionWrapper;\n          this.FEATURES[keyword] = featureDefinitionWrapper;\n      }\n\n      /**\n       * @param {string} name\n       * @param {ParseRule} definition\n       */\n      addLeafExpression (name:string, definition:ParseRule):void {\n          this.LEAF_EXPRESSIONS.push(name);\n          this.addGrammarElement(name, definition);\n      }\n\n      /**\n       * @param {string} name\n       * @param {ParseRule} definition\n       */\n      addIndirectExpression (name:string, definition:ParseRule):void {\n          this.INDIRECT_EXPRESSIONS.push(name);\n          this.addGrammarElement(name, definition);\n      }\n\n      /**\n       *\n       * @param {Tokens} tokens\n       * @returns string\n       */\n      static createParserContext (tokens:Tokens):string {\n          var currentToken = tokens.currentToken();\n          var source = tokens.source;\n          var lines = source.split(\"\\n\");\n          var line = currentToken && currentToken.line ? currentToken.line - 1 : lines.length - 1;\n          var contextLine = lines[line];\n          var offset = /** @type {number} */ (\n              currentToken && currentToken.line ? currentToken.column : contextLine.length - 1);\n          return contextLine + \"\\n\" + \" \".repeat(offset) + \"^^\\n\\n\";\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @param {string} [message]\n       * @returns {never}\n       */\n      static raiseParseError (tokens:Tokens, message?:string):never {\n          message =\n              (message || \"Unexpected Token : \" + tokens.currentToken().value) + \"\\n\\n\" + Parser.createParserContext(tokens);\n          var error = new Error(message);\n          error[\"tokens\"] = tokens;\n          throw error;\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @param {string} [message]\n       */\n      raiseParseError (tokens:Tokens, message?:string):void {\n          Parser.raiseParseError(tokens, message)\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @returns {ASTNode}\n       */\n      parseHyperScript (tokens:Tokens):ASTNode {\n          var result = this.parseElement(\"hyperscript\", tokens);\n          if (tokens.hasMore()) this.raiseParseError(tokens);\n          if (result) return result;\n      }\n\n      /**\n       * @param {ASTNode | undefined} elt\n       * @param {ASTNode} parent\n       */\n      setParent (elt:ASTNode | undefined, parent:ASTNode):void {\n          if (typeof elt === 'object') {\n              elt.parent = parent;\n              if (typeof parent === 'object') {\n                  parent.children = (parent.children || new Set());\n                  parent.children.add(elt)\n              }\n              this.setParent(elt.next, parent);\n          }\n      }\n\n      /**\n       * @param {Token} token\n       * @returns {ParseRule}\n       */\n      commandStart (token:Token):ParseRule {\n          return this.COMMANDS[token.value || \"\"];\n      }\n\n      /**\n       * @param {Token} token\n       * @returns {ParseRule}\n       */\n      featureStart (token:Token):ParseRule {\n          return this.FEATURES[token.value || \"\"];\n      }\n\n      /**\n       * @param {Token} token\n       * @returns {boolean}\n       */\n      commandBoundary (token:Token):boolean {\n          if (\n              token.value == \"end\" ||\n              token.value == \"then\" ||\n              token.value == \"else\" ||\n              token.value == \"otherwise\" ||\n              token.value == \")\" ||\n              this.commandStart(token) ||\n              this.featureStart(token) ||\n              token.type == \"EOF\"\n          ) {\n              return true;\n          }\n          return false;\n      }\n\n      /**\n       * @param {Tokens} tokens\n       * @returns {(string | ASTNode)[]}\n       */\n      parseStringTemplate (tokens:Tokens):(string|ASTNode)[] {\n          /** @type {(string | ASTNode)[]} */\n          var returnArr:(string | ASTNode)[] = [\"\"];\n          do {\n              returnArr.push(tokens.lastWhitespace());\n              if (tokens.currentToken().value === \"$\") {\n                  tokens.consumeToken();\n                  var startingBrace = tokens.matchOpToken(\"{\");\n                  returnArr.push(this.requireElement(\"expression\", tokens));\n                  if (startingBrace) {\n                      tokens.requireOpToken(\"}\");\n                  }\n                  returnArr.push(\"\");\n              } else if (tokens.currentToken().value === \"\\\\\") {\n                  tokens.consumeToken(); // skip next\n                  tokens.consumeToken();\n              } else {\n                  var token = tokens.consumeToken();\n                  returnArr[returnArr.length - 1] += token ? token.value : \"\";\n              }\n          } while (tokens.hasMore());\n          returnArr.push(tokens.lastWhitespace());\n          return returnArr;\n      }\n\n      /**\n       * @param {ASTNode} commandList\n       */\n      ensureTerminated (commandList:ASTNode):void {\n          const runtime = this.runtime\n          var implicitReturn = {\n              type: \"implicitReturn\",\n              op: function (context) {\n                  context.meta.returned = true;\n                  if (context.meta.resolve) {\n                      context.meta.resolve();\n                  }\n                  return runtime.HALT;\n              },\n              execute: function (ctx) {\n                  // do nothing\n              },\n          };\n\n          var end = commandList;\n          while (end.next) {\n              end = end.next;\n          }\n          end.next = implicitReturn;\n      }\n  }\n\n/**\n * @typedef {{queue:Array, executing:boolean}} EventQueue\n */\n\n  type EventQueue = { queue:any[], executing:boolean }\n\n  class Runtime {\n    public lexer:Lexer\n    public parser:Parser\n\n      /**\n       *\n       * @param {Lexer} [lexer]\n       * @param {Parser} [parser]\n       */\n      constructor(lexer?:Lexer, parser?:Parser) {\n          this.lexer = lexer ?? new Lexer;\n          this.parser = parser ?? new Parser(this)\n              .use(hyperscriptCoreGrammar)\n              .use(hyperscriptWebGrammar);\n          this.parser.runtime = this\n      }\n\n      /**\n       * @param {HTMLElement} elt\n       * @param {string} selector\n       * @returns boolean\n       */\n      matchesSelector(elt:HTMLElement, selector:string):boolean {\n          // noinspection JSUnresolvedVariable\n          var matchesFunction =\n              // @ts-ignore\n              elt.matches || elt.matchesSelector || elt.msMatchesSelector || elt.mozMatchesSelector || elt.webkitMatchesSelector || elt.oMatchesSelector;\n          return matchesFunction && matchesFunction.call(elt, selector);\n      }\n\n      /**\n       * @param {string} eventName\n       * @param {Object} [detail]\n       * @returns {Event}\n       */\n      makeEvent(eventName:string, detail?:object):Event {\n          var evt;\n          if (globalScope.Event && typeof globalScope.Event === \"function\") {\n              evt = new Event(eventName, {\n                  bubbles: true,\n                  cancelable: true,\n              });\n              evt['detail'] = detail;\n          } else {\n              evt = document.createEvent(\"CustomEvent\");\n              evt.initCustomEvent(eventName, true, true, detail);\n          }\n          return evt;\n      }\n\n      /**\n       * @param {Element} elt\n       * @param {string} eventName\n       * @param {Object} [detail]\n       * @param {Element} [sender]\n       * @returns {boolean}\n       */\n      triggerEvent(elt:Element, eventName:string, detail?:object, sender?:Element):boolean {\n          detail = detail || {};\n          detail[\"sender\"] = sender;\n          var event = this.makeEvent(eventName, detail);\n          var eventResult = elt.dispatchEvent(event);\n          return eventResult;\n      }\n\n      /**\n       * isArrayLike returns `true` if the provided value is an array or\n       * a NodeList (which is close enough to being an array for our purposes).\n       *\n       * @param {any} value\n       * @returns {value is Array | NodeList}\n       */\n      isArrayLike (value:any):boolean {\n          return Array.isArray(value) ||\n              (typeof NodeList !== 'undefined' && (value instanceof NodeList || value instanceof HTMLCollection));\n      }\n\n      /**\n       * isIterable returns `true` if the provided value supports the\n       * iterator protocol.\n       *\n       * @param {any} value\n       * @returns {value is Iterable}\n       */\n      isIterable (value:any):boolean {\n          return typeof value === 'object'\n              && Symbol.iterator in value\n              && typeof value[Symbol.iterator] === 'function';\n      }\n\n      /**\n       * shouldAutoIterate returns `true` if the provided value\n       * should be implicitly iterated over when accessing properties,\n       * and as the target of some commands.\n       *\n       * Currently, this is when the value is an {ElementCollection}\n       * or {isArrayLike} returns true.\n       *\n       * @param {any} value\n       * @returns {value is (any[] | ElementCollection)}\n       */\n      shouldAutoIterate (value:any):boolean {\n          return value != null && value[shouldAutoIterateSymbol] ||\n              this.isArrayLike(value);\n      }\n\n      /**\n       * forEach executes the provided `func` on every item in the `value` array.\n       * if `value` is a single item (and not an array) then `func` is simply called\n       * once.  If `value` is null, then no further actions are taken.\n       *\n       * @template T\n       * @param {T | Iterable<T>} value\n       * @param {(item: T) => void} func\n       */\n      forEach (value:any, func:any):void {\n          if (value == null) {\n              // do nothing\n          } else if (this.isIterable(value)) {\n              for (const nth of value) {\n                  func(nth);\n              }\n          } else if (this.isArrayLike(value)) {\n              for (var i = 0; i < value.length; i++) {\n                  func(value[i]);\n              }\n          } else {\n              func(value);\n          }\n      }\n\n      /**\n       * implicitLoop executes the provided `func` on:\n       * - every item of {value}, if {value} should be auto-iterated\n       *   (see {shouldAutoIterate})\n       * - {value} otherwise\n       *\n       * @template T\n       * @param {ElementCollection | T | T[]} value\n       * @param {(item: T) => void} func\n       */\n      implicitLoop (value:any, func:any):void {\n          if (this.shouldAutoIterate(value)) {\n              for (const x of value) func(x);\n          } else {\n              func(value);\n          }\n      }\n\n      wrapArrays (args:any[]):any[] {\n          var arr = [];\n          for (var i = 0; i < args.length; i++) {\n              var arg = args[i];\n              if (Array.isArray(arg)) {\n                  arr.push(Promise.all(arg));\n              } else {\n                  arr.push(arg);\n              }\n          }\n          return arr;\n      }\n\n      unwrapAsyncs (values:any[]):void {\n          for (var i = 0; i < values.length; i++) {\n              var value = values[i];\n              if (value.asyncWrapper) {\n                  values[i] = value.value;\n              }\n              if (Array.isArray(value)) {\n                  for (var j = 0; j < value.length; j++) {\n                      var valueElement = value[j];\n                      if (valueElement.asyncWrapper) {\n                          value[j] = valueElement.value;\n                      }\n                  }\n              }\n          }\n      }\n\n      static HALT:{} = {};\n      HALT = Runtime.HALT;\n\n      /**\n       * @param {ASTNode} command\n       * @param {Context} ctx\n       */\n      unifiedExec (command:ASTNode, ctx:Context):void {\n          while (true) {\n              try {\n                  var next = this.unifiedEval(command, ctx);\n              } catch (e) {\n                  if (ctx.meta.handlingFinally) {\n                      console.error(\" Exception in finally block: \", e);\n                      next = Runtime.HALT;\n                  } else {\n                      this.registerHyperTrace(ctx, e);\n                      if (ctx.meta.errorHandler && !ctx.meta.handlingError) {\n                          ctx.meta.handlingError = true;\n                          ctx.locals[ctx.meta.errorSymbol] = e;\n                          command = ctx.meta.errorHandler;\n                          continue;\n                      } else  {\n                          ctx.meta.currentException = e;\n                          next = Runtime.HALT;\n                      }\n                  }\n              }\n              if (next == null) {\n                  console.error(command, \" did not return a next element to execute! context: \", ctx);\n                  return;\n              } else if (next.then) {\n                  next.then(resolvedNext => {\n                      this.unifiedExec(resolvedNext, ctx);\n                  }).catch(reason => {\n                      this.unifiedExec({ // Anonymous command to simply throw the exception\n                          op: function(){\n                              throw reason;\n                          }\n                      }, ctx);\n                  });\n                  return;\n              } else if (next === Runtime.HALT) {\n                  if (ctx.meta.finallyHandler && !ctx.meta.handlingFinally) {\n                      ctx.meta.handlingFinally = true;\n                      command = ctx.meta.finallyHandler;\n                  } else {\n                      if (ctx.meta.onHalt) {\n                          ctx.meta.onHalt();\n                      }\n                      if (ctx.meta.currentException) {\n                          if (ctx.meta.reject) {\n                              ctx.meta.reject(ctx.meta.currentException);\n                              return;\n                          } else {\n                              throw ctx.meta.currentException;\n                          }\n                      } else {\n                          return;\n                      }\n                  }\n              } else {\n                  command = next; // move to the next command\n              }\n          }\n      }\n\n      /**\n      * @param {*} parseElement\n      * @param {Context} ctx\n      * @returns {*}\n      */\n      unifiedEval(parseElement:any, ctx:Context):any {\n          /** @type any[] */\n          var args:any[] = [ctx];\n          var async:boolean = false;\n          var wrappedAsyncs:boolean = false;\n\n          if (parseElement.args) {\n              for (var i = 0; i < parseElement.args.length; i++) {\n                  var argument = parseElement.args[i];\n                  if (argument == null) {\n                      args.push(null);\n                  } else if (Array.isArray(argument)) {\n                      var arr = [];\n                      for (var j = 0; j < argument.length; j++) {\n                          var element = argument[j];\n                          var value = element ? element.evaluate(ctx) : null; // OK\n                          if (value) {\n                              if (value.then) {\n                                  async = true;\n                              } else if (value.asyncWrapper) {\n                                  wrappedAsyncs = true;\n                              }\n                          }\n                          arr.push(value);\n                      }\n                      args.push(arr);\n                  } else if (argument.evaluate) {\n                      var value = argument.evaluate(ctx); // OK\n                      if (value) {\n                          if (value.then) {\n                              async = true;\n                          } else if (value.asyncWrapper) {\n                              wrappedAsyncs = true;\n                          }\n                      }\n                      args.push(value);\n                  } else {\n                      args.push(argument);\n                  }\n              }\n          }\n          if (async) {\n              return new Promise((resolve, reject) => {\n                  args = this.wrapArrays(args);\n                  Promise.all(args)\n                      .then(function (values) {\n                          if (wrappedAsyncs) {\n                              this.unwrapAsyncs(values);\n                          }\n                          try {\n                              var apply = parseElement.op.apply(parseElement, values);\n                              resolve(apply);\n                          } catch (e) {\n                              reject(e);\n                          }\n                      })\n                      .catch(function (reason) {\n                          reject(reason);\n                      });\n              });\n          } else {\n              if (wrappedAsyncs) {\n                  this.unwrapAsyncs(args);\n              }\n              return parseElement.op.apply(parseElement, args);\n          }\n      }\n\n      /**\n       * @type {string[] | null}\n       */\n      _scriptAttrs:string[] | null = null;\n\n      /**\n      * getAttributes returns the attribute name(s) to use when\n      * locating hyperscript scripts in a DOM element.  If no value\n      * has been configured, it defaults to config.attributes\n      * @returns string[]\n      */\n      getScriptAttributes ():string[] {\n          if (this._scriptAttrs == null) {\n              this._scriptAttrs = config.attributes.replace(/ /g, \"\").split(\",\");\n          }\n          return this._scriptAttrs;\n      }\n\n      /**\n      * @param {Element} elt\n      * @returns {string | null}\n      */\n      getScript (elt:Element):string | null {\n          for (var i = 0; i < this.getScriptAttributes().length; i++) {\n              var scriptAttribute = this.getScriptAttributes()[i];\n              if (elt.hasAttribute && elt.hasAttribute(scriptAttribute)) {\n                  return elt.getAttribute(scriptAttribute);\n              }\n          }\n          if (elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\") {\n              return elt.innerText;\n          }\n          return null;\n      }\n\n      hyperscriptFeaturesMap = new WeakMap\n\n      /**\n      * @param {*} elt\n      * @returns {Object}\n      */\n      getHyperscriptFeatures (elt:any):Object {\n          var hyperscriptFeatures = this.hyperscriptFeaturesMap.get(elt);\n          if (typeof hyperscriptFeatures === 'undefined') {\n              if (elt) {\n                  // in some rare cases, elt is null and this line crashes\n                  this.hyperscriptFeaturesMap.set(elt, hyperscriptFeatures = {});\n              }\n          }\n          return hyperscriptFeatures;\n      }\n\n      /**\n      * @param {Element} owner\n      * @param {Context} ctx\n      */\n      addFeatures(owner:Element, ctx:Context):void {\n          if (owner) {\n              Object.assign(ctx.locals, this.getHyperscriptFeatures(owner));\n              this.addFeatures(owner.parentElement, ctx);\n          }\n      }\n\n      /**\n      * @param {*} owner\n      * @param {*} feature\n      * @param {*} hyperscriptTarget\n      * @param {*} event\n      * @returns {Context}\n      */\n      makeContext (owner:any, feature:any, hyperscriptTarget:any, event:any):Context {\n          return new Context(owner, feature, hyperscriptTarget, event, this)\n      }\n\n      /**\n      * @returns string\n      */\n      getScriptSelector ():string {\n          return this.getScriptAttributes()\n              .map(function (attribute) {\n                  return \"[\" + attribute + \"]\";\n              })\n              .join(\", \");\n      }\n\n      /**\n      * @param {any} value\n      * @param {string} type\n      * @returns {any}\n      */\n      convertValue (value:any, type:string):any {\n          var dynamicResolvers = conversions.dynamicResolvers;\n          for (var i = 0; i < dynamicResolvers.length; i++) {\n              var dynamicResolver = dynamicResolvers[i];\n              var converted = dynamicResolver(type, value);\n              if (converted !== undefined) {\n                  return converted;\n              }\n          }\n\n          if (value == null) {\n              return null;\n          }\n          var converter = conversions[type];\n          if (converter) {\n              return converter(value);\n          }\n\n          throw \"Unknown conversion : \" + type;\n      }\n\n      /**\n      * @param {string} src\n      * @returns {ASTNode}\n      */\n      parse (src:string):ASTNode {\n          const lexer = this.lexer, parser = this.parser\n          var tokens = lexer.tokenize(src);\n          if (this.parser.commandStart(tokens.currentToken())) {\n              var commandList = parser.requireElement(\"commandList\", tokens);\n              if (tokens.hasMore()) parser.raiseParseError(tokens);\n              parser.ensureTerminated(commandList);\n              return commandList;\n          } else if (parser.featureStart(tokens.currentToken())) {\n              var hyperscript = parser.requireElement(\"hyperscript\", tokens);\n              if (tokens.hasMore()) parser.raiseParseError(tokens);\n              return hyperscript;\n          } else {\n              var expression = parser.requireElement(\"expression\", tokens);\n              if (tokens.hasMore()) parser.raiseParseError(tokens);\n              return expression;\n          }\n      }\n\n      /**\n       *\n       * @param {ASTNode} elt\n       * @param {Context} ctx\n       * @returns {any}\n       */\n      evaluateNoPromise (elt:ASTNode, ctx:Context):any {\n          let result = elt.evaluate(ctx);\n          if (result.next) {\n              throw new Error(Tokens.sourceFor.call(elt) + \" returned a Promise in a context that they are not allowed.\");\n          }\n          return result;\n      }\n\n      /**\n      * @param {string} src\n      * @param {Partial<Context>} [ctx]\n      * @param {Object} [args]\n      * @returns {any}\n      */\n      evaluate (src:string, ctx?:Context, args?:any):any {\n          class HyperscriptModule extends EventTarget {\n            public module:any \n\n              constructor (mod) {\n                  super();\n                  this.module = mod;\n              }\n              toString ():string {\n                  return this.module.id;\n              }\n          }\n\n          var body = 'document' in globalScope\n              ? globalScope.document.body\n              : new HyperscriptModule(args && args.module);\n          ctx = Object.assign(this.makeContext(body, null, body, null), ctx || {});\n          var element = this.parse(src);\n          if (element.execute) {\n              element.execute(ctx);\n              return ctx.result;\n          } else if (element.apply) {\n              element.apply(body, body, args);\n              return this.getHyperscriptFeatures(body);\n          } else {\n              return element.evaluate(ctx);\n          }\n      }\n\n      /**\n      * @param {HTMLElement} elt\n      */\n      processNode (elt:HTMLElement):void {\n          var selector = this.getScriptSelector();\n          if (this.matchesSelector(elt, selector)) {\n              this.initElement(elt, elt);\n          }\n          if (elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\") {\n              this.initElement(elt, document.body);\n          }\n          if (elt.querySelectorAll) {\n              this.forEach(elt.querySelectorAll(selector + \", [type='text/hyperscript']\"), elt => {\n                  this.initElement(elt, elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\" ? document.body : elt);\n              });\n          }\n      }\n\n      /**\n      * @param {Element} elt\n      * @param {Element} [target]\n      */\n      initElement (elt:Element, target:Element):void {\n          if (elt.closest && elt.closest(config.disableSelector)) {\n              return;\n          }\n          var internalData = this.getInternalData(elt);\n          if (!internalData.initialized) {\n              var src = this.getScript(elt);\n              if (src) {\n                  try {\n                      internalData.initialized = true;\n                      internalData.script = src;\n                      const lexer = this.lexer, parser = this.parser\n                      var tokens = lexer.tokenize(src);\n                      var hyperScript = parser.parseHyperScript(tokens);\n                      if (!hyperScript) return;\n                      hyperScript.apply(target || elt, elt);\n                      setTimeout(() => {\n                          this.triggerEvent(target || elt, \"load\", {\n                              hyperscript: true,\n                          });\n                      }, 1);\n                  } catch (e) {\n                      this.triggerEvent(elt, \"exception\", {\n                          error: e,\n                      });\n                      console.error(\n                          \"hyperscript errors were found on the following element:\",\n                          elt,\n                          \"\\n\\n\",\n                          e.message,\n                          e.stack\n                      );\n                  }\n              }\n          }\n      }\n\n      internalDataMap = new WeakMap\n\n      /**\n      * @param {Element} elt\n      * @returns {Object}\n      */\n      getInternalData (elt:Element):any {\n          var internalData = this.internalDataMap.get(elt);\n          if (typeof internalData === 'undefined') {\n              this.internalDataMap.set(elt, internalData = {});\n          }\n          return internalData;\n      }\n\n      /**\n      * @param {any} value\n      * @param {string} typeString\n      * @param {boolean} [nullOk]\n      * @returns {boolean}\n      */\n      typeCheck (value:any, typeString:string, nullOk:boolean):boolean {\n          if (value == null && nullOk) {\n              return true;\n          }\n          var typeName = Object.prototype.toString.call(value).slice(8, -1);\n          return typeName === typeString;\n      }\n\n      getElementScope (context:Context):any {\n          var elt = context.meta && context.meta.owner;\n          if (elt) {\n              var internalData = this.getInternalData(elt);\n              var scopeName = \"elementScope\";\n              if (context.meta.feature && context.meta.feature.behavior) {\n                  scopeName = context.meta.feature.behavior + \"Scope\";\n              }\n              var elementScope = getOrInitObject(internalData, scopeName);\n              return elementScope;\n          } else {\n              return {}; // no element, return empty scope\n          }\n      }\n\n      /**\n      * @param {string} str\n      * @returns {boolean}\n      */\n      isReservedWord (str:string):boolean {\n          return [\"meta\", \"it\", \"result\", \"locals\", \"event\", \"target\", \"detail\", \"sender\", \"body\"].includes(str)\n      }\n\n      /**\n      * @param {any} context\n      * @returns {boolean}\n      */\n      isHyperscriptContext (context:any):boolean {\n          return context instanceof Context;\n      }\n\n      /**\n      * @param {string} str\n      * @param {Context} context\n      * @returns {any}\n      */\n      resolveSymbol (str:string, context:Context, type:string):any {\n          if (str === \"me\" || str === \"my\" || str === \"I\") {\n              return context.me;\n          }\n          if (str === \"it\" || str === \"its\" || str === \"result\") {\n              return context.result;\n          }\n          if (str === \"you\" || str === \"your\" || str === \"yourself\") {\n              return context.you;\n          } else {\n              if (type === \"global\") {\n                  return globalScope[str];\n              } else if (type === \"element\") {\n                  var elementScope = this.getElementScope(context);\n                  return elementScope[str];\n              } else if (type === \"local\") {\n                  return context.locals[str];\n              } else {\n                  // meta scope (used for event conditionals)\n                  if (context.meta && context.meta.context) {\n                      var fromMetaContext = context.meta.context[str];\n                      if (typeof fromMetaContext !== \"undefined\") {\n                          return fromMetaContext;\n                      }\n                  }\n                  if (this.isHyperscriptContext(context) && !this.isReservedWord(str)) {\n                      // local scope\n                      var fromContext = context.locals[str];\n                  } else {\n                      // direct get from normal JS object or top-level of context\n                      var fromContext = context[str];\n                  }\n                  if (typeof fromContext !== \"undefined\") {\n                      return fromContext;\n                  } else {\n                      // element scope\n                      var elementScope = this.getElementScope(context);\n                      fromContext = elementScope[str];\n                      if (typeof fromContext !== \"undefined\") {\n                          return fromContext;\n                      } else {\n                          // global scope\n                          return globalScope[str];\n                      }\n                  }\n              }\n          }\n      }\n\n      setSymbol (str:string, context:Context, type:string, value:any):void {\n          if (type === \"global\") {\n              globalScope[str] = value;\n          } else if (type === \"element\") {\n              var elementScope = this.getElementScope(context);\n              elementScope[str] = value;\n          } else if (type === \"local\") {\n              context.locals[str] = value;\n          } else {\n              if (this.isHyperscriptContext(context) && !this.isReservedWord(str) && typeof context.locals[str] !== \"undefined\") {\n                  // local scope\n                  context.locals[str] = value;\n              } else {\n                  // element scope\n                  var elementScope = this.getElementScope(context);\n                  var fromContext = elementScope[str];\n                  if (typeof fromContext !== \"undefined\") {\n                      elementScope[str] = value;\n                  } else {\n                      if (this.isHyperscriptContext(context) && !this.isReservedWord(str)) {\n                          // local scope\n                          context.locals[str] = value;\n                      } else {\n                          // direct set on normal JS object or top-level of context\n                          context[str] = value;\n                      }\n                  }\n              }\n          }\n      }\n\n      /**\n      * @param {ASTNode} command\n      * @param {Context} context\n      * @returns {undefined | ASTNode}\n      */\n      findNext (command:ASTNode, context:Context):undefined | ASTNode {\n          if (command) {\n              if (command.resolveNext) {\n                  return command.resolveNext(context);\n              } else if (command.next) {\n                  return command.next;\n              } else {\n                  return this.findNext(command.parent, context);\n              }\n          }\n      }\n\n      /**\n      * @param {Object<string,any>} root\n      * @param {string} property\n      * @param {Getter} getter\n      * @returns {any}\n      *\n      * @callback Getter\n      * @param {Object<string,any>} root\n      * @param {string} property\n      */\n      flatGet (root:any, property:string, getter:(root:any,property:string) => any):any {\n          if (root != null) {\n              var val = getter(root, property);\n              if (typeof val !== \"undefined\") {\n                  return val;\n              }\n\n              if (this.shouldAutoIterate(root)) {\n                  // flat map\n                  var result = [];\n                  for (var component of root) {\n                      var componentValue = getter(component, property);\n                      result.push(componentValue);\n                  }\n                  return result;\n              }\n          }\n      }\n\n      resolveProperty (root:Element, property:string):any {\n          return this.flatGet(root, property, (root, property) => root[property] )\n      }\n\n      resolveAttribute (root:Element, property:string):any {\n          return this.flatGet(root, property, (root, property) => root.getAttribute && root.getAttribute(property) )\n      }\n\n      /**\n       *\n       * @param {Object<string, any>} root\n       * @param {string} property\n       * @returns {string}\n       */\n      resolveStyle (root:Element, property:string):string {\n          return this.flatGet(root, property, (root, property) => root.style && root.style[property] )\n      }\n\n      /**\n       *\n       * @param {Object<string, any>} root\n       * @param {string} property\n       * @returns {string}\n       */\n      resolveComputedStyle (root:Element, property:string):string {\n          return this.flatGet(root, property, (root, property) => getComputedStyle(\n              /** @type {Element} */ (root)).getPropertyValue(property) )\n      }\n\n      /**\n      * @param {Element} elt\n      * @param {string[]} nameSpace\n      * @param {string} name\n      * @param {any} value\n      */\n      assignToNamespace (elt:Element, nameSpace:string[], name:string, value:any):void {\n          let root\n          if (typeof document !== \"undefined\" && elt === document.body) {\n              root = globalScope;\n          } else {\n              root = this.getHyperscriptFeatures(elt);\n          }\n          var propertyName:string;\n          while ((propertyName = nameSpace.shift()) !== undefined) {\n              var newRoot = root[propertyName];\n              if (newRoot == null) {\n                  newRoot = {};\n                  root[propertyName] = newRoot;\n              }\n              root = newRoot;\n          }\n\n          root[name] = value;\n      }\n\n      getHyperTrace (ctx:Context, thrown:any):any {\n          var trace:any[] = [];\n          var root:Context = ctx;\n          while (root.meta.caller) {\n              root = root.meta.caller;\n          }\n          if (root.meta.traceMap) {\n              return root.meta.traceMap.get(thrown, trace);\n          }\n      }\n\n      registerHyperTrace (ctx:Context, thrown:any):void {\n          var trace:any[] = [];\n          var root:Context = null;\n          while (ctx != null) {\n              trace.push(ctx);\n              root = ctx;\n              ctx = ctx.meta.caller;\n          }\n          if (root.meta.traceMap == null) {\n              root.meta.traceMap = new Map(); // TODO - WeakMap?\n          }\n          if (!root.meta.traceMap.get(thrown)) {\n              var traceEntry = {\n                  trace: trace,\n                  print: function (logger) {\n                      logger = logger || console.error;\n                      logger(\"hypertrace /// \");\n                      var maxLen = 0;\n                      for (var i = 0; i < trace.length; i++) {\n                          maxLen = Math.max(maxLen, trace[i].meta.feature.displayName.length);\n                      }\n                      for (var i = 0; i < trace.length; i++) {\n                          var traceElt = trace[i];\n                          logger(\n                              \"  ->\",\n                              traceElt.meta.feature.displayName.padEnd(maxLen + 2),\n                              \"-\",\n                              traceElt.meta.owner\n                          );\n                      }\n                  },\n              };\n              root.meta.traceMap.set(thrown, traceEntry);\n          }\n      }\n\n      /**\n      * @param {string} str\n      * @returns {string}\n      */\n      escapeSelector (str:string):string {\n          return str.replace(/:/g, function (str) {\n              return \"\\\\\" + str;\n          });\n      }\n\n      /**\n      * @param {any} value\n      * @param {*} elt\n      */\n      nullCheck (value:any, elt:any):void {\n          if (value == null) {\n              throw new Error(\"'\" + elt.sourceFor() + \"' is null\");\n          }\n      }\n\n      /**\n      * @param {any} value\n      * @returns {boolean}\n      */\n      isEmpty (value:any):boolean {\n          return value == undefined || value.length === 0;\n      }\n\n      /**\n      * @param {any} value\n      * @returns {boolean}\n      */\n      doesExist (value:any):boolean {\n          if(value == null){\n              return false;\n          }\n          if (this.shouldAutoIterate(value)) {\n              for (const elt of value) {\n                  return true;\n              }\n          }\n          return false;\n      }\n\n      /**\n      * @param {Node} node\n      * @returns {Document|ShadowRoot}\n      */\n      getRootNode (node:Node):Document|ShadowRoot {\n          if (node && node instanceof Node) {\n              var rv = node.getRootNode();\n              if (rv instanceof Document || rv instanceof ShadowRoot) return rv;\n          }\n          return document;\n      }\n\n      /**\n       *\n       * @param {Element} elt\n       * @param {ASTNode} onFeature\n       * @returns {EventQueue}\n       */\n      getEventQueueFor (elt:Element, onFeature:ASTNode):EventQueue {\n          let internalData = this.getInternalData(elt);\n          var eventQueuesForElt = internalData.eventQueues;\n          if (eventQueuesForElt == null) {\n              eventQueuesForElt = new Map();\n              internalData.eventQueues = eventQueuesForElt;\n          }\n          var eventQueueForFeature = eventQueuesForElt.get(onFeature);\n          if (eventQueueForFeature == null) {\n              eventQueueForFeature = {queue:[], executing:false};\n              eventQueuesForElt.set(onFeature, eventQueueForFeature);\n          }\n          return eventQueueForFeature;\n      }\n\n      /** @type string | null */\n      \n      hyperscriptUrl:string|null = \"document\" in globalScope ? document.currentScript['src'] : null;\n  }\n\n  class Context {\n    public meta:any\n    public locals:Object\n    public me:any\n    public you:any \n    public result:any \n    public event:Event\n    public target:EventTarget\n    public detail:any\n    public sender:any\n    public body:HTMLElement | null\n\n      /**\n      * @param {*} owner\n      * @param {*} feature\n      * @param {*} hyperscriptTarget\n      * @param {*} event\n      */\n      constructor (owner:any, feature:any, hyperscriptTarget:any, event:Event, runtime:Runtime) {\n          this.meta = {\n              parser: runtime.parser,\n              lexer: runtime.lexer,\n              runtime,\n              owner: owner,\n              feature: feature,\n              iterators: {},\n              ctx: this\n          }\n          this.locals = {};\n          this.me = hyperscriptTarget,\n          this.you = undefined\n          this.result = undefined\n          this.event = event;\n          this.target = event ? event.target : null;\n          this.detail = event ? event['detail'] : null;\n          this.sender = event ? event['detail'] ? event['detail'].sender : null : null;\n          this.body = \"document\" in globalScope ? document.body : null;\n          runtime.addFeatures(owner, this);\n      }\n  }\n\n  class ElementCollection {\n    public _css:string\n    public relativeToElement:Element\n    public escape:any\n\n      constructor (css:string, relativeToElement:Element, escape?:any) {\n          this._css = css;\n          this.relativeToElement = relativeToElement;\n          this.escape = escape;\n          this[shouldAutoIterateSymbol] = true;\n      }\n\n      get css () {\n          if (this.escape) {\n              return Runtime.prototype.escapeSelector(this._css);\n          } else {\n              return this._css;\n          }\n      }\n\n      get className () {\n          return this._css.substr(1);\n      }\n\n      contains (elt) {\n          for (let element of this) {\n              if (element.contains(elt)) {\n                  return true;\n              }\n          }\n          return false;\n      }\n\n      get length () {\n          return this.selectMatches().length;\n      }\n\n      [Symbol.iterator]() {\n          let query = this.selectMatches();\n          return query [Symbol.iterator]();\n      }\n\n      selectMatches () {\n          let query = Runtime.prototype.getRootNode(this.relativeToElement).querySelectorAll(this.css);\n          return query;\n      }\n  }\n\n  const shouldAutoIterateSymbol = Symbol()\n\n  function getOrInitObject (root:any, prop:any):any {\n      var value = root[prop];\n      if (value) {\n          return value;\n      } else {\n          var newObj = {};\n          root[prop] = newObj;\n          return newObj;\n      }\n  }\n\n  /**\n   * parseJSON parses a JSON string into a corresponding value.  If the\n   * value passed in is not valid JSON, then it logs an error and returns `null`.\n   *\n   * @param {string} jString\n   * @returns any\n   */\n  function parseJSON (jString:string):any {\n      try {\n          return JSON.parse(jString);\n      } catch (error) {\n          logError(error);\n          return null;\n      }\n  }\n\n  /**\n   * logError writes an error message to the Javascript console.  It can take any\n   * value, but msg should commonly be a simple string.\n   * @param {*} msg\n   */\n  function logError (msg:any):void {\n      if (console.error) {\n          console.error(msg);\n      } else if (console.log) {\n          console.log(\"ERROR: \", msg);\n      }\n  }\n\n  // TODO: JSDoc description of what's happening here\n  function varargConstructor (Cls:any, args:any[]):any {\n      return new (Cls.bind.apply(Cls, [Cls].concat(args)))();\n  }\n\n  // Grammar\n\n  /**\n   * @param {Parser} parser\n   */\n  function hyperscriptCoreGrammar (parser):void {\n      parser.addLeafExpression(\"parenthesized\", function (parser, _runtime, tokens) {\n          if (tokens.matchOpToken(\"(\")) {\n              var follows = tokens.clearFollows();\n              try {\n                  var expr = parser.requireElement(\"expression\", tokens);\n              } finally {\n                  tokens.restoreFollows(follows);\n              }\n              tokens.requireOpToken(\")\");\n              return expr;\n          }\n      });\n\n      parser.addLeafExpression(\"string\", function (parser, runtime, tokens) {\n          var stringToken = tokens.matchTokenType(\"STRING\");\n          if (!stringToken) return;\n          var rawValue = /** @type {string} */ (stringToken.value);\n          /** @type {any[]} */\n          var args;\n          if (stringToken.template) {\n              var innerTokens = Lexer.tokenize(rawValue, true);\n              args = parser.parseStringTemplate(innerTokens);\n          } else {\n              args = [];\n          }\n          return {\n              type: \"string\",\n              token: stringToken,\n              args: args,\n              op: function (context) {\n                  var returnStr = \"\";\n                  for (var i = 1; i < arguments.length; i++) {\n                      var val = arguments[i];\n                      if (val !== undefined) {\n                          returnStr += val;\n                      }\n                  }\n                  return returnStr;\n              },\n              evaluate: function (context) {\n                  if (args.length === 0) {\n                      return rawValue;\n                  } else {\n                      return runtime.unifiedEval(this, context);\n                  }\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"nakedString\", function (parser, runtime, tokens) {\n          if (tokens.hasMore()) {\n              var tokenArr = tokens.consumeUntilWhitespace();\n              tokens.matchTokenType(\"WHITESPACE\");\n              return {\n                  type: \"nakedString\",\n                  tokens: tokenArr,\n                  evaluate: function (context) {\n                      return tokenArr\n                          .map(function (t) {\n                              return t.value;\n                          })\n                          .join(\"\");\n                  },\n              };\n          }\n      });\n\n      parser.addLeafExpression(\"number\", function (parser, runtime, tokens) {\n          var number = tokens.matchTokenType(\"NUMBER\");\n          if (!number) return;\n          var numberToken = number;\n          var value = parseFloat(/** @type {string} */ (number.value));\n          return {\n              type: \"number\",\n              value: value,\n              numberToken: numberToken,\n              evaluate: function () {\n                  return value;\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"idRef\", function (parser, runtime, tokens) {\n          var elementId = tokens.matchTokenType(\"ID_REF\");\n          if (!elementId) return;\n          if (!elementId.value) return;\n          // TODO - unify these two expression types\n          if (elementId.template) {\n              var templateValue = elementId.value.substring(2);\n              var innerTokens = Lexer.tokenize(templateValue);\n              var innerExpression = parser.requireElement(\"expression\", innerTokens);\n              return {\n                  type: \"idRefTemplate\",\n                  args: [innerExpression],\n                  op: function (context, arg) {\n                      return runtime.getRootNode(context.me).getElementById(arg);\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              const value = elementId.value.substring(1);\n              return {\n                  type: \"idRef\",\n                  css: elementId.value,\n                  value: value,\n                  evaluate: function (context) {\n                      return (\n                          runtime.getRootNode(context.me).getElementById(value)\n                      );\n                  },\n              };\n          }\n      });\n\n      parser.addLeafExpression(\"classRef\", function (parser, runtime, tokens) {\n          var classRef = tokens.matchTokenType(\"CLASS_REF\");\n\n          if (!classRef) return;\n          if (!classRef.value) return;\n\n          // TODO - unify these two expression types\n          if (classRef.template) {\n              var templateValue = classRef.value.substring(2);\n              var innerTokens = Lexer.tokenize(templateValue);\n              var innerExpression = parser.requireElement(\"expression\", innerTokens);\n              return {\n                  type: \"classRefTemplate\",\n                  args: [innerExpression],\n                  op: function (context, arg) {\n                      return new ElementCollection(\".\" + arg, context.me, true)\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              const css = classRef.value;\n              return {\n                  type: \"classRef\",\n                  css: css,\n                  evaluate: function (context) {\n                      return new ElementCollection(css, context.me, true)\n                  },\n              };\n          }\n      });\n\n      class TemplatedQueryElementCollection extends ElementCollection {\n        public templateParts:any[]\n        public elements:any[]\n\n          constructor(css, relativeToElement, templateParts) {\n              super(css, relativeToElement);\n              this.templateParts = templateParts;\n              this.elements = templateParts.filter(elt => elt instanceof Element);\n          }\n\n          get css() {\n              let rv = \"\", i = 0\n              for (const val of this.templateParts) {\n                  if (val instanceof Element) {\n                      rv += \"[data-hs-query-id='\" + i++ + \"']\";\n                  } else rv += val;\n              }\n              return rv;\n          }\n\n          [Symbol.iterator]() {\n              this.elements.forEach((el, i) => el.dataset.hsQueryId = i);\n              const rv = super[Symbol.iterator]();\n              this.elements.forEach(el => el.removeAttribute('data-hs-query-id'));\n              return rv;\n          }\n      }\n\n      parser.addLeafExpression(\"queryRef\", function (parser, runtime, tokens) {\n          var queryStart = tokens.matchOpToken(\"<\");\n          if (!queryStart) return;\n          var queryTokens = tokens.consumeUntil(\"/\");\n          tokens.requireOpToken(\"/\");\n          tokens.requireOpToken(\">\");\n          var queryValue = queryTokens\n              .map(function (t) {\n                  if (t.type === \"STRING\") {\n                      return '\"' + t.value + '\"';\n                  } else {\n                      return t.value;\n                  }\n              })\n              .join(\"\");\n\n          var template, innerTokens, args;\n          if (queryValue.indexOf(\"$\") >= 0) {\n              template = true;\n              innerTokens = Lexer.tokenize(queryValue, true);\n              args = parser.parseStringTemplate(innerTokens);\n          }\n\n          return {\n              type: \"queryRef\",\n              css: queryValue,\n              args: args,\n              op: function (context, ...args) {\n                  if (template) {\n                      return new TemplatedQueryElementCollection(queryValue, context.me, args)\n                  } else {\n                      return new ElementCollection(queryValue, context.me)\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"attributeRef\", function (parser, runtime, tokens) {\n          var attributeRef = tokens.matchTokenType(\"ATTRIBUTE_REF\");\n          if (!attributeRef) return;\n          if (!attributeRef.value) return;\n          var outerVal = attributeRef.value;\n          if (outerVal.indexOf(\"[\") === 0) {\n              var innerValue = outerVal.substring(2, outerVal.length - 1);\n          } else {\n              var innerValue = outerVal.substring(1);\n          }\n          var css = \"[\" + innerValue + \"]\";\n          var split = innerValue.split(\"=\");\n          var name = split[0];\n          var value = split[1];\n          if (value) {\n              // strip quotes\n              if (value.indexOf('\"') === 0) {\n                  value = value.substring(1, value.length - 1);\n              }\n          }\n          return {\n              type: \"attributeRef\",\n              name: name,\n              css: css,\n              value: value,\n              op: function (context) {\n                  var target = context.you || context.me;\n                  if (target) {\n                      return target.getAttribute(name);\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"styleRef\", function (parser, runtime, tokens) {\n          var styleRef = tokens.matchTokenType(\"STYLE_REF\");\n          if (!styleRef) return;\n          if (!styleRef.value) return;\n          var styleProp = styleRef.value.substr(1);\n          if (styleProp.startsWith(\"computed-\")) {\n              styleProp = styleProp.substr(\"computed-\".length);\n              return {\n                  type: \"computedStyleRef\",\n                  name: styleProp,\n                  op: function (context) {\n                      var target = context.you || context.me;\n                      if (target) {\n                          return runtime.resolveComputedStyle(target, styleProp);\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              return {\n                  type: \"styleRef\",\n                  name: styleProp,\n                  op: function (context) {\n                      var target = context.you || context.me;\n                      if (target) {\n                          return runtime.resolveStyle(target, styleProp);\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n      });\n\n      parser.addGrammarElement(\"objectKey\", function (parser, runtime, tokens) {\n          var token;\n          if ((token = tokens.matchTokenType(\"STRING\"))) {\n              return {\n                  type: \"objectKey\",\n                  key: token.value,\n                  evaluate: function () {\n                      return token.value;\n                  },\n              };\n          } else if (tokens.matchOpToken(\"[\")) {\n              var expr = parser.parseElement(\"expression\", tokens);\n              tokens.requireOpToken(\"]\");\n              return {\n                  type: \"objectKey\",\n                  expr: expr,\n                  args: [expr],\n                  op: function (ctx, expr) {\n                      return expr;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              var key = \"\";\n              do {\n                  token = tokens.matchTokenType(\"IDENTIFIER\") || tokens.matchOpToken(\"-\");\n                  if (token) key += token.value;\n              } while (token);\n              return {\n                  type: \"objectKey\",\n                  key: key,\n                  evaluate: function () {\n                      return key;\n                  },\n              };\n          }\n      });\n\n      parser.addLeafExpression(\"objectLiteral\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"{\")) return;\n          var keyExpressions = [];\n          var valueExpressions = [];\n          if (!tokens.matchOpToken(\"}\")) {\n              do {\n                  var name = parser.requireElement(\"objectKey\", tokens);\n                  tokens.requireOpToken(\":\");\n                  var value = parser.requireElement(\"expression\", tokens);\n                  valueExpressions.push(value);\n                  keyExpressions.push(name);\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\"}\");\n          }\n          return {\n              type: \"objectLiteral\",\n              args: [keyExpressions, valueExpressions],\n              op: function (context, keys, values) {\n                  var returnVal = {};\n                  for (var i = 0; i < keys.length; i++) {\n                      returnVal[keys[i]] = values[i];\n                  }\n                  return returnVal;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"nakedNamedArgumentList\", function (parser, runtime, tokens) {\n          var fields = [];\n          var valueExpressions = [];\n          if (tokens.currentToken().type === \"IDENTIFIER\") {\n              do {\n                  var name = tokens.requireTokenType(\"IDENTIFIER\");\n                  tokens.requireOpToken(\":\");\n                  var value = parser.requireElement(\"expression\", tokens);\n                  valueExpressions.push(value);\n                  fields.push({ name: name, value: value });\n              } while (tokens.matchOpToken(\",\"));\n          }\n          return {\n              type: \"namedArgumentList\",\n              fields: fields,\n              args: [valueExpressions],\n              op: function (context, values) {\n                  var returnVal = { _namedArgList_: true };\n                  for (var i = 0; i < values.length; i++) {\n                      var field = fields[i];\n                      returnVal[field.name.value] = values[i];\n                  }\n                  return returnVal;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"namedArgumentList\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"(\")) return;\n          var elt = parser.requireElement(\"nakedNamedArgumentList\", tokens);\n          tokens.requireOpToken(\")\");\n          return elt;\n      });\n\n      parser.addGrammarElement(\"symbol\", function (parser, runtime, tokens) {\n          /** @scope {SymbolScope} */\n          var scope = \"default\";\n          if (tokens.matchToken(\"global\")) {\n              scope = \"global\";\n          } else if (tokens.matchToken(\"element\") || tokens.matchToken(\"module\")) {\n              scope = \"element\";\n              // optional possessive\n              if (tokens.matchOpToken(\"'\")) {\n                  tokens.requireToken(\"s\");\n              }\n          } else if (tokens.matchToken(\"local\")) {\n              scope = \"local\";\n          }\n\n          // TODO better look ahead here\n          let eltPrefix = tokens.matchOpToken(\":\");\n          let identifier = tokens.matchTokenType(\"IDENTIFIER\");\n          if (identifier && identifier.value) {\n              var name = identifier.value;\n              if (eltPrefix) {\n                  name = \":\" + name;\n              }\n              if (scope === \"default\") {\n                  if (name.indexOf(\"$\") === 0) {\n                      scope = \"global\";\n                  }\n                  if (name.indexOf(\":\") === 0) {\n                      scope = \"element\";\n                  }\n              }\n              return {\n                  type: \"symbol\",\n                  token: identifier,\n                  scope: scope,\n                  name: name,\n                  evaluate: function (context) {\n                      return runtime.resolveSymbol(name, context, scope);\n                  },\n              };\n          }\n      });\n\n      parser.addGrammarElement(\"implicitMeTarget\", function (parser, runtime, tokens) {\n          return {\n              type: \"implicitMeTarget\",\n              evaluate: function (context) {\n                  return context.you || context.me;\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"boolean\", function (parser, runtime, tokens) {\n          var booleanLiteral = tokens.matchToken(\"true\") || tokens.matchToken(\"false\");\n          if (!booleanLiteral) return;\n          const value = booleanLiteral.value === \"true\";\n          return {\n              type: \"boolean\",\n              evaluate: function (context) {\n                  return value;\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"null\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"null\")) {\n              return {\n                  type: \"null\",\n                  evaluate: function (context) {\n                      return null;\n                  },\n              };\n          }\n      });\n\n      parser.addLeafExpression(\"arrayLiteral\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"[\")) return;\n          var values = [];\n          if (!tokens.matchOpToken(\"]\")) {\n              do {\n                  var expr = parser.requireElement(\"expression\", tokens);\n                  values.push(expr);\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\"]\");\n          }\n          return {\n              type: \"arrayLiteral\",\n              values: values,\n              args: [values],\n              op: function (context, values) {\n                  return values;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"blockLiteral\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"\\\\\")) return;\n          var args = [];\n          var arg1 = tokens.matchTokenType(\"IDENTIFIER\");\n          if (arg1) {\n              args.push(arg1);\n              while (tokens.matchOpToken(\",\")) {\n                  args.push(tokens.requireTokenType(\"IDENTIFIER\"));\n              }\n          }\n          // TODO compound op token\n          tokens.requireOpToken(\"-\");\n          tokens.requireOpToken(\">\");\n          var expr = parser.requireElement(\"expression\", tokens);\n          return {\n              type: \"blockLiteral\",\n              args: args,\n              expr: expr,\n              evaluate: function (ctx) {\n                  var returnFunc = function () {\n                      //TODO - push scope\n                      for (var i = 0; i < args.length; i++) {\n                          ctx.locals[args[i].value] = arguments[i];\n                      }\n                      return expr.evaluate(ctx); //OK\n                  };\n                  return returnFunc;\n              },\n          };\n      });\n\n      parser.addIndirectExpression(\"propertyAccess\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchOpToken(\".\")) return;\n          var prop = tokens.requireTokenType(\"IDENTIFIER\");\n          var propertyAccess = {\n              type: \"propertyAccess\",\n              root: root,\n              prop: prop,\n              args: [root],\n              op: function (_context, rootVal) {\n                  var value = runtime.resolveProperty(rootVal, prop.value);\n                  return value;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n          return parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n      });\n\n      parser.addIndirectExpression(\"of\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchToken(\"of\")) return;\n          var newRoot = parser.requireElement(\"unaryExpression\", tokens);\n          // find the urroot\n          var childOfUrRoot = null;\n          var urRoot = root;\n          while (urRoot.root) {\n              childOfUrRoot = urRoot;\n              urRoot = urRoot.root;\n          }\n          if (urRoot.type !== \"symbol\" && urRoot.type !== \"attributeRef\" && urRoot.type !== \"styleRef\" && urRoot.type !== \"computedStyleRef\") {\n              parser.raiseParseError(tokens, \"Cannot take a property of a non-symbol: \" + urRoot.type);\n          }\n          var attribute = urRoot.type === \"attributeRef\";\n          var style = urRoot.type === \"styleRef\" || urRoot.type === \"computedStyleRef\";\n          if (attribute || style) {\n              var attributeElt = urRoot\n          }\n          var prop = urRoot.name;\n\n          var propertyAccess = {\n              type: \"ofExpression\",\n              prop: urRoot.token,\n              root: newRoot,\n              attribute: attributeElt,\n              expression: root,\n              args: [newRoot],\n              op: function (context, rootVal) {\n                  if (attribute) {\n                      return runtime.resolveAttribute(rootVal, prop);\n                  } else if (style) {\n                      if (urRoot.type === \"computedStyleRef\") {\n                          return runtime.resolveComputedStyle(rootVal, prop);\n                      } else {\n                          return runtime.resolveStyle(rootVal, prop);\n                      }\n                  } else {\n                      return runtime.resolveProperty(rootVal, prop);\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n\n          if (urRoot.type === \"attributeRef\") {\n              propertyAccess.attribute = urRoot;\n          }\n          if (childOfUrRoot) {\n              childOfUrRoot.root = propertyAccess;\n              childOfUrRoot.args = [propertyAccess];\n          } else {\n              root = propertyAccess;\n          }\n\n          return parser.parseElement(\"indirectExpression\", tokens, root);\n      });\n\n      parser.addIndirectExpression(\"possessive\", function (parser, runtime, tokens, root) {\n          if (parser.possessivesDisabled) {\n              return;\n          }\n          var apostrophe = tokens.matchOpToken(\"'\");\n          if (\n              apostrophe ||\n              (root.type === \"symbol\" &&\n                  (root.name === \"my\" || root.name === \"its\" || root.name === \"your\") &&\n                  (tokens.currentToken().type === \"IDENTIFIER\" || tokens.currentToken().type === \"ATTRIBUTE_REF\" || tokens.currentToken().type === \"STYLE_REF\"))\n          ) {\n              if (apostrophe) {\n                  tokens.requireToken(\"s\");\n              }\n\n              var attribute, style, prop;\n              attribute = parser.parseElement(\"attributeRef\", tokens);\n              if (attribute == null) {\n                  style = parser.parseElement(\"styleRef\", tokens);\n                  if (style == null) {\n                      prop = tokens.requireTokenType(\"IDENTIFIER\");\n                  }\n              }\n              var propertyAccess = {\n                  type: \"possessive\",\n                  root: root,\n                  attribute: attribute || style,\n                  prop: prop,\n                  args: [root],\n                  op: function (context, rootVal) {\n                      if (attribute) {\n                          // @ts-ignore\n                          var value = runtime.resolveAttribute(rootVal, attribute.name);\n                      } else if (style) {\n                          var value\n                          if (style.type === 'computedStyleRef') {\n                              value = runtime.resolveComputedStyle(rootVal, style['name']);\n                          } else {\n                              value = runtime.resolveStyle(rootVal, style['name']);\n                          }\n                      } else {\n                          var value = runtime.resolveProperty(rootVal, prop.value);\n                      }\n                      return value;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n              return parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n          }\n      });\n\n      parser.addIndirectExpression(\"inExpression\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchToken(\"in\")) return;\n          var target = parser.requireElement(\"unaryExpression\", tokens);\n          var propertyAccess = {\n              type: \"inExpression\",\n              root: root,\n              args: [root, target],\n              op: function (context, rootVal, target) {\n                  var returnArr = [];\n                  if (rootVal.css) {\n                      runtime.implicitLoop(target, function (targetElt) {\n                          var results = targetElt.querySelectorAll(rootVal.css);\n                          for (var i = 0; i < results.length; i++) {\n                              returnArr.push(results[i]);\n                          }\n                      });\n                  } else if (rootVal instanceof Element) {\n                      var within = false;\n                      runtime.implicitLoop(target, function (targetElt) {\n                          if (targetElt.contains(rootVal)) {\n                              within = true;\n                          }\n                      });\n                      if(within) {\n                          return rootVal;\n                      }\n                  } else {\n                      runtime.implicitLoop(rootVal, function (rootElt) {\n                          runtime.implicitLoop(target, function (targetElt) {\n                              if (rootElt === targetElt) {\n                                  returnArr.push(rootElt);\n                              }\n                          });\n                      });\n                  }\n                  return returnArr;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n          return parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n      });\n\n      parser.addIndirectExpression(\"asExpression\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchToken(\"as\")) return;\n          tokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n          var conversion = parser.requireElement(\"dotOrColonPath\", tokens).evaluate(); // OK No promise\n          var propertyAccess = {\n              type: \"asExpression\",\n              root: root,\n              args: [root],\n              op: function (context, rootVal) {\n                  return runtime.convertValue(rootVal, conversion);\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n          return parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n      });\n\n      parser.addIndirectExpression(\"functionCall\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchOpToken(\"(\")) return;\n          var args = [];\n          if (!tokens.matchOpToken(\")\")) {\n              do {\n                  args.push(parser.requireElement(\"expression\", tokens));\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\")\");\n          }\n\n          if (root.root) {\n              var functionCall = {\n                  type: \"functionCall\",\n                  root: root,\n                  argExressions: args,\n                  args: [root.root, args],\n                  op: function (context, rootRoot, args) {\n                      runtime.nullCheck(rootRoot, root.root);\n                      var func = rootRoot[root.prop.value];\n                      runtime.nullCheck(func, root);\n                      if (func.hyperfunc) {\n                          args.push(context);\n                      }\n                      return func.apply(rootRoot, args);\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              var functionCall = {\n                  type: \"functionCall\",\n                  root: root,\n                  argExressions: args,\n                  args: [root, args],\n                  op: function (context, func, argVals) {\n                      runtime.nullCheck(func, root);\n                      if (func.hyperfunc) {\n                          argVals.push(context);\n                      }\n                      var apply = func.apply(null, argVals);\n                      return apply;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n          return parser.parseElement(\"indirectExpression\", tokens, functionCall);\n      });\n\n      parser.addIndirectExpression(\"attributeRefAccess\", function (parser, runtime, tokens, root) {\n          var attribute = parser.parseElement(\"attributeRef\", tokens);\n          if (!attribute) return;\n          var attributeAccess = {\n              type: \"attributeRefAccess\",\n              root: root,\n              attribute: attribute,\n              args: [root],\n              op: function (_ctx, rootVal) {\n                  // @ts-ignore\n                  var value = runtime.resolveAttribute(rootVal, attribute.name);\n                  return value;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n          return attributeAccess;\n      });\n\n      parser.addIndirectExpression(\"arrayIndex\", function (parser, runtime, tokens, root) {\n          if (!tokens.matchOpToken(\"[\")) return;\n          var andBefore = false;\n          var andAfter = false;\n          var firstIndex = null;\n          var secondIndex = null;\n\n          if (tokens.matchOpToken(\"..\")) {\n              andBefore = true;\n              firstIndex = parser.requireElement(\"expression\", tokens);\n          } else {\n              firstIndex = parser.requireElement(\"expression\", tokens);\n\n              if (tokens.matchOpToken(\"..\")) {\n                  andAfter = true;\n                  var current = tokens.currentToken();\n                  if (current.type !== \"R_BRACKET\") {\n                      secondIndex = parser.parseElement(\"expression\", tokens);\n                  }\n              }\n          }\n          tokens.requireOpToken(\"]\");\n\n          var arrayIndex = {\n              type: \"arrayIndex\",\n              root: root,\n              prop: firstIndex,\n              firstIndex: firstIndex,\n              secondIndex: secondIndex,\n              args: [root, firstIndex, secondIndex],\n              op: function (_ctx, root, firstIndex, secondIndex) {\n                  if (root == null) {\n                      return null;\n                  }\n                  if (andBefore) {\n                      if (firstIndex < 0) {\n                          firstIndex = root.length + firstIndex;\n                      }\n                      return root.slice(0, firstIndex + 1); // returns all items from beginning to firstIndex (inclusive)\n                  } else if (andAfter) {\n                      if (secondIndex != null) {\n                          if (secondIndex < 0) {\n                              secondIndex = root.length + secondIndex;\n                          }\n                          return root.slice(firstIndex, secondIndex + 1); // returns all items from firstIndex to secondIndex (inclusive)\n                      } else {\n                          return root.slice(firstIndex); // returns from firstIndex to end of array\n                      }\n                  } else {\n                      return root[firstIndex];\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n\n          return parser.parseElement(\"indirectExpression\", tokens, arrayIndex);\n      });\n\n      // taken from https://drafts.csswg.org/css-values-4/#relative-length\n      //        and https://drafts.csswg.org/css-values-4/#absolute-length\n      //        (NB: we do not support `in` dues to conflicts w/ the hyperscript grammar)\n      var STRING_POSTFIXES = [\n          'em', 'ex', 'cap', 'ch', 'ic', 'rem', 'lh', 'rlh', 'vw', 'vh', 'vi', 'vb', 'vmin', 'vmax',\n          'cm', 'mm', 'Q', 'pc', 'pt', 'px'\n      ];\n      parser.addGrammarElement(\"postfixExpression\", function (parser, runtime, tokens) {\n          var root = parser.parseElement(\"primaryExpression\", tokens);\n\n          let stringPosfix = tokens.matchAnyToken.apply(tokens, STRING_POSTFIXES) || tokens.matchOpToken(\"%\");\n          if (stringPosfix) {\n              return {\n                  type: \"stringPostfix\",\n                  postfix: stringPosfix.value,\n                  args: [root],\n                  op: function (context, val) {\n                      return \"\" + val + stringPosfix.value;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n\n          var timeFactor = null;\n          if (tokens.matchToken(\"s\") || tokens.matchToken(\"seconds\")) {\n              timeFactor = 1000;\n          } else if (tokens.matchToken(\"ms\") || tokens.matchToken(\"milliseconds\")) {\n              timeFactor = 1;\n          }\n          if (timeFactor) {\n              return {\n                  type: \"timeExpression\",\n                  time: root,\n                  factor: timeFactor,\n                  args: [root],\n                  op: function (_context, val) {\n                      return val * timeFactor;\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n\n          if (tokens.matchOpToken(\":\")) {\n              var typeName = tokens.requireTokenType(\"IDENTIFIER\");\n              if (!typeName.value) return;\n              var nullOk = !tokens.matchOpToken(\"!\");\n              return {\n                  type: \"typeCheck\",\n                  typeName: typeName,\n                  nullOk: nullOk,\n                  args: [root],\n                  op: function (context, val) {\n                      var passed = runtime.typeCheck(val, this.typeName.value, nullOk);\n                      if (passed) {\n                          return val;\n                      } else {\n                          throw new Error(\"Typecheck failed!  Expected: \" + typeName.value);\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          } else {\n              return root;\n          }\n      });\n\n      parser.addGrammarElement(\"logicalNot\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"not\")) return;\n          var root = parser.requireElement(\"unaryExpression\", tokens);\n          return {\n              type: \"logicalNot\",\n              root: root,\n              args: [root],\n              op: function (context, val) {\n                  return !val;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"noExpression\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"no\")) return;\n          var root = parser.requireElement(\"unaryExpression\", tokens);\n          return {\n              type: \"noExpression\",\n              root: root,\n              args: [root],\n              op: function (_context, val) {\n                  return runtime.isEmpty(val);\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"some\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"some\")) return;\n          var root = parser.requireElement(\"expression\", tokens);\n          return {\n              type: \"noExpression\",\n              root: root,\n              args: [root],\n              op: function (_context, val) {\n                  return !runtime.isEmpty(val);\n              },\n              evaluate(context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"negativeNumber\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"-\")) return;\n          var root = parser.requireElement(\"unaryExpression\", tokens);\n          return {\n              type: \"negativeNumber\",\n              root: root,\n              args: [root],\n              op: function (context, value) {\n                  return -1 * value;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"unaryExpression\", function (parser, runtime, tokens) {\n          tokens.matchToken(\"the\"); // optional \"the\"\n          return parser.parseAnyOf(\n              [\"beepExpression\", \"logicalNot\", \"relativePositionalExpression\", \"positionalExpression\", \"noExpression\", \"negativeNumber\", \"postfixExpression\"],\n              tokens\n          );\n      });\n\n      parser.addGrammarElement(\"beepExpression\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"beep!\")) return;\n          var expression = parser.parseElement(\"unaryExpression\", tokens);\n          if (expression) {\n              expression['booped'] = true;\n              var originalEvaluate = expression.evaluate;\n              expression.evaluate = function(ctx){\n                  let value = originalEvaluate.apply(expression, arguments);\n                  let element = ctx.me;\n                  if (runtime.triggerEvent(element, \"hyperscript:beep\", {element, expression, value})) {\n                      var typeName;\n                      if (value) {\n                          if (value instanceof ElementCollection){\n                              typeName = \"ElementCollection\";\n                          } else if (value.constructor) {\n                              typeName = value.constructor.name;\n                          } else {\n                              typeName = \"unknown\";\n                          }\n                      } else {\n                          typeName = \"object (null)\"\n                      }\n                      var logValue = value;\n                      if (typeName === \"String\") {\n                          logValue = '\"' + logValue + '\"';\n                      } else if (value instanceof ElementCollection) {\n                          logValue = Array.from(value);\n                      }\n                      console.log(\"///_ BEEP! The expression (\" + Tokens.sourceFor.call(expression).substr(6) + \") evaluates to:\", logValue,  \"of type \" + typeName);\n                  }\n                  return value;\n              }\n              return expression;\n          }\n      });\n\n      var scanForwardQuery = function(start, root, match, wrap) {\n          var results = root.querySelectorAll(match);\n          for (var i = 0; i < results.length; i++) {\n              var elt = results[i];\n              if (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_PRECEDING) {\n                  return elt;\n              }\n          }\n          if (wrap) {\n              return results[0];\n          }\n      }\n\n      var scanBackwardsQuery = function(start, root, match, wrap) {\n          var results = root.querySelectorAll(match);\n          for (var i = results.length - 1; i >= 0; i--) {\n              var elt = results[i];\n              if (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_FOLLOWING) {\n                  return elt;\n              }\n          }\n          if (wrap) {\n              return results[results.length - 1];\n          }\n      }\n\n      var scanForwardArray = function(start, array, match, wrap) {\n          var matches = [];\n          Runtime.prototype.forEach(array, function(elt){\n              if (elt.matches(match) || elt === start) {\n                  matches.push(elt);\n              }\n          })\n          for (var i = 0; i < matches.length - 1; i++) {\n              var elt = matches[i];\n              if (elt === start) {\n                  return matches[i + 1];\n              }\n          }\n          if (wrap) {\n              var first = matches[0];\n              if (first && first.matches(match)) {\n                  return first;\n              }\n          }\n      }\n\n      var scanBackwardsArray = function(start, array, match, wrap) {\n          return scanForwardArray(start, Array.from(array).reverse(), match, wrap);\n      }\n\n      parser.addGrammarElement(\"relativePositionalExpression\", function (parser, runtime, tokens) {\n          var op = tokens.matchAnyToken(\"next\", \"previous\");\n          if (!op) return;\n          var forwardSearch = op.value === \"next\";\n\n          var thing = parser.parseElement(\"expression\", tokens);\n\n          if (tokens.matchToken(\"from\")) {\n              tokens.pushFollow(\"in\");\n              try {\n                  var from = parser.requireElement(\"unaryExpression\", tokens);\n              } finally {\n                  tokens.popFollow();\n              }\n          } else {\n              var from = parser.requireElement(\"implicitMeTarget\", tokens);\n          }\n\n          var inSearch = false;\n          var withinElt;\n          if (tokens.matchToken(\"in\")) {\n              inSearch = true;\n              var inElt = parser.requireElement(\"unaryExpression\", tokens);\n          } else if (tokens.matchToken(\"within\")) {\n              withinElt = parser.requireElement(\"unaryExpression\", tokens);\n          } else {\n              withinElt = document.body;\n          }\n\n          var wrapping = false;\n          if (tokens.matchToken(\"with\")) {\n              tokens.requireToken(\"wrapping\")\n              wrapping = true;\n          }\n\n          return {\n              type: \"relativePositionalExpression\",\n              from: from,\n              forwardSearch: forwardSearch,\n              inSearch: inSearch,\n              wrapping: wrapping,\n              inElt: inElt,\n              withinElt: withinElt,\n              operator: op.value,\n              args: [thing, from, inElt, withinElt],\n              op: function (context, thing, from, inElt, withinElt) {\n\n                  var css = thing.css;\n                  if (css == null) {\n                      throw \"Expected a CSS value\";\n                  }\n\n                  if(inSearch) {\n                      if (inElt) {\n                          if (forwardSearch) {\n                              return scanForwardArray(from, inElt, css, wrapping);\n                          } else {\n                              return scanBackwardsArray(from, inElt, css, wrapping);\n                          }\n                      }\n                  } else {\n                      if (withinElt) {\n                          if (forwardSearch) {\n                              return scanForwardQuery(from, withinElt, css, wrapping);\n                          } else {\n                              return scanBackwardsQuery(from, withinElt, css, wrapping);\n                          }\n                      }\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          }\n\n      });\n\n      parser.addGrammarElement(\"positionalExpression\", function (parser, runtime, tokens) {\n          var op = tokens.matchAnyToken(\"first\", \"last\", \"random\");\n          if (!op) return;\n          tokens.matchAnyToken(\"in\", \"from\", \"of\");\n          var rhs = parser.requireElement(\"unaryExpression\", tokens);\n          const operator = op.value;\n          return {\n              type: \"positionalExpression\",\n              rhs: rhs,\n              operator: op.value,\n              args: [rhs],\n              op: function (context, rhsVal) {\n                  if (rhsVal && !Array.isArray(rhsVal)) {\n                      if (rhsVal.children) {\n                          rhsVal = rhsVal.children;\n                      } else {\n                          rhsVal = Array.from(rhsVal);\n                      }\n                  }\n                  if (rhsVal) {\n                      if (operator === \"first\") {\n                          return rhsVal[0];\n                      } else if (operator === \"last\") {\n                          return rhsVal[rhsVal.length - 1];\n                      } else if (operator === \"random\") {\n                          return rhsVal[Math.floor(Math.random() * rhsVal.length)];\n                      }\n                  }\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              },\n          };\n      });\n\n      parser.addGrammarElement(\"mathOperator\", function (parser, runtime, tokens) {\n          var expr = parser.parseElement(\"unaryExpression\", tokens);\n          var mathOp,\n              initialMathOp = null;\n          mathOp = tokens.matchAnyOpToken(\"+\", \"-\", \"*\", \"/\", \"%\");\n          while (mathOp) {\n              initialMathOp = initialMathOp || mathOp;\n              var operator = mathOp.value;\n              if (initialMathOp.value !== operator) {\n                  parser.raiseParseError(tokens, \"You must parenthesize math operations with different operators\");\n              }\n              var rhs = parser.parseElement(\"unaryExpression\", tokens);\n              expr = {\n                  type: \"mathOperator\",\n                  lhs: expr,\n                  rhs: rhs,\n                  operator: operator,\n                  args: [expr, rhs],\n                  op: function (context, lhsVal, rhsVal) {\n                      if (operator === \"+\") {\n                          return lhsVal + rhsVal;\n                      } else if (operator === \"-\") {\n                          return lhsVal - rhsVal;\n                      } else if (operator === \"*\") {\n                          return lhsVal * rhsVal;\n                      } else if (operator === \"/\") {\n                          return lhsVal / rhsVal;\n                      } else if (operator === \"%\") {\n                          return lhsVal % rhsVal;\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n              mathOp = tokens.matchAnyOpToken(\"+\", \"-\", \"*\", \"/\", \"%\");\n          }\n          return expr;\n      });\n\n      parser.addGrammarElement(\"mathExpression\", function (parser, runtime, tokens) {\n          return parser.parseAnyOf([\"mathOperator\", \"unaryExpression\"], tokens);\n      });\n\n      function sloppyContains(src, container, value){\n          if (container['contains']) {\n              return container.contains(value);\n          } else if (container['includes']) {\n              return container.includes(value);\n          } else {\n              throw Error(\"The value of \" + src.sourceFor() + \" does not have a contains or includes method on it\");\n          }\n      }\n      function sloppyMatches(src, target, toMatch){\n          if (target['match']) {\n              return !!target.match(toMatch);\n          } else if (target['matches']) {\n              return target.matches(toMatch);\n          } else {\n              throw Error(\"The value of \" + src.sourceFor() + \" does not have a match or matches method on it\");\n          }\n      }\n\n      parser.addGrammarElement(\"comparisonOperator\", function (parser, runtime, tokens) {\n          var expr = parser.parseElement(\"mathExpression\", tokens);\n          var comparisonToken = tokens.matchAnyOpToken(\"<\", \">\", \"<=\", \">=\", \"==\", \"===\", \"!=\", \"!==\");\n          var operator = comparisonToken ? comparisonToken.value : null;\n          var hasRightValue = true; // By default, most comparisons require two values, but there are some exceptions.\n          var typeCheck = false;\n\n          if (operator == null) {\n              if (tokens.matchToken(\"is\") || tokens.matchToken(\"am\")) {\n                  if (tokens.matchToken(\"not\")) {\n                      if (tokens.matchToken(\"in\")) {\n                          operator = \"not in\";\n                      } else if (tokens.matchToken(\"a\")) {\n                          operator = \"not a\";\n                          typeCheck = true;\n                      } else if (tokens.matchToken(\"empty\")) {\n                          operator = \"not empty\";\n                          hasRightValue = false;\n                      } else {\n                          operator = \"!=\";\n                      }\n                  } else if (tokens.matchToken(\"in\")) {\n                      operator = \"in\";\n                  } else if (tokens.matchToken(\"a\")) {\n                      operator = \"a\";\n                      typeCheck = true;\n                  } else if (tokens.matchToken(\"empty\")) {\n                      operator = \"empty\";\n                      hasRightValue = false;\n                  } else if (tokens.matchToken(\"less\")) {\n                      tokens.requireToken(\"than\");\n                      if (tokens.matchToken(\"or\")) {\n                          tokens.requireToken(\"equal\");\n                          tokens.requireToken(\"to\");\n                          operator = \"<=\";\n                      } else {\n                          operator = \"<\";\n                      }\n                  } else if (tokens.matchToken(\"greater\")) {\n                      tokens.requireToken(\"than\");\n                      if (tokens.matchToken(\"or\")) {\n                          tokens.requireToken(\"equal\");\n                          tokens.requireToken(\"to\");\n                          operator = \">=\";\n                      } else {\n                          operator = \">\";\n                      }\n                  } else {\n                      operator = \"==\";\n                  }\n              } else if (tokens.matchToken(\"exist\") || tokens.matchToken(\"exists\")) {\n                  operator = \"exist\";\n                  hasRightValue = false;\n              } else if (tokens.matchToken(\"matches\") || tokens.matchToken(\"match\")) {\n                  operator = \"match\";\n              } else if (tokens.matchToken(\"contains\") || tokens.matchToken(\"contain\")) {\n                  operator = \"contain\";\n              } else if (tokens.matchToken(\"includes\") || tokens.matchToken(\"include\")) {\n                  operator = \"include\";\n              } else if (tokens.matchToken(\"do\") || tokens.matchToken(\"does\")) {\n                  tokens.requireToken(\"not\");\n                  if (tokens.matchToken(\"matches\") || tokens.matchToken(\"match\")) {\n                      operator = \"not match\";\n                  } else if (tokens.matchToken(\"contains\") || tokens.matchToken(\"contain\")) {\n                      operator = \"not contain\";\n                  } else if (tokens.matchToken(\"exist\") || tokens.matchToken(\"exist\")) {\n                      operator = \"not exist\";\n                      hasRightValue = false;\n                  } else if (tokens.matchToken(\"include\")) {\n                      operator = \"not include\";\n                  } else {\n                      parser.raiseParseError(tokens, \"Expected matches or contains\");\n                  }\n              }\n          }\n\n          if (operator) {\n              // Do not allow chained comparisons, which is dumb\n              var typeName, nullOk, rhs\n              if (typeCheck) {\n                  typeName = tokens.requireTokenType(\"IDENTIFIER\");\n                  nullOk = !tokens.matchOpToken(\"!\");\n              } else if (hasRightValue) {\n                  rhs = parser.requireElement(\"mathExpression\", tokens);\n                  if (operator === \"match\" || operator === \"not match\") {\n                      rhs = rhs.css ? rhs.css : rhs;\n                  }\n              }\n              var lhs = expr;\n              expr = {\n                  type: \"comparisonOperator\",\n                  operator: operator,\n                  typeName: typeName,\n                  nullOk: nullOk,\n                  lhs: expr,\n                  rhs: rhs,\n                  args: [expr, rhs],\n                  op: function (context, lhsVal, rhsVal) {\n                      if (operator === \"==\") {\n                          return lhsVal == rhsVal;\n                      } else if (operator === \"!=\") {\n                          return lhsVal != rhsVal;\n                      }\n                      if (operator === \"match\") {\n                          return lhsVal != null && sloppyMatches(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"not match\") {\n                          return lhsVal == null || !sloppyMatches(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"in\") {\n                          return rhsVal != null && sloppyContains(rhs, rhsVal, lhsVal);\n                      }\n                      if (operator === \"not in\") {\n                          return rhsVal == null || !sloppyContains(rhs, rhsVal, lhsVal);\n                      }\n                      if (operator === \"contain\") {\n                          return lhsVal != null && sloppyContains(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"not contain\") {\n                          return lhsVal == null || !sloppyContains(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"include\") {\n                          return lhsVal != null && sloppyContains(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"not include\") {\n                          return lhsVal == null || !sloppyContains(lhs, lhsVal, rhsVal);\n                      }\n                      if (operator === \"===\") {\n                          return lhsVal === rhsVal;\n                      } else if (operator === \"!==\") {\n                          return lhsVal !== rhsVal;\n                      } else if (operator === \"<\") {\n                          return lhsVal < rhsVal;\n                      } else if (operator === \">\") {\n                          return lhsVal > rhsVal;\n                      } else if (operator === \"<=\") {\n                          return lhsVal <= rhsVal;\n                      } else if (operator === \">=\") {\n                          return lhsVal >= rhsVal;\n                      } else if (operator === \"empty\") {\n                          return runtime.isEmpty(lhsVal);\n                      } else if (operator === \"not empty\") {\n                          return !runtime.isEmpty(lhsVal);\n                      } else if (operator === \"exist\") {\n                          return runtime.doesExist(lhsVal);\n                      } else if (operator === \"not exist\") {\n                          return !runtime.doesExist(lhsVal);\n                      } else if (operator === \"a\") {\n                          return runtime.typeCheck(lhsVal, typeName.value, nullOk);\n                      } else if (operator === \"not a\") {\n                          return !runtime.typeCheck(lhsVal, typeName.value, nullOk);\n                      } else {\n                          throw \"Unknown comparison : \" + operator;\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n          }\n          return expr;\n      });\n\n      parser.addGrammarElement(\"comparisonExpression\", function (parser, runtime, tokens) {\n          return parser.parseAnyOf([\"comparisonOperator\", \"mathExpression\"], tokens);\n      });\n\n      parser.addGrammarElement(\"logicalOperator\", function (parser, runtime, tokens) {\n          var expr = parser.parseElement(\"comparisonExpression\", tokens);\n          var logicalOp,\n              initialLogicalOp = null;\n          logicalOp = tokens.matchToken(\"and\") || tokens.matchToken(\"or\");\n          while (logicalOp) {\n              initialLogicalOp = initialLogicalOp || logicalOp;\n              if (initialLogicalOp.value !== logicalOp.value) {\n                  parser.raiseParseError(tokens, \"You must parenthesize logical operations with different operators\");\n              }\n              var rhs = parser.requireElement(\"comparisonExpression\", tokens);\n              const operator = logicalOp.value;\n              expr = {\n                  type: \"logicalOperator\",\n                  operator: operator,\n                  lhs: expr,\n                  rhs: rhs,\n                  args: [expr, rhs],\n                  op: function (context, lhsVal, rhsVal) {\n                      if (operator === \"and\") {\n                          return lhsVal && rhsVal;\n                      } else {\n                          return lhsVal || rhsVal;\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n              logicalOp = tokens.matchToken(\"and\") || tokens.matchToken(\"or\");\n          }\n          return expr;\n      });\n\n      parser.addGrammarElement(\"logicalExpression\", function (parser, runtime, tokens) {\n          return parser.parseAnyOf([\"logicalOperator\", \"mathExpression\"], tokens);\n      });\n\n      parser.addGrammarElement(\"asyncExpression\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"async\")) {\n              var value = parser.requireElement(\"logicalExpression\", tokens);\n              var expr = {\n                  type: \"asyncExpression\",\n                  value: value,\n                  evaluate: function (context) {\n                      return {\n                          asyncWrapper: true,\n                          value: this.value.evaluate(context), //OK\n                      };\n                  },\n              };\n              return expr;\n          } else {\n              return parser.parseElement(\"logicalExpression\", tokens);\n          }\n      });\n\n      parser.addGrammarElement(\"expression\", function (parser, runtime, tokens) {\n          tokens.matchToken(\"the\"); // optional the\n          return parser.parseElement(\"asyncExpression\", tokens);\n      });\n\n      parser.addGrammarElement(\"assignableExpression\", function (parser, runtime, tokens) {\n          tokens.matchToken(\"the\"); // optional the\n\n          // TODO obviously we need to generalize this as a left hand side / targetable concept\n          var expr = parser.parseElement(\"primaryExpression\", tokens);\n          if (expr && (\n              expr.type === \"symbol\" ||\n              expr.type === \"ofExpression\" ||\n              expr.type === \"propertyAccess\" ||\n              expr.type === \"attributeRefAccess\" ||\n              expr.type === \"attributeRef\" ||\n              expr.type === \"styleRef\" ||\n              expr.type === \"arrayIndex\" ||\n              expr.type === \"possessive\")\n          ) {\n              return expr;\n          } else {\n              parser.raiseParseError(\n                  tokens,\n                  \"A target expression must be writable.  The expression type '\" + (expr && expr.type) + \"' is not.\"\n              );\n          }\n          return expr;\n      });\n\n      parser.addGrammarElement(\"hyperscript\", function (parser, runtime, tokens) {\n          var features = [];\n\n          if (tokens.hasMore()) {\n              while (parser.featureStart(tokens.currentToken()) || tokens.currentToken().value === \"(\") {\n                  var feature = parser.requireElement(\"feature\", tokens);\n                  features.push(feature);\n                  tokens.matchToken(\"end\"); // optional end\n              }\n          }\n          return {\n              type: \"hyperscript\",\n              features: features,\n              apply: function (target, source, args) {\n                  // no op\n                  for (const feature of features) {\n                      feature.install(target, source, args);\n                  }\n              },\n          };\n      });\n\n      var parseEventArgs = function (tokens) {\n          var args = [];\n          // handle argument list (look ahead 3)\n          if (\n              tokens.token(0).value === \"(\" &&\n              (tokens.token(1).value === \")\" || tokens.token(2).value === \",\" || tokens.token(2).value === \")\")\n          ) {\n              tokens.matchOpToken(\"(\");\n              do {\n                  args.push(tokens.requireTokenType(\"IDENTIFIER\"));\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\")\");\n          }\n          return args;\n      };\n\n      parser.addFeature(\"on\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"on\")) return;\n          var every = false;\n          if (tokens.matchToken(\"every\")) {\n              every = true;\n          }\n          var events = [];\n          var displayName = null;\n          do {\n              var on = parser.requireElement(\"eventName\", tokens, \"Expected event name\");\n\n              var eventName = on.evaluate(); // OK No Promise\n\n              if (displayName) {\n                  displayName = displayName + \" or \" + eventName;\n              } else {\n                  displayName = \"on \" + eventName;\n              }\n              var args = parseEventArgs(tokens);\n\n              var filter = null;\n              if (tokens.matchOpToken(\"[\")) {\n                  filter = parser.requireElement(\"expression\", tokens);\n                  tokens.requireOpToken(\"]\");\n              }\n\n              var startCount, endCount ,unbounded;\n              if (tokens.currentToken().type === \"NUMBER\") {\n                  var startCountToken = tokens.consumeToken();\n                  if (!startCountToken.value) return;\n                  startCount = parseInt(startCountToken.value);\n                  if (tokens.matchToken(\"to\")) {\n                      var endCountToken = tokens.consumeToken();\n                      if (!endCountToken.value) return;\n                      endCount = parseInt(endCountToken.value);\n                  } else if (tokens.matchToken(\"and\")) {\n                      unbounded = true;\n                      tokens.requireToken(\"on\");\n                  }\n              }\n\n              var intersectionSpec, mutationSpec;\n              if (eventName === \"intersection\") {\n                  intersectionSpec = {};\n                  if (tokens.matchToken(\"with\")) {\n                      intersectionSpec[\"with\"] = parser.requireElement(\"expression\", tokens).evaluate();\n                  }\n                  if (tokens.matchToken(\"having\")) {\n                      do {\n                          if (tokens.matchToken(\"margin\")) {\n                              intersectionSpec[\"rootMargin\"] = parser.requireElement(\"stringLike\", tokens).evaluate();\n                          } else if (tokens.matchToken(\"threshold\")) {\n                              intersectionSpec[\"threshold\"] = parser.requireElement(\"expression\", tokens).evaluate();\n                          } else {\n                              parser.raiseParseError(tokens, \"Unknown intersection config specification\");\n                          }\n                      } while (tokens.matchToken(\"and\"));\n                  }\n              } else if (eventName === \"mutation\") {\n                  mutationSpec = {};\n                  if (tokens.matchToken(\"of\")) {\n                      do {\n                          if (tokens.matchToken(\"anything\")) {\n                              mutationSpec[\"attributes\"] = true;\n                              mutationSpec[\"subtree\"] = true;\n                              mutationSpec[\"characterData\"] = true;\n                              mutationSpec[\"childList\"] = true;\n                          } else if (tokens.matchToken(\"childList\")) {\n                              mutationSpec[\"childList\"] = true;\n                          } else if (tokens.matchToken(\"attributes\")) {\n                              mutationSpec[\"attributes\"] = true;\n                              mutationSpec[\"attributeOldValue\"] = true;\n                          } else if (tokens.matchToken(\"subtree\")) {\n                              mutationSpec[\"subtree\"] = true;\n                          } else if (tokens.matchToken(\"characterData\")) {\n                              mutationSpec[\"characterData\"] = true;\n                              mutationSpec[\"characterDataOldValue\"] = true;\n                          } else if (tokens.currentToken().type === \"ATTRIBUTE_REF\") {\n                              var attribute = tokens.consumeToken();\n                              if (mutationSpec[\"attributeFilter\"] == null) {\n                                  mutationSpec[\"attributeFilter\"] = [];\n                              }\n                              if (attribute.value.indexOf(\"@\") == 0) {\n                                  mutationSpec[\"attributeFilter\"].push(attribute.value.substring(1));\n                              } else {\n                                  parser.raiseParseError(\n                                      tokens,\n                                      \"Only shorthand attribute references are allowed here\"\n                                  );\n                              }\n                          } else {\n                              parser.raiseParseError(tokens, \"Unknown mutation config specification\");\n                          }\n                      } while (tokens.matchToken(\"or\"));\n                  } else {\n                      mutationSpec[\"attributes\"] = true;\n                      mutationSpec[\"characterData\"] = true;\n                      mutationSpec[\"childList\"] = true;\n                  }\n              }\n\n              var from = null;\n              var elsewhere = false;\n              if (tokens.matchToken(\"from\")) {\n                  if (tokens.matchToken(\"elsewhere\")) {\n                      elsewhere = true;\n                  } else {\n                      from = parser.parseElement(\"expression\", tokens);\n                      if (!from) {\n                          parser.raiseParseError(tokens, 'Expected either target value or \"elsewhere\".');\n                      }\n                  }\n              }\n              // support both \"elsewhere\" and \"from elsewhere\"\n              if (from === null && elsewhere === false && tokens.matchToken(\"elsewhere\")) {\n                  elsewhere = true;\n              }\n\n              if (tokens.matchToken(\"in\")) {\n                  var inExpr = parser.parseElement('unaryExpression', tokens);\n              }\n\n              if (tokens.matchToken(\"debounced\")) {\n                  tokens.requireToken(\"at\");\n                  var timeExpr = parser.requireElement(\"expression\", tokens);\n                  // @ts-ignore\n                  var debounceTime = timeExpr.evaluate({}); // OK No promise TODO make a literal time expr\n              } else if (tokens.matchToken(\"throttled\")) {\n                  tokens.requireToken(\"at\");\n                  var timeExpr = parser.requireElement(\"expression\", tokens);\n                  // @ts-ignore\n                  var throttleTime = timeExpr.evaluate({}); // OK No promise TODO make a literal time expr\n              }\n\n              events.push({\n                  execCount: 0,\n                  every: every,\n                  on: eventName,\n                  args: args,\n                  filter: filter,\n                  from: from,\n                  inExpr: inExpr,\n                  elsewhere: elsewhere,\n                  startCount: startCount,\n                  endCount: endCount,\n                  unbounded: unbounded,\n                  debounceTime: debounceTime,\n                  throttleTime: throttleTime,\n                  mutationSpec: mutationSpec,\n                  intersectionSpec: intersectionSpec,\n                  debounced: undefined,\n                  lastExec: undefined,\n              });\n          } while (tokens.matchToken(\"or\"));\n\n          var queueLast = true;\n          if (!every) {\n              if (tokens.matchToken(\"queue\")) {\n                  if (tokens.matchToken(\"all\")) {\n                      var queueAll = true;\n                      var queueLast = false;\n                  } else if (tokens.matchToken(\"first\")) {\n                      var queueFirst = true;\n                  } else if (tokens.matchToken(\"none\")) {\n                      var queueNone = true;\n                  } else {\n                      tokens.requireToken(\"last\");\n                  }\n              }\n          }\n\n          var start = parser.requireElement(\"commandList\", tokens);\n          parser.ensureTerminated(start);\n\n          var errorSymbol, errorHandler;\n          if (tokens.matchToken(\"catch\")) {\n              errorSymbol = tokens.requireTokenType(\"IDENTIFIER\").value;\n              errorHandler = parser.requireElement(\"commandList\", tokens);\n              parser.ensureTerminated(errorHandler);\n          }\n\n          if (tokens.matchToken(\"finally\")) {\n              var finallyHandler = parser.requireElement(\"commandList\", tokens);\n              parser.ensureTerminated(finallyHandler);\n          }\n\n          var onFeature = {\n              displayName: displayName,\n              events: events,\n              start: start,\n              every: every,\n              execCount: 0,\n              errorHandler: errorHandler,\n              errorSymbol: errorSymbol,\n              execute: function (/** @type {Context} */ ctx) {\n                  let eventQueueInfo = runtime.getEventQueueFor(ctx.me, onFeature);\n                  if (eventQueueInfo.executing && every === false) {\n                      if (queueNone || (queueFirst && eventQueueInfo.queue.length > 0)) {\n                          return;\n                      }\n                      if (queueLast) {\n                          eventQueueInfo.queue.length = 0;\n                      }\n                      eventQueueInfo.queue.push(ctx);\n                      return;\n                  }\n                  onFeature.execCount++;\n                  eventQueueInfo.executing = true;\n                  ctx.meta.onHalt = function () {\n                      eventQueueInfo.executing = false;\n                      var queued = eventQueueInfo.queue.shift();\n                      if (queued) {\n                          setTimeout(function () {\n                              onFeature.execute(queued);\n                          }, 1);\n                      }\n                  };\n                  ctx.meta.reject = function (err) {\n                      console.error(err.message ? err.message : err);\n                      var hypertrace = runtime.getHyperTrace(ctx, err);\n                      if (hypertrace) {\n                          hypertrace.print();\n                      }\n                      runtime.triggerEvent(ctx.me, \"exception\", {\n                          error: err,\n                      });\n                  };\n                  start.execute(ctx);\n              },\n              install: function (elt, source) {\n                  for (const eventSpec of onFeature.events) {\n                      var targets;\n                      if (eventSpec.elsewhere) {\n                          targets = [document];\n                      } else if (eventSpec.from) {\n                          targets = eventSpec.from.evaluate(runtime.makeContext(elt, onFeature, elt, null));\n                      } else {\n                          targets = [elt];\n                      }\n                      runtime.implicitLoop(targets, function (target) {\n                          // OK NO PROMISE\n\n                          var eventName = eventSpec.on;\n                          if (target == null) {\n                            console.warn(\"'%s' feature ignored because target does not exists:\", displayName, elt);\n                            return;\n                          }\n                          \n                          if (eventSpec.mutationSpec) {\n                              eventName = \"hyperscript:mutation\";\n                              const observer = new MutationObserver(function (mutationList, observer) {\n                                  if (!onFeature.executing) {\n                                      runtime.triggerEvent(target, eventName, {\n                                          mutationList: mutationList,\n                                          observer: observer,\n                                      });\n                                  }\n                              });\n                              observer.observe(target, eventSpec.mutationSpec);\n                          }\n\n                          if (eventSpec.intersectionSpec) {\n                              eventName = \"hyperscript:insersection\";\n                              const observer = new IntersectionObserver(function (entries) {\n                                  for (const entry of entries) {\n                                      var detail = {\n                                          observer: observer,\n                                      };\n                                      detail = Object.assign(detail, entry);\n                                      detail[\"intersecting\"] = entry.isIntersecting;\n                                      runtime.triggerEvent(target, eventName, detail);\n                                  }\n                              }, eventSpec.intersectionSpec);\n                              observer.observe(target);\n                          }\n\n                          var addEventListener = target.addEventListener || target.on;\n                          addEventListener.call(target, eventName, function listener(evt) {\n                              // OK NO PROMISE\n                              if (typeof Node !== 'undefined' && elt instanceof Node && target !== elt && !elt.isConnected) {\n                                  target.removeEventListener(eventName, listener);\n                                  return;\n                              }\n\n                              var ctx = runtime.makeContext(elt, onFeature, elt, evt);\n                              if (eventSpec.elsewhere && elt.contains(evt.target)) {\n                                  return;\n                              }\n                              if (eventSpec.from) {\n                                  ctx.result = target;\n                              }\n\n                              // establish context\n                              for (const arg of eventSpec.args) {\n                                  let eventValue = ctx.event[arg.value];\n                                  if (eventValue !== undefined) {\n                                      ctx.locals[arg.value] = eventValue;\n                                  } else if ('detail' in ctx.event) {\n                                      ctx.locals[arg.value] = ctx.event['detail'][arg.value];\n                                  }\n                              }\n\n                              // install error handler if any\n                              ctx.meta.errorHandler = errorHandler;\n                              ctx.meta.errorSymbol = errorSymbol;\n                              ctx.meta.finallyHandler = finallyHandler;\n\n                              // apply filter\n                              if (eventSpec.filter) {\n                                  var initialCtx = ctx.meta.context;\n                                  ctx.meta.context = ctx.event;\n                                  try {\n                                      var value = eventSpec.filter.evaluate(ctx); //OK NO PROMISE\n                                      if (value) {\n                                          // match the javascript semantics for if statements\n                                      } else {\n                                          return;\n                                      }\n                                  } finally {\n                                      ctx.meta.context = initialCtx;\n                                  }\n                              }\n\n                              if (eventSpec.inExpr) {\n                                  var inElement = evt.target;\n                                  while (true) {\n                                      if (inElement.matches && inElement.matches(eventSpec.inExpr.css)) {\n                                          ctx.result = inElement;\n                                          break;\n                                      } else {\n                                          inElement = inElement.parentElement;\n                                          if (inElement == null) {\n                                              return; // no match found\n                                          }\n                                      }\n                                  }\n                              }\n\n                              // verify counts\n                              eventSpec.execCount++;\n                              if (eventSpec.startCount) {\n                                  if (eventSpec.endCount) {\n                                      if (\n                                          eventSpec.execCount < eventSpec.startCount ||\n                                          eventSpec.execCount > eventSpec.endCount\n                                      ) {\n                                          return;\n                                      }\n                                  } else if (eventSpec.unbounded) {\n                                      if (eventSpec.execCount < eventSpec.startCount) {\n                                          return;\n                                      }\n                                  } else if (eventSpec.execCount !== eventSpec.startCount) {\n                                      return;\n                                  }\n                              }\n\n                              //debounce\n                              if (eventSpec.debounceTime) {\n                                  if (eventSpec.debounced) {\n                                      clearTimeout(eventSpec.debounced);\n                                  }\n                                  eventSpec.debounced = setTimeout(function () {\n                                      onFeature.execute(ctx);\n                                  }, eventSpec.debounceTime);\n                                  return;\n                              }\n\n                              // throttle\n                              if (eventSpec.throttleTime) {\n                                  if (\n                                      eventSpec.lastExec &&\n                                      Date.now() < (eventSpec.lastExec + eventSpec.throttleTime)\n                                  ) {\n                                      return;\n                                  } else {\n                                      eventSpec.lastExec = Date.now();\n                                  }\n                              }\n\n                              // apply execute\n                              onFeature.execute(ctx);\n                          });\n                      });\n                  }\n              },\n              executing: undefined\n          };\n          parser.setParent(start, onFeature);\n          return onFeature;\n      });\n\n      parser.addFeature(\"def\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"def\")) return;\n          var functionName = parser.requireElement(\"dotOrColonPath\", tokens);\n          var nameVal = functionName.evaluate(); // OK\n          var nameSpace = nameVal.split(\".\");\n          var funcName = nameSpace.pop();\n\n          var args = [];\n          if (tokens.matchOpToken(\"(\")) {\n              if (tokens.matchOpToken(\")\")) {\n                  // emtpy args list\n              } else {\n                  do {\n                      args.push(tokens.requireTokenType(\"IDENTIFIER\"));\n                  } while (tokens.matchOpToken(\",\"));\n                  tokens.requireOpToken(\")\");\n              }\n          }\n\n          var start = parser.requireElement(\"commandList\", tokens);\n\n          var errorSymbol, errorHandler;\n          if (tokens.matchToken(\"catch\")) {\n              errorSymbol = tokens.requireTokenType(\"IDENTIFIER\").value;\n              errorHandler = parser.parseElement(\"commandList\", tokens);\n          }\n\n          if (tokens.matchToken(\"finally\")) {\n              var finallyHandler = parser.requireElement(\"commandList\", tokens);\n              parser.ensureTerminated(finallyHandler);\n          }\n\n          var functionFeature = {\n              displayName:\n                  funcName +\n                  \"(\" +\n                  args\n                      .map(function (arg) {\n                          return arg.value;\n                      })\n                      .join(\", \") +\n                  \")\",\n              name: funcName,\n              args: args,\n              start: start,\n              errorHandler: errorHandler,\n              errorSymbol: errorSymbol,\n              finallyHandler: finallyHandler,\n              install: function (target, source) {\n                  var func = function () {\n                      // null, worker\n                      var ctx = runtime.makeContext(source, functionFeature, target, null);\n\n                      // install error handler if any\n                      ctx.meta.errorHandler = errorHandler;\n                      ctx.meta.errorSymbol = errorSymbol;\n                      ctx.meta.finallyHandler = finallyHandler;\n\n                      for (var i = 0; i < args.length; i++) {\n                          var name = args[i];\n                          var argumentVal = arguments[i];\n                          if (name) {\n                              ctx.locals[name.value] = argumentVal;\n                          }\n                      }\n                      ctx.meta.caller = arguments[args.length];\n                      if (ctx.meta.caller) {\n                          ctx.meta.callingCommand = ctx.meta.caller.meta.command;\n                      }\n                      var resolve,\n                          reject = null;\n                      var promise = new Promise(function (theResolve, theReject) {\n                          resolve = theResolve;\n                          reject = theReject;\n                      });\n                      start.execute(ctx);\n                      if (ctx.meta.returned) {\n                          return ctx.meta.returnValue;\n                      } else {\n                          ctx.meta.resolve = resolve;\n                          ctx.meta.reject = reject;\n                          return promise;\n                      }\n                  };\n                  func['hyperfunc'] = true;\n                  func['hypername'] = nameVal;\n                  runtime.assignToNamespace(target, nameSpace, funcName, func);\n              },\n          };\n\n          parser.ensureTerminated(start);\n\n          // terminate error handler if any\n          if (errorHandler) {\n              parser.ensureTerminated(errorHandler);\n          }\n\n          parser.setParent(start, functionFeature);\n          return functionFeature;\n      });\n\n      parser.addFeature(\"set\", function (parser, runtime, tokens) {\n          let setCmd = parser.parseElement(\"setCommand\", tokens);\n          if (setCmd) {\n              if (setCmd.target.scope !== \"element\") {\n                  parser.raiseParseError(tokens, \"variables declared at the feature level must be element scoped.\");\n              }\n              let setFeature = {\n                  start: setCmd,\n                  install: function (target, source) {\n                      setCmd && setCmd.execute(runtime.makeContext(target, setFeature, target, null));\n                  },\n              };\n              parser.ensureTerminated(setCmd);\n              return setFeature;\n          }\n      });\n\n      parser.addFeature(\"init\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"init\")) return;\n\n          var immediately = tokens.matchToken(\"immediately\");\n\n          var start = parser.requireElement(\"commandList\", tokens);\n          var initFeature = {\n              start: start,\n              install: function (target, source) {\n                  let handler = function () {\n                      start && start.execute(runtime.makeContext(target, initFeature, target, null));\n                  };\n                  if (immediately) {\n                      handler();\n                  } else {\n                      setTimeout(handler, 0);\n                  }\n              },\n          };\n  \n          // terminate body\n          parser.ensureTerminated(start);\n          parser.setParent(start, initFeature);\n          return initFeature;\n      });\n\n      parser.addFeature(\"worker\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"worker\")) {\n              parser.raiseParseError(\n                  tokens,\n                  \"In order to use the 'worker' feature, include \" +\n                      \"the _hyperscript worker plugin. See \" +\n                      \"https://hyperscript.org/features/worker/ for \" +\n                      \"more info.\"\n              );\n              return undefined\n          }\n      });\n\n      parser.addFeature(\"behavior\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"behavior\")) return;\n          var path = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n          var nameSpace = path.split(\".\");\n          var name = nameSpace.pop();\n\n          var formalParams = [];\n          if (tokens.matchOpToken(\"(\") && !tokens.matchOpToken(\")\")) {\n              do {\n                  formalParams.push(tokens.requireTokenType(\"IDENTIFIER\").value);\n              } while (tokens.matchOpToken(\",\"));\n              tokens.requireOpToken(\")\");\n          }\n          var hs = parser.requireElement(\"hyperscript\", tokens);\n          for (var i = 0; i < hs.features.length; i++) {\n              var feature = hs.features[i];\n              feature.behavior = path;\n          }\n\n          return {\n              install: function (target, source) {\n                  runtime.assignToNamespace(\n                      globalScope.document && globalScope.document.body,\n                      nameSpace,\n                      name,\n                      function (target, source, innerArgs) {\n                          var internalData = runtime.getInternalData(target);\n                          var elementScope = getOrInitObject(internalData, path + \"Scope\");\n                          for (var i = 0; i < formalParams.length; i++) {\n                              elementScope[formalParams[i]] = innerArgs[formalParams[i]];\n                          }\n                          hs.apply(target, source);\n                      }\n                  );\n              },\n          };\n      });\n\n      parser.addFeature(\"install\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"install\")) return;\n          var behaviorPath = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n          var behaviorNamespace = behaviorPath.split(\".\");\n          var args = parser.parseElement(\"namedArgumentList\", tokens);\n\n          var installFeature;\n          return (installFeature = {\n              install: function (target, source) {\n                  runtime.unifiedEval(\n                      {\n                          args: [args],\n                          op: function (ctx, args) {\n                              var behavior = globalScope;\n                              for (var i = 0; i < behaviorNamespace.length; i++) {\n                                  behavior = behavior[behaviorNamespace[i]];\n                                  if (typeof behavior !== \"object\" && typeof behavior !== \"function\")\n                                      throw new Error(\"No such behavior defined as \" + behaviorPath);\n                              }\n\n                              if (!(behavior instanceof Function))\n                                  throw new Error(behaviorPath + \" is not a behavior\");\n\n                              behavior(target, source, args);\n                          },\n                      },\n                      runtime.makeContext(target, installFeature, target, null)\n                  );\n              },\n          });\n      });\n\n      parser.addGrammarElement(\"jsBody\", function (parser, runtime, tokens) {\n          var jsSourceStart = tokens.currentToken().start;\n          var jsLastToken = tokens.currentToken();\n\n          var funcNames = [];\n          var funcName = \"\";\n          var expectFunctionDeclaration = false;\n          while (tokens.hasMore()) {\n              jsLastToken = tokens.consumeToken();\n              var peek = tokens.token(0, true);\n              if (peek.type === \"IDENTIFIER\" && peek.value === \"end\") {\n                  break;\n              }\n              if (expectFunctionDeclaration) {\n                  if (jsLastToken.type === \"IDENTIFIER\" || jsLastToken.type === \"NUMBER\") {\n                      funcName += jsLastToken.value;\n                  } else {\n                      if (funcName !== \"\") funcNames.push(funcName);\n                      funcName = \"\";\n                      expectFunctionDeclaration = false;\n                  }\n              } else if (jsLastToken.type === \"IDENTIFIER\" && jsLastToken.value === \"function\") {\n                  expectFunctionDeclaration = true;\n              }\n          }\n          var jsSourceEnd = jsLastToken.end + 1;\n\n          return {\n              type: \"jsBody\",\n              exposedFunctionNames: funcNames,\n              jsSource: tokens.source.substring(jsSourceStart, jsSourceEnd),\n          };\n      });\n\n      parser.addFeature(\"js\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"js\")) return;\n          var jsBody = parser.requireElement(\"jsBody\", tokens);\n\n          var jsSource =\n              jsBody.jsSource +\n              \"\\nreturn { \" +\n              jsBody.exposedFunctionNames\n                  .map(function (name) {\n                      return name + \":\" + name;\n                  })\n                  .join(\",\") +\n              \" } \";\n          var func = new Function(jsSource);\n\n          return {\n              jsSource: jsSource,\n              function: func,\n              exposedFunctionNames: jsBody.exposedFunctionNames,\n              install: function () {\n                  Object.assign(globalScope, func());\n              },\n          };\n      });\n\n      parser.addCommand(\"js\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"js\")) return;\n          // Parse inputs\n          var inputs = [];\n          if (tokens.matchOpToken(\"(\")) {\n              if (tokens.matchOpToken(\")\")) {\n                  // empty input list\n              } else {\n                  do {\n                      var inp = tokens.requireTokenType(\"IDENTIFIER\");\n                      inputs.push(inp.value);\n                  } while (tokens.matchOpToken(\",\"));\n                  tokens.requireOpToken(\")\");\n              }\n          }\n\n          var jsBody = parser.requireElement(\"jsBody\", tokens);\n          tokens.matchToken(\"end\");\n\n          var func = varargConstructor(Function, inputs.concat([jsBody.jsSource]));\n\n          var command = {\n              jsSource: jsBody.jsSource,\n              function: func,\n              inputs: inputs,\n              op: function (context) {\n                  var args = [];\n                  inputs.forEach(function (input) {\n                      args.push(runtime.resolveSymbol(input, context, 'default'));\n                  });\n                  var result = func.apply(globalScope, args);\n                  if (result && typeof result.then === \"function\") {\n                      return new Promise(function (resolve) {\n                          result.then(function (actualResult) {\n                              context.result = actualResult;\n                              resolve(runtime.findNext(this, context));\n                          });\n                      });\n                  } else {\n                      context.result = result;\n                      return runtime.findNext(this, context);\n                  }\n              },\n          };\n          return command;\n      });\n\n      parser.addCommand(\"async\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"async\")) return;\n          if (tokens.matchToken(\"do\")) {\n              var body = parser.requireElement(\"commandList\", tokens);\n\n              // Append halt\n              var end = body;\n              while (end.next) end = end.next;\n              end.next = runtime.HALT;\n\n              tokens.requireToken(\"end\");\n          } else {\n              var body = parser.requireElement(\"command\", tokens);\n          }\n          var command = {\n              body: body,\n              op: function (context) {\n                  setTimeout(function () {\n                      body.execute(context);\n                  });\n                  return runtime.findNext(this, context);\n              },\n          };\n          parser.setParent(body, command);\n          return command;\n      });\n\n      parser.addCommand(\"tell\", function (parser, runtime, tokens) {\n          var startToken = tokens.currentToken();\n          if (!tokens.matchToken(\"tell\")) return;\n          var value = parser.requireElement(\"expression\", tokens);\n          var body = parser.requireElement(\"commandList\", tokens);\n          if (tokens.hasMore() && !parser.featureStart(tokens.currentToken())) {\n              tokens.requireToken(\"end\");\n          }\n          var slot = \"tell_\" + startToken.start;\n          var tellCmd = {\n              value: value,\n              body: body,\n              args: [value],\n              resolveNext: function (context) {\n                  var iterator = context.meta.iterators[slot];\n                  if (iterator.index < iterator.value.length) {\n                      context.you = iterator.value[iterator.index++];\n                      return body;\n                  } else {\n                      // restore original me\n                      context.you = iterator.originalYou;\n                      if (this.next) {\n                          return this.next;\n                      } else {\n                          return runtime.findNext(this.parent, context);\n                      }\n                  }\n              },\n              op: function (context, value) {\n                  if (value == null) {\n                      value = [];\n                  } else if (!(Array.isArray(value) || value instanceof NodeList)) {\n                      value = [value];\n                  }\n                  context.meta.iterators[slot] = {\n                      originalYou: context.you,\n                      index: 0,\n                      value: value,\n                  };\n                  return this.resolveNext(context);\n              },\n          };\n          parser.setParent(body, tellCmd);\n          return tellCmd;\n      });\n\n      parser.addCommand(\"wait\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"wait\")) return;\n          var command;\n\n          // wait on event\n          if (tokens.matchToken(\"for\")) {\n              tokens.matchToken(\"a\"); // optional \"a\"\n              var events = [];\n              do {\n                  var lookahead = tokens.token(0);\n                  if (lookahead.type === 'NUMBER' || lookahead.type === 'L_PAREN') {\n                      events.push({\n                          time: parser.requireElement('expression', tokens).evaluate() // TODO: do we want to allow async here?\n                      })\n                  } else {\n                      events.push({\n                          name: parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\").evaluate(),\n                          args: parseEventArgs(tokens),\n                      });\n                  }\n              } while (tokens.matchToken(\"or\"));\n\n              if (tokens.matchToken(\"from\")) {\n                  var on = parser.requireElement(\"expression\", tokens);\n              }\n\n              // wait on event\n              command = {\n                  event: events,\n                  on: on,\n                  args: [on],\n                  op: function (context, on) {\n                      var target = on ? on : context.me;\n                      if (!(target instanceof EventTarget))\n                          throw new Error(\"Not a valid event target: \" + this.on.sourceFor());\n                      return new Promise((resolve) => {\n                          var resolved = false;\n                          for (const eventInfo of events) {\n                              var listener = (event) => {\n                                  context.result = event;\n                                  if (eventInfo.args) {\n                                      for (const arg of eventInfo.args) {\n                                          context.locals[arg.value] =\n                                              event[arg.value] || (event.detail ? event.detail[arg.value] : null);\n                                      }\n                                  }\n                                  if (!resolved) {\n                                      resolved = true;\n                                      resolve(runtime.findNext(this, context));\n                                  }\n                              };\n                              if (eventInfo.name){\n                                  target.addEventListener(eventInfo.name, listener, {once: true});\n                              } else if (eventInfo.time != null) {\n                                  setTimeout(listener, eventInfo.time, eventInfo.time)\n                              }\n                          }\n                      });\n                  },\n              };\n              return command;\n          } else {\n              var time;\n              if (tokens.matchToken(\"a\")) {\n                  tokens.requireToken(\"tick\");\n                  time = 0;\n              } else {\n                  time = parser.requireElement(\"expression\", tokens);\n              }\n\n              command = {\n                  type: \"waitCmd\",\n                  time: time,\n                  args: [time],\n                  op: function (context, timeValue) {\n                      return new Promise((resolve) => {\n                          setTimeout(() => {\n                              resolve(runtime.findNext(this, context));\n                          }, timeValue);\n                      });\n                  },\n                  execute: function (context) {\n                      return runtime.unifiedExec(this, context);\n                  },\n              };\n              return command;\n          }\n      });\n\n      // TODO  - colon path needs to eventually become part of ruby-style symbols\n      parser.addGrammarElement(\"dotOrColonPath\", function (parser, runtime, tokens) {\n          var root = tokens.matchTokenType(\"IDENTIFIER\");\n          if (root) {\n              var path = [root.value];\n\n              var separator = tokens.matchOpToken(\".\") || tokens.matchOpToken(\":\");\n              if (separator) {\n                  do {\n                      path.push(tokens.requireTokenType(\"IDENTIFIER\", \"NUMBER\").value);\n                  } while (tokens.matchOpToken(separator.value));\n              }\n\n              return {\n                  type: \"dotOrColonPath\",\n                  path: path,\n                  evaluate: function () {\n                      return path.join(separator ? separator.value : \"\");\n                  },\n              };\n          }\n      });\n\n\n      parser.addGrammarElement(\"eventName\", function (parser, runtime, tokens) {\n          var token;\n          if ((token = tokens.matchTokenType(\"STRING\"))) {\n              return {\n                  evaluate: function() {\n                      return token.value;\n                  },\n              };\n          }\n\n          return parser.parseElement(\"dotOrColonPath\", tokens);\n      });\n\n      function parseSendCmd(cmdType, parser, runtime, tokens) {\n          var eventName = parser.requireElement(\"eventName\", tokens);\n\n          var details = parser.parseElement(\"namedArgumentList\", tokens);\n          if ((cmdType === \"send\" && tokens.matchToken(\"to\")) ||\n              (cmdType === \"trigger\" && tokens.matchToken(\"on\"))) {\n              var toExpr = parser.requireElement(\"expression\", tokens);\n          } else {\n              var toExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n          }\n\n          var sendCmd = {\n              eventName: eventName,\n              details: details,\n              to: toExpr,\n              args: [toExpr, eventName, details],\n              op: function (context, to, eventName, details) {\n                  runtime.nullCheck(to, toExpr);\n                  runtime.forEach(to, function (target) {\n                      runtime.triggerEvent(target, eventName, details, context.me);\n                  });\n                  return runtime.findNext(sendCmd, context);\n              },\n          };\n          return sendCmd;\n      }\n\n      parser.addCommand(\"trigger\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"trigger\")) {\n              return parseSendCmd(\"trigger\", parser, runtime, tokens);\n          }\n      });\n\n      parser.addCommand(\"send\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"send\")) {\n              return parseSendCmd(\"send\", parser, runtime, tokens);\n          }\n      });\n\n      var parseReturnFunction = function (parser, runtime, tokens, returnAValue) {\n          if (returnAValue) {\n              if (parser.commandBoundary(tokens.currentToken())) {\n                  parser.raiseParseError(tokens, \"'return' commands must return a value.  If you do not wish to return a value, use 'exit' instead.\");\n              } else {\n                  var value = parser.requireElement(\"expression\", tokens);\n              }\n          }\n\n          var returnCmd = {\n              value: value,\n              args: [value],\n              op: function (context, value) {\n                  var resolve = context.meta.resolve;\n                  context.meta.returned = true;\n                  context.meta.returnValue = value;\n                  if (resolve) {\n                      if (value) {\n                          resolve(value);\n                      } else {\n                          resolve();\n                      }\n                  }\n                  return runtime.HALT;\n              },\n          };\n          return returnCmd;\n      };\n\n      parser.addCommand(\"return\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"return\")) {\n              return parseReturnFunction(parser, runtime, tokens, true);\n          }\n      });\n\n      parser.addCommand(\"exit\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"exit\")) {\n              return parseReturnFunction(parser, runtime, tokens, false);\n          }\n      });\n\n      parser.addCommand(\"halt\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"halt\")) {\n              if (tokens.matchToken(\"the\")) {\n                  tokens.requireToken(\"event\");\n                  // optional possessive\n                  if (tokens.matchOpToken(\"'\")) {\n                      tokens.requireToken(\"s\");\n                  }\n                  var keepExecuting = true;\n              }\n              if (tokens.matchToken(\"bubbling\")) {\n                  var bubbling = true;\n              } else if (tokens.matchToken(\"default\")) {\n                  var haltDefault = true;\n              }\n              var exit = parseReturnFunction(parser, runtime, tokens, false);\n\n              var haltCmd = {\n                  keepExecuting: true,\n                  bubbling: bubbling,\n                  haltDefault: haltDefault,\n                  exit: exit,\n                  op: function (ctx) {\n                      if (ctx.event) {\n                          if (bubbling) {\n                              ctx.event.stopPropagation();\n                          } else if (haltDefault) {\n                              ctx.event.preventDefault();\n                          } else {\n                              ctx.event.stopPropagation();\n                              ctx.event.preventDefault();\n                          }\n                          if (keepExecuting) {\n                              return runtime.findNext(this, ctx);\n                          } else {\n                              return exit;\n                          }\n                      }\n                  },\n              };\n              return haltCmd;\n          }\n      });\n\n      parser.addCommand(\"log\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"log\")) return;\n          var exprs = [parser.parseElement(\"expression\", tokens)];\n          while (tokens.matchOpToken(\",\")) {\n              exprs.push(parser.requireElement(\"expression\", tokens));\n          }\n          if (tokens.matchToken(\"with\")) {\n              var withExpr = parser.requireElement(\"expression\", tokens);\n          }\n          var logCmd = {\n              exprs: exprs,\n              withExpr: withExpr,\n              args: [withExpr, exprs],\n              op: function (ctx, withExpr, values) {\n                  if (withExpr) {\n                      withExpr.apply(null, values);\n                  } else {\n                      console.log.apply(null, values);\n                  }\n                  return runtime.findNext(this, ctx);\n              },\n          };\n          return logCmd;\n      });\n\n      parser.addCommand(\"throw\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"throw\")) return;\n          var expr = parser.requireElement(\"expression\", tokens);\n          var throwCmd = {\n              expr: expr,\n              args: [expr],\n              op: function (ctx, expr) {\n                  runtime.registerHyperTrace(ctx, expr);\n                  throw expr;\n              },\n          };\n          return throwCmd;\n      });\n\n      var parseCallOrGet = function (parser, runtime, tokens) {\n          var expr = parser.requireElement(\"expression\", tokens);\n          var callCmd = {\n              expr: expr,\n              args: [expr],\n              op: function (context, result) {\n                  context.result = result;\n                  return runtime.findNext(callCmd, context);\n              },\n          };\n          return callCmd;\n      };\n      parser.addCommand(\"call\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"call\")) return;\n          var call = parseCallOrGet(parser, runtime, tokens);\n          if (call.expr && call.expr.type !== \"functionCall\") {\n              parser.raiseParseError(tokens, \"Must be a function invocation\");\n          }\n          return call;\n      });\n      parser.addCommand(\"get\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"get\")) {\n              return parseCallOrGet(parser, runtime, tokens);\n          }\n      });\n\n      parser.addCommand(\"make\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"make\")) return;\n          tokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n\n          var expr = parser.requireElement(\"expression\", tokens);\n\n          var args = [];\n          if (expr.type !== \"queryRef\" && tokens.matchToken(\"from\")) {\n              do {\n                  args.push(parser.requireElement(\"expression\", tokens));\n              } while (tokens.matchOpToken(\",\"));\n          }\n\n          if (tokens.matchToken(\"called\")) {\n              var target = parser.requireElement(\"symbol\", tokens);\n          }\n\n          var command;\n          if (expr.type === \"queryRef\") {\n              command = {\n                  op: function (ctx) {\n                      var match,\n                          tagname = \"div\",\n                          id,\n                          classes = [];\n                      var re = /(?:(^|#|\\.)([^#\\. ]+))/g;\n                      while ((match = re.exec(expr.css))) {\n                          if (match[1] === \"\") tagname = match[2].trim();\n                          else if (match[1] === \"#\") id = match[2].trim();\n                          else classes.push(match[2].trim());\n                      }\n\n                      var result = document.createElement(tagname);\n                      if (id !== undefined) result.id = id;\n                      for (var i = 0; i < classes.length; i++) {\n                          var cls = classes[i];\n                          result.classList.add(cls)\n                      }\n\n                      ctx.result = result;\n                      if (target){\n                          runtime.setSymbol(target.name, ctx, target.scope, result);\n                      }\n\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n              return command;\n          } else {\n              command = {\n                  args: [expr, args],\n                  op: function (ctx, expr, args) {\n                      ctx.result = varargConstructor(expr, args);\n                      if (target){\n                          runtime.setSymbol(target.name, ctx, target.scope, ctx.result);\n                      }\n\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n              return command;\n          }\n      });\n\n      parser.addGrammarElement(\"pseudoCommand\", function (parser, runtime, tokens) {\n\n          let lookAhead = tokens.token(1);\n          if (!(lookAhead && lookAhead.op && (lookAhead.value === '.' || lookAhead.value === \"(\"))) {\n              return null;\n          }\n\n          var expr = parser.requireElement(\"primaryExpression\", tokens);\n\n          var rootRoot = expr.root;\n          var root = expr;\n          while (rootRoot.root != null) {\n              root = root.root;\n              rootRoot = rootRoot.root;\n          }\n\n          if (expr.type !== \"functionCall\") {\n              parser.raiseParseError(tokens, \"Pseudo-commands must be function calls\");\n          }\n\n          if (root.type === \"functionCall\" && root.root.root == null) {\n              if (tokens.matchAnyToken(\"the\", \"to\", \"on\", \"with\", \"into\", \"from\", \"at\")) {\n                  var realRoot = parser.requireElement(\"expression\", tokens);\n              } else if (tokens.matchToken(\"me\")) {\n                  var realRoot = parser.requireElement(\"implicitMeTarget\", tokens);\n              }\n          }\n\n          /** @type {ASTNode} */\n\n          var pseudoCommand\n          if(realRoot){\n              pseudoCommand = {\n                  type: \"pseudoCommand\",\n                  root: realRoot,\n                  argExressions: root.argExressions,\n                  args: [realRoot, root.argExressions],\n                  op: function (context, rootRoot, args) {\n                      runtime.nullCheck(rootRoot, realRoot);\n                      var func = rootRoot[root.root.name];\n                      runtime.nullCheck(func, root);\n                      if (func.hyperfunc) {\n                          args.push(context);\n                      }\n                      context.result = func.apply(rootRoot, args);\n                      return runtime.findNext(pseudoCommand, context);\n                  },\n                  execute: function (context) {\n                      return runtime.unifiedExec(this, context);\n                  },\n              }\n          } else {\n              pseudoCommand = {\n                  type: \"pseudoCommand\",\n                  expr: expr,\n                  args: [expr],\n                  op: function (context, result) {\n                      context.result = result;\n                      return runtime.findNext(pseudoCommand, context);\n                  },\n                  execute: function (context) {\n                      return runtime.unifiedExec(this, context);\n                  },\n              };\n          }\n\n          return pseudoCommand;\n      });\n\n      /**\n      * @param {Parser} parser\n      * @param {Runtime} runtime\n      * @param {Tokens} tokens\n      * @param {*} target\n      * @param {*} value\n      * @returns\n      */\n      var makeSetter = function (parser, runtime, tokens, target, value) {\n          var symbolWrite = target.type === \"symbol\";\n          var attributeWrite = target.type === \"attributeRef\";\n          var styleWrite = target.type === \"styleRef\";\n          var arrayWrite = target.type === \"arrayIndex\";\n\n          if (!(attributeWrite || styleWrite || symbolWrite) && target.root == null) {\n              parser.raiseParseError(tokens, \"Can only put directly into symbols, not references\");\n          }\n\n          var rootElt = null;\n          var prop = null;\n          if (symbolWrite) {\n              // rootElt is null\n          } else if (attributeWrite || styleWrite) {\n              rootElt = parser.requireElement(\"implicitMeTarget\", tokens);\n              var attribute = target;\n          } else if(arrayWrite) {\n              prop = target.firstIndex;\n              rootElt = target.root;\n          } else {\n              prop = target.prop ? target.prop.value : null;\n              var attribute = target.attribute;\n              rootElt = target.root;\n          }\n\n          /** @type {ASTNode} */\n          var setCmd = {\n              target: target,\n              symbolWrite: symbolWrite,\n              value: value,\n              args: [rootElt, prop, value],\n              op: function (context, root, prop, valueToSet) {\n                  if (symbolWrite) {\n                      runtime.setSymbol(target.name, context, target.scope, valueToSet);\n                  } else {\n                      runtime.nullCheck(root, rootElt);\n                      if (arrayWrite) {\n                          root[prop] = valueToSet;\n                      } else {\n                          runtime.implicitLoop(root, function (elt) {\n                              if (attribute) {\n                                  if (attribute.type === \"attributeRef\") {\n                                      if (valueToSet == null) {\n                                          elt.removeAttribute(attribute.name);\n                                      } else {\n                                          elt.setAttribute(attribute.name, valueToSet);\n                                      }\n                                  } else {\n                                      elt.style[attribute.name] = valueToSet;\n                                  }\n                              } else {\n                                  elt[prop] = valueToSet;\n                              }\n                          });\n                      }\n                  }\n                  return runtime.findNext(this, context);\n              },\n              parent: undefined\n          };\n          return setCmd;\n      };\n\n      parser.addCommand(\"default\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"default\")) return;\n          var target = parser.requireElement(\"assignableExpression\", tokens);\n          tokens.requireToken(\"to\");\n\n          var value = parser.requireElement(\"expression\", tokens);\n\n          /** @type {ASTNode} */\n          var setter = makeSetter(parser, runtime, tokens, target, value);\n          var defaultCmd = {\n              target: target,\n              value: value,\n              setter: setter,\n              args: [target],\n              op: function (context, target) {\n                  if (target) {\n                      return runtime.findNext(this, context);\n                  } else {\n                      return setter;\n                  }\n              },\n          };\n          setter.parent = defaultCmd;\n          return defaultCmd;\n      });\n\n      parser.addCommand(\"set\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"set\")) return;\n          if (tokens.currentToken().type === \"L_BRACE\") {\n              var obj = parser.requireElement(\"objectLiteral\", tokens);\n              tokens.requireToken(\"on\");\n              var target = parser.requireElement(\"expression\", tokens);\n\n              var command = {\n                  objectLiteral: obj,\n                  target: target,\n                  args: [obj, target],\n                  op: function (ctx, obj, target) {\n                      Object.assign(target, obj);\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n              return command;\n          }\n\n          try {\n              tokens.pushFollow(\"to\");\n              var target = parser.requireElement(\"assignableExpression\", tokens);\n          } finally {\n              tokens.popFollow();\n          }\n          tokens.requireToken(\"to\");\n          var value = parser.requireElement(\"expression\", tokens);\n          return makeSetter(parser, runtime, tokens, target, value);\n      });\n\n      parser.addCommand(\"if\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"if\")) return;\n          var expr = parser.requireElement(\"expression\", tokens);\n          tokens.matchToken(\"then\"); // optional 'then'\n          var trueBranch = parser.parseElement(\"commandList\", tokens);\n          if (tokens.matchToken(\"else\") || tokens.matchToken(\"otherwise\")) {\n              var falseBranch = parser.parseElement(\"commandList\", tokens);\n          }\n          if (tokens.hasMore()) {\n              tokens.requireToken(\"end\");\n          }\n\n          /** @type {ASTNode} */\n          var ifCmd = {\n              expr: expr,\n              trueBranch: trueBranch,\n              falseBranch: falseBranch,\n              args: [expr],\n              op: function (context, exprValue) {\n                  if (exprValue) {\n                      return trueBranch;\n                  } else if (falseBranch) {\n                      return falseBranch;\n                  } else {\n                      return runtime.findNext(this, context);\n                  }\n              },\n          };\n          parser.setParent(trueBranch, ifCmd);\n          parser.setParent(falseBranch, ifCmd);\n          return ifCmd;\n      });\n\n      var parseRepeatExpression = function (parser, tokens, runtime, startedWithForToken) {\n          var innerStartToken = tokens.currentToken();\n          var identifier;\n          if (tokens.matchToken(\"for\") || startedWithForToken) {\n              var identifierToken = tokens.requireTokenType(\"IDENTIFIER\");\n              identifier = identifierToken.value;\n              tokens.requireToken(\"in\");\n              var expression = parser.requireElement(\"expression\", tokens);\n          } else if (tokens.matchToken(\"in\")) {\n              identifier = \"it\";\n              var expression = parser.requireElement(\"expression\", tokens);\n          } else if (tokens.matchToken(\"while\")) {\n              var whileExpr = parser.requireElement(\"expression\", tokens);\n          } else if (tokens.matchToken(\"until\")) {\n              var isUntil = true;\n              if (tokens.matchToken(\"event\")) {\n                  var evt = parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\");\n                  if (tokens.matchToken(\"from\")) {\n                      var on = parser.requireElement(\"expression\", tokens);\n                  }\n              } else {\n                  var whileExpr = parser.requireElement(\"expression\", tokens);\n              }\n          } else {\n              if (!parser.commandBoundary(tokens.currentToken()) &&\n                  tokens.currentToken().value !== 'forever') {\n                  var times = parser.requireElement(\"expression\", tokens);\n                  tokens.requireToken(\"times\");\n              } else {\n                  tokens.matchToken(\"forever\"); // consume optional forever\n                  var forever = true;\n              }\n          }\n\n          if (tokens.matchToken(\"index\")) {\n              var identifierToken = tokens.requireTokenType(\"IDENTIFIER\");\n              var indexIdentifier = identifierToken.value;\n          }\n\n          var loop = parser.parseElement(\"commandList\", tokens);\n          if (loop && evt) {\n              // if this is an event based loop, wait a tick at the end of the loop so that\n              // events have a chance to trigger in the loop condition o_O)))\n              var last = loop;\n              while (last.next) {\n                  last = last.next;\n              }\n              var waitATick = {\n                  type: \"waitATick\",\n                  op: function () {\n                      return new Promise(function (resolve) {\n                          setTimeout(function () {\n                              resolve(runtime.findNext(waitATick));\n                          }, 0);\n                      });\n                  },\n              };\n              last.next = waitATick;\n          }\n          if (tokens.hasMore()) {\n              tokens.requireToken(\"end\");\n          }\n\n          if (identifier == null) {\n              identifier = \"_implicit_repeat_\" + innerStartToken.start;\n              var slot:string = identifier;\n          } else {\n              var slot:string = identifier + \"_\" + innerStartToken.start;\n          }\n\n          var repeatCmd = {\n              identifier: identifier,\n              indexIdentifier: indexIdentifier,\n              slot: slot,\n              expression: expression,\n              forever: forever,\n              times: times,\n              until: isUntil,\n              event: evt,\n              on: on,\n              whileExpr: whileExpr,\n              resolveNext: function () {\n                  return this;\n              },\n              loop: loop,\n              args: [whileExpr, times],\n              op: function (context, whileValue, times) {\n                  var iteratorInfo = context.meta.iterators[slot];\n                  var keepLooping = false;\n                  var loopVal = null;\n                  if (this.forever) {\n                      keepLooping = true;\n                  } else if (this.until) {\n                      if (evt) {\n                          keepLooping = context.meta.iterators[slot].eventFired === false;\n                      } else {\n                          keepLooping = whileValue !== true;\n                      }\n                  } else if (whileExpr) {\n                      keepLooping = whileValue;\n                  } else if (times) {\n                      keepLooping = iteratorInfo.index < times;\n                  } else {\n                      var nextValFromIterator = iteratorInfo.iterator.next();\n                      keepLooping = !nextValFromIterator.done;\n                      loopVal = nextValFromIterator.value;\n                  }\n\n                  if (keepLooping) {\n                      if (iteratorInfo.value) {\n                          context.result = context.locals[identifier] = loopVal;\n                      } else {\n                          context.result = iteratorInfo.index;\n                      }\n                      if (indexIdentifier) {\n                          context.locals[indexIdentifier] = iteratorInfo.index;\n                      }\n                      iteratorInfo.index++;\n                      return loop;\n                  } else {\n                      context.meta.iterators[slot] = null;\n                      return runtime.findNext(this.parent, context);\n                  }\n              },\n          };\n          parser.setParent(loop, repeatCmd);\n          var repeatInit = {\n              name: \"repeatInit\",\n              args: [expression, evt, on],\n              op: function (context, value, event, on) {\n                  var iteratorInfo = {\n                    iterator: undefined,\n                      index: 0,\n                      value: value,\n                      eventFired: false,\n                  };\n                  context.meta.iterators[slot] = iteratorInfo;\n                  if (value && value[Symbol.iterator]) {\n                      iteratorInfo.iterator = value[Symbol.iterator]();\n                  }\n                  if (evt) {\n                      var target = on || context.me;\n                      target.addEventListener(\n                          event,\n                          function (e) {\n                              context.meta.iterators[slot].eventFired = true;\n                          },\n                          { once: true }\n                      );\n                  }\n                  return repeatCmd; // continue to loop\n              },\n              execute: function (context) {\n                  return runtime.unifiedExec(this, context);\n              },\n          };\n          parser.setParent(repeatCmd, repeatInit);\n          return repeatInit;\n      };\n\n      parser.addCommand(\"repeat\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"repeat\")) {\n              return parseRepeatExpression(parser, tokens, runtime, false);\n          }\n      });\n\n      parser.addCommand(\"for\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"for\")) {\n              return parseRepeatExpression(parser, tokens, runtime, true);\n          }\n      });\n\n    parser.addCommand(\"continue\", function (parser, runtime, tokens) {\n\n      if (!tokens.matchToken(\"continue\")) return;\n\n      var command = {\n        op: function (context) {\n\n          // scan for the closest repeat statement\n          for (var parent = this.parent ; true ; parent = parent.parent) {\n\n            if (parent == undefined) {\n              parser.raiseParseError(tokens, \"Command `continue` cannot be used outside of a `repeat` loop.\")\n            }\n            if (parent.loop != undefined) {\n              return parent.resolveNext(context)\n            }\n          }\n        }\n      };\n      return command;\n    });\n\n    parser.addCommand(\"break\", function (parser, runtime, tokens) {\n\n      if (!tokens.matchToken(\"break\")) return;\n\n      var command = {\n        op: function (context) {\n\n          // scan for the closest repeat statement\n          for (var parent = this.parent ; true ; parent = parent.parent) {\n\n            if (parent == undefined) {\n              parser.raiseParseError(tokens, \"Command `continue` cannot be used outside of a `repeat` loop.\")\n            }\n            if (parent.loop != undefined) {\n                return runtime.findNext(parent.parent, context);\n            }\n          }\n        }\n      };\n      return command;\n    });\n\n      parser.addGrammarElement(\"stringLike\", function (parser, runtime, tokens) {\n          return parser.parseAnyOf([\"string\", \"nakedString\"], tokens);\n      });\n\n      parser.addCommand(\"append\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"append\")) return;\n          var targetExpr = null;\n\n          var value = parser.requireElement(\"expression\", tokens);\n\n          /** @type {ASTNode} */\n          var implicitResultSymbol = {\n              type: \"symbol\",\n              evaluate: function (context) {\n                  return runtime.resolveSymbol(\"result\", context);\n              },\n          };\n\n          if (tokens.matchToken(\"to\")) {\n              targetExpr = parser.requireElement(\"expression\", tokens);\n          } else {\n              targetExpr = implicitResultSymbol;\n          }\n\n          var setter = null;\n          if (targetExpr.type === \"symbol\" || targetExpr.type === \"attributeRef\" || targetExpr.root != null) {\n              setter = makeSetter(parser, runtime, tokens, targetExpr, implicitResultSymbol);\n          }\n\n          var command = {\n              value: value,\n              target: targetExpr,\n              args: [targetExpr, value],\n              op: function (context, target, value) {\n                  if (Array.isArray(target)) {\n                      target.push(value);\n                      return runtime.findNext(this, context);\n                  } else if (target instanceof Element) {\n                      target.innerHTML += value;\n                      return runtime.findNext(this, context);\n                  } else if(setter) {\n                      context.result = (target || \"\") + value;\n                      return setter;\n                  } else {\n                      throw Error(\"Unable to append a value!\")\n                  }\n              },\n              execute: function (context) {\n                  return runtime.unifiedExec(this, context/*, value, target*/);\n              },\n          };\n\n          if (setter != null) {\n              setter.parent = command;\n          }\n\n          return command;\n      });\n\n      function parsePickRange(parser, runtime, tokens) {\n          tokens.matchToken(\"at\") || tokens.matchToken(\"from\");\n          const rv = { from:undefined, to:undefined, includeStart:true, includeEnd:false, toEnd:undefined }\n\n          rv.from = tokens.matchToken(\"start\") ? 0 : parser.requireElement(\"expression\", tokens)\n\n          if (tokens.matchToken(\"to\") || tokens.matchOpToken(\"..\")) {\n            if (tokens.matchToken(\"end\")) {\n              rv.toEnd = true;\n            } else {\n              rv.to = parser.requireElement(\"expression\", tokens);\n            }\n          }\n\n          if (tokens.matchToken(\"inclusive\")) rv.includeEnd = true;\n          else if (tokens.matchToken(\"exclusive\")) rv.includeStart = false;\n\n          return rv;\n      }\n\n      class RegExpIterator {\n        public re:RegExp\n        public flags:string\n        public str:string\n\n        constructor(re, str) {\n          this.re = re;\n          this.str = str;\n        }\n\n        next() {\n          const match = this.re.exec(this.str);\n          if (match === null) return { done: true };\n          else return { value: match };\n        }\n      }\n\n      class RegExpIterable {\n        public re:RegExp\n        public flags:string\n        public str:string\n\n        constructor(re, flags, str) {\n          this.re = re;\n          this.flags = flags;\n          this.str = str;\n        }\n\n        [Symbol.iterator]() {\n          return new RegExpIterator(new RegExp(this.re, this.flags), this.str);\n        }\n      }\n\n      parser.addCommand(\"pick\", (parser, runtime, tokens) => {\n        if (!tokens.matchToken(\"pick\")) return;\n\n        tokens.matchToken(\"the\");\n\n        if (tokens.matchToken(\"item\") || tokens.matchToken(\"items\")\n         || tokens.matchToken(\"character\") || tokens.matchToken(\"characters\")) {\n          const range = parsePickRange(parser, runtime, tokens);\n\n          tokens.requireToken(\"from\");\n          const root = parser.requireElement(\"expression\", tokens);\n\n          return {\n            args: [root, range.from, range.to],\n            op(ctx, root, from, to) {\n              if (range.toEnd) to = root.length;\n              if (!range.includeStart) from++;\n              if (range.includeEnd) to++;\n              if (to == null || to == undefined) to = from + 1;\n              ctx.result = root.slice(from, to);\n              return runtime.findNext(this, ctx);\n            }\n          }\n        }\n\n        if (tokens.matchToken(\"match\")) {\n          tokens.matchToken(\"of\");\n          const re = parser.parseElement(\"expression\", tokens);\n          let flags = \"\"\n          if (tokens.matchOpToken(\"|\")) {\n            flags = tokens.requireToken(\"identifier\").value;\n          }\n\n          tokens.requireToken(\"from\");\n          const root = parser.parseElement(\"expression\", tokens);\n\n          return {\n            args: [root, re],\n            op(ctx, root, re) {\n              ctx.result = new RegExp(re, flags).exec(root);\n              return runtime.findNext(this, ctx);\n            }\n          }\n        }\n\n        if (tokens.matchToken(\"matches\")) {\n          tokens.matchToken(\"of\");\n          const re = parser.parseElement(\"expression\", tokens);\n          let flags = \"gu\"\n          if (tokens.matchOpToken(\"|\")) {\n            flags = 'g' + tokens.requireToken(\"identifier\").value.replace('g', '');\n          }\n          console.log('flags', flags)\n\n          tokens.requireToken(\"from\");\n          const root = parser.parseElement(\"expression\", tokens);\n\n          return {\n            args: [root, re],\n            op(ctx, root, re) {\n              ctx.result = new RegExpIterable(re, flags, root);\n              return runtime.findNext(this, ctx);\n            }\n          }\n        }\n      });\n  \n      parser.addCommand(\"increment\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"increment\")) return;\n          var amountExpr;\n  \n          // This is optional.  Defaults to \"result\"\n          var target = parser.parseElement(\"assignableExpression\", tokens);\n  \n          // This is optional. Defaults to 1.\n          if (tokens.matchToken(\"by\")) {\n              amountExpr = parser.requireElement(\"expression\", tokens);\n          }\n  \n          var implicitIncrementOp = {\n              type: \"implicitIncrementOp\",\n              target: target,\n              args: [target, amountExpr],\n              op: function (context, targetValue, amount) {\n                  targetValue = targetValue ? parseFloat(targetValue) : 0;\n                  amount = amountExpr ? parseFloat(amount) : 1;\n                  var newValue = targetValue + amount;\n                  context.result = newValue;\n                  return newValue;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              }\n          };\n\n          return makeSetter(parser, runtime, tokens, target, implicitIncrementOp);\n      });\n  \n      parser.addCommand(\"decrement\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"decrement\")) return;\n          var amountExpr;\n  \n          // This is optional.  Defaults to \"result\"\n          var target = parser.parseElement(\"assignableExpression\", tokens);\n  \n          // This is optional. Defaults to 1.\n          if (tokens.matchToken(\"by\")) {\n              amountExpr = parser.requireElement(\"expression\", tokens);\n          }\n  \n          var implicitDecrementOp = {\n              type: \"implicitDecrementOp\",\n              target: target,\n              args: [target, amountExpr],\n              op: function (context, targetValue, amount) {\n                  targetValue = targetValue ? parseFloat(targetValue) : 0;\n                  amount = amountExpr ? parseFloat(amount) : 1;\n                  var newValue = targetValue - amount;\n                  context.result = newValue;\n                  return newValue;\n              },\n              evaluate: function (context) {\n                  return runtime.unifiedEval(this, context);\n              }\n          };\n\n          return makeSetter(parser, runtime, tokens, target, implicitDecrementOp);\n      });\n\n      function parseConversionInfo(tokens, parser) {\n          var type = \"text\";\n          var conversion;\n          tokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n          if (tokens.matchToken(\"json\") || tokens.matchToken(\"Object\")) {\n              type = \"json\";\n          } else if (tokens.matchToken(\"response\")) {\n              type = \"response\";\n          } else if (tokens.matchToken(\"html\")) {\n              type = \"html\";\n          } else if (tokens.matchToken(\"text\")) {\n              // default, ignore\n          } else {\n              conversion = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n          }\n          return {type, conversion};\n      }\n\n      parser.addCommand(\"fetch\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"fetch\")) return;\n          var url = parser.requireElement(\"stringLike\", tokens);\n\n          if (tokens.matchToken(\"as\")) {\n              var conversionInfo = parseConversionInfo(tokens, parser);\n          }\n\n          if (tokens.matchToken(\"with\") && tokens.currentToken().value !== \"{\") {\n              var args = parser.parseElement(\"nakedNamedArgumentList\", tokens);\n          } else {\n              var args = parser.parseElement(\"objectLiteral\", tokens);\n          }\n\n          if (conversionInfo == null && tokens.matchToken(\"as\")) {\n              conversionInfo = parseConversionInfo(tokens, parser);\n          }\n\n          var type = conversionInfo ? conversionInfo.type : \"text\";\n          var conversion = conversionInfo ? conversionInfo.conversion : null\n\n          /** @type {ASTNode} */\n          var fetchCmd = {\n              url: url,\n              argExpressions: args,\n              args: [url, args],\n              op: function (context, url, args) {\n                  var detail = args || {};\n                  detail[\"sender\"] = context.me;\n                  detail[\"headers\"] = detail[\"headers\"] || {}\n                  var abortController = new AbortController();\n                  let abortListener = context.me.addEventListener('fetch:abort', function(){\n                      abortController.abort();\n                  }, {once: true});\n                  detail['signal'] = abortController.signal;\n                  runtime.triggerEvent(context.me, \"hyperscript:beforeFetch\", detail);\n                  runtime.triggerEvent(context.me, \"fetch:beforeRequest\", detail);\n                  args = detail;\n                  var finished = false;\n                  if (args.timeout) {\n                      setTimeout(function () {\n                          if (!finished) {\n                              abortController.abort();\n                          }\n                      }, args.timeout);\n                  }\n                  return fetch(url, args)\n                      .then(function (resp) {\n                          let resultDetails = {response:resp};\n                          runtime.triggerEvent(context.me, \"fetch:afterResponse\", resultDetails);\n                          resp = resultDetails.response;\n\n                          if (type === \"response\") {\n                              context.result = resp;\n                              runtime.triggerEvent(context.me, \"fetch:afterRequest\", {result:resp});\n                              finished = true;\n                              return runtime.findNext(fetchCmd, context);\n                          }\n                          if (type === \"json\") {\n                              return resp.json().then(function (result) {\n                                  context.result = result;\n                                  runtime.triggerEvent(context.me, \"fetch:afterRequest\", {result});\n                                  finished = true;\n                                  return runtime.findNext(fetchCmd, context);\n                              });\n                          }\n                          return resp.text().then(function (result) {\n                              if (conversion) result = runtime.convertValue(result, conversion);\n\n                              if (type === \"html\") result = runtime.convertValue(result, \"Fragment\");\n\n                              context.result = result;\n                              runtime.triggerEvent(context.me, \"fetch:afterRequest\", {result});\n                              finished = true;\n                              return runtime.findNext(fetchCmd, context);\n                          });\n                      })\n                      .catch(function (reason) {\n                          runtime.triggerEvent(context.me, \"fetch:error\", {\n                              reason: reason,\n                          });\n                          throw reason;\n                      }).finally(function(){\n                          context.me.removeEventListener('fetch:abort', abortListener);\n                      });\n              },\n          };\n          return fetchCmd;\n      });\n  }\n\n  function hyperscriptWebGrammar(parser) {\n      parser.addCommand(\"settle\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"settle\")) {\n              if (!parser.commandBoundary(tokens.currentToken())) {\n                  var onExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  var onExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              }\n\n              var settleCommand = {\n                  type: \"settleCmd\",\n                  args: [onExpr],\n                  op: function (context, on) {\n                      runtime.nullCheck(on, onExpr);\n                      var resolve = null;\n                      var resolved = false;\n                      var transitionStarted = false;\n\n                      var promise = new Promise(function (r) {\n                          resolve = r;\n                      });\n\n                      // listen for a transition begin\n                      on.addEventListener(\n                          \"transitionstart\",\n                          function () {\n                              transitionStarted = true;\n                          },\n                          { once: true }\n                      );\n\n                      // if no transition begins in 500ms, cancel\n                      setTimeout(function () {\n                          if (!transitionStarted && !resolved) {\n                              resolve(runtime.findNext(settleCommand, context));\n                          }\n                      }, 500);\n\n                      // continue on a transition emd\n                      on.addEventListener(\n                          \"transitionend\",\n                          function () {\n                              if (!resolved) {\n                                  resolve(runtime.findNext(settleCommand, context));\n                              }\n                          },\n                          { once: true }\n                      );\n                      return promise;\n                  },\n                  execute: function (context) {\n                      return runtime.unifiedExec(this, context);\n                  },\n              };\n              return settleCommand;\n          }\n      });\n\n      parser.addCommand(\"add\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"add\")) {\n              var classRef = parser.parseElement(\"classRef\", tokens);\n              var attributeRef = null;\n              var cssDeclaration = null;\n              if (classRef == null) {\n                  attributeRef = parser.parseElement(\"attributeRef\", tokens);\n                  if (attributeRef == null) {\n                      cssDeclaration = parser.parseElement(\"styleLiteral\", tokens);\n                      if (cssDeclaration == null) {\n                          parser.raiseParseError(tokens, \"Expected either a class reference or attribute expression\");\n                      }\n                  }\n              } else {\n                  var classRefs = [classRef];\n                  while ((classRef = parser.parseElement(\"classRef\", tokens))) {\n                      classRefs.push(classRef);\n                  }\n              }\n\n              if (tokens.matchToken(\"to\")) {\n                  var toExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  var toExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              }\n\n              if (tokens.matchToken(\"when\")) {\n                  if (cssDeclaration) {\n                      parser.raiseParseError(tokens, \"Only class and properties are supported with a when clause\")\n                  }\n                  var when = parser.requireElement(\"expression\", tokens);\n              }\n\n              if (classRefs) {\n                  return {\n                      classRefs: classRefs,\n                      to: toExpr,\n                      args: [toExpr, classRefs],\n                      op: function (context, to, classRefs) {\n                          runtime.nullCheck(to, toExpr);\n                          runtime.forEach(classRefs, function (classRef) {\n                              runtime.implicitLoop(to, function (target) {\n                                  if (when) {\n                                      context.result = target;\n                                      let whenResult = runtime.evaluateNoPromise(when, context);\n                                      if (whenResult) {\n                                          if (target instanceof Element) target.classList.add(classRef.className);\n                                      } else {\n                                          if (target instanceof Element) target.classList.remove(classRef.className);\n                                      }\n                                      context.result = null;\n                                  } else {\n                                      if (target instanceof Element) target.classList.add(classRef.className);\n                                  }\n                              });\n                          });\n                          return runtime.findNext(this, context);\n                      },\n                  };\n              } else if (attributeRef) {\n                  return {\n                      type: \"addCmd\",\n                      attributeRef: attributeRef,\n                      to: toExpr,\n                      args: [toExpr],\n                      op: function (context, to, attrRef) {\n                          runtime.nullCheck(to, toExpr);\n                          runtime.implicitLoop(to, function (target) {\n                              if (when) {\n                                  context.result = target;\n                                  let whenResult = runtime.evaluateNoPromise(when, context);\n                                  if (whenResult) {\n                                      target.setAttribute(attributeRef.name, attributeRef.value);\n                                  } else {\n                                      target.removeAttribute(attributeRef.name);\n                                  }\n                                  context.result = null;\n                              } else {\n                                  target.setAttribute(attributeRef.name, attributeRef.value);\n                              }\n                          });\n                          return runtime.findNext(this, context);\n                      },\n                      execute: function (ctx) {\n                          return runtime.unifiedExec(this, ctx);\n                      },\n                  };\n              } else {\n                  return {\n                      type: \"addCmd\",\n                      cssDeclaration: cssDeclaration,\n                      to: toExpr,\n                      args: [toExpr, cssDeclaration],\n                      op: function (context, to, css) {\n                          runtime.nullCheck(to, toExpr);\n                          runtime.implicitLoop(to, function (target) {\n                              target.style.cssText += css;\n                          });\n                          return runtime.findNext(this, context);\n                      },\n                      execute: function (ctx) {\n                          return runtime.unifiedExec(this, ctx);\n                      },\n                  };\n              }\n          }\n      });\n\n      parser.addGrammarElement(\"styleLiteral\", function (parser, runtime, tokens) {\n          if (!tokens.matchOpToken(\"{\")) return;\n\n          var stringParts = [\"\"]\n          var exprs = []\n\n          while (tokens.hasMore()) {\n              if (tokens.matchOpToken(\"\\\\\")) {\n                  tokens.consumeToken();\n              } else if (tokens.matchOpToken(\"}\")) {\n                  break;\n              } else if (tokens.matchToken(\"$\")) {\n                  var opencurly = tokens.matchOpToken(\"{\");\n                  var expr = parser.parseElement(\"expression\", tokens);\n                  if (opencurly) tokens.requireOpToken(\"}\");\n\n                  exprs.push(expr)\n                  stringParts.push(\"\")\n              } else {\n                  var tok = tokens.consumeToken();\n                  stringParts[stringParts.length-1] += tokens.source.substring(tok.start, tok.end);\n              }\n\n              stringParts[stringParts.length-1] += tokens.lastWhitespace();\n          }\n\n          return {\n              type: \"styleLiteral\",\n              args: [exprs],\n              op: function (ctx, exprs) {\n                  var rv = \"\";\n\n                  stringParts.forEach(function (part, idx) {\n                      rv += part;\n                      if (idx in exprs) rv += exprs[idx];\n                  });\n\n                  return rv;\n              },\n              evaluate: function(ctx) {\n                  return runtime.unifiedEval(this, ctx);\n              }\n          }\n      })\n\n      parser.addCommand(\"remove\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"remove\")) {\n              var classRef = parser.parseElement(\"classRef\", tokens);\n              var attributeRef = null;\n              var elementExpr = null;\n              if (classRef == null) {\n                  attributeRef = parser.parseElement(\"attributeRef\", tokens);\n                  if (attributeRef == null) {\n                      elementExpr = parser.parseElement(\"expression\", tokens);\n                      if (elementExpr == null) {\n                          parser.raiseParseError(\n                              tokens,\n                              \"Expected either a class reference, attribute expression or value expression\"\n                          );\n                      }\n                  }\n              } else {\n                  var classRefs = [classRef];\n                  while ((classRef = parser.parseElement(\"classRef\", tokens))) {\n                      classRefs.push(classRef);\n                  }\n              }\n\n              if (tokens.matchToken(\"from\")) {\n                  var fromExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  if (elementExpr == null) {\n                      var fromExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n                  }\n              }\n\n              if (elementExpr) {\n                  return {\n                      elementExpr: elementExpr,\n                      from: fromExpr,\n                      args: [elementExpr, fromExpr],\n                      op: function (context, element, from) {\n                          runtime.nullCheck(element, elementExpr);\n                          runtime.implicitLoop(element, function (target) {\n                              if (target.parentElement && (from == null || from.contains(target))) {\n                                  target.parentElement.removeChild(target);\n                              }\n                          });\n                          return runtime.findNext(this, context);\n                      },\n                  };\n              } else {\n                  return {\n                      classRefs: classRefs,\n                      attributeRef: attributeRef,\n                      elementExpr: elementExpr,\n                      from: fromExpr,\n                      args: [classRefs, fromExpr],\n                      op: function (context, classRefs, from) {\n                          runtime.nullCheck(from, fromExpr);\n                          if (classRefs) {\n                              runtime.forEach(classRefs, function (classRef) {\n                                  runtime.implicitLoop(from, function (target) {\n                                      target.classList.remove(classRef.className);\n                                  });\n                              });\n                          } else {\n                              runtime.implicitLoop(from, function (target) {\n                                  target.removeAttribute(attributeRef.name);\n                              });\n                          }\n                          return runtime.findNext(this, context);\n                      },\n                  };\n              }\n          }\n      });\n\n      parser.addCommand(\"toggle\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"toggle\")) {\n              tokens.matchAnyToken(\"the\", \"my\");\n              if (tokens.currentToken().type === \"STYLE_REF\") {\n                  let styleRef = tokens.consumeToken();\n                  var name = styleRef.value.substr(1);\n                  var visibility = true;\n                  var hideShowStrategy = resolveStrategy(parser, tokens, name);\n                  if (tokens.matchToken(\"of\")) {\n                      tokens.pushFollow(\"with\");\n                      try {\n                          var onExpr = parser.requireElement(\"expression\", tokens);\n                      } finally {\n                          tokens.popFollow();\n                      }\n                  } else {\n                      var onExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n                  }\n              } else if (tokens.matchToken(\"between\")) {\n                  var between = true;\n                  var classRef = parser.parseElement(\"classRef\", tokens);\n                  tokens.requireToken(\"and\");\n                  var classRef2 = parser.requireElement(\"classRef\", tokens);\n              } else {\n                  var classRef = parser.parseElement(\"classRef\", tokens);\n                  var attributeRef = null;\n                  if (classRef == null) {\n                      attributeRef = parser.parseElement(\"attributeRef\", tokens);\n                      if (attributeRef == null) {\n                          parser.raiseParseError(tokens, \"Expected either a class reference or attribute expression\");\n                      }\n                  } else {\n                      var classRefs = [classRef];\n                      while ((classRef = parser.parseElement(\"classRef\", tokens))) {\n                          classRefs.push(classRef);\n                      }\n                  }\n              }\n\n              if (visibility !== true) {\n                  if (tokens.matchToken(\"on\")) {\n                      var onExpr = parser.requireElement(\"expression\", tokens);\n                  } else {\n                      var onExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n                  }\n              }\n\n              if (tokens.matchToken(\"for\")) {\n                  var time = parser.requireElement(\"expression\", tokens);\n              } else if (tokens.matchToken(\"until\")) {\n                  var evt = parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\");\n                  if (tokens.matchToken(\"from\")) {\n                      var from = parser.requireElement(\"expression\", tokens);\n                  }\n              }\n\n              var toggleCmd = {\n                  classRef: classRef,\n                  classRef2: classRef2,\n                  classRefs: classRefs,\n                  attributeRef: attributeRef,\n                  on: onExpr,\n                  time: time,\n                  evt: evt,\n                  from: from,\n                  toggle: function (on, classRef, classRef2, classRefs) {\n                      runtime.nullCheck(on, onExpr);\n                      if (visibility) {\n                          runtime.implicitLoop(on, function (target) {\n                              hideShowStrategy(\"toggle\", target);\n                          });\n                      } else if (between) {\n                          runtime.implicitLoop(on, function (target) {\n                              if (target.classList.contains(classRef.className)) {\n                                  target.classList.remove(classRef.className);\n                                  target.classList.add(classRef2.className);\n                              } else {\n                                  target.classList.add(classRef.className);\n                                  target.classList.remove(classRef2.className);\n                              }\n                          });\n                      } else if (classRefs) {\n                          runtime.forEach(classRefs, function (classRef) {\n                              runtime.implicitLoop(on, function (target) {\n                                  target.classList.toggle(classRef.className);\n                              });\n                          });\n                      } else {\n                          runtime.forEach(on, function (target) {\n                              if (target.hasAttribute(attributeRef.name)) {\n                                  target.removeAttribute(attributeRef.name);\n                              } else {\n                                  target.setAttribute(attributeRef.name, attributeRef.value);\n                              }\n                          });\n                      }\n                  },\n                  args: [onExpr, time, evt, from, classRef, classRef2, classRefs],\n                  op: function (context, on, time, evt, from, classRef, classRef2, classRefs) {\n                      if (time) {\n                          return new Promise(function (resolve) {\n                              toggleCmd.toggle(on, classRef, classRef2, classRefs);\n                              setTimeout(function () {\n                                  toggleCmd.toggle(on, classRef, classRef2, classRefs);\n                                  resolve(runtime.findNext(toggleCmd, context));\n                              }, time);\n                          });\n                      } else if (evt) {\n                          return new Promise(function (resolve) {\n                              var target = from || context.me;\n                              target.addEventListener(\n                                  evt,\n                                  function () {\n                                      toggleCmd.toggle(on, classRef, classRef2, classRefs);\n                                      resolve(runtime.findNext(toggleCmd, context));\n                                  },\n                                  { once: true }\n                              );\n                              toggleCmd.toggle(on, classRef, classRef2, classRefs);\n                          });\n                      } else {\n                          this.toggle(on, classRef, classRef2, classRefs);\n                          return runtime.findNext(toggleCmd, context);\n                      }\n                  },\n              };\n              return toggleCmd;\n          }\n      });\n\n      var HIDE_SHOW_STRATEGIES = {\n          display: function (op, element, arg) {\n              if (arg) {\n                  element.style.display = arg;\n              } else if (op === \"toggle\") {\n                  if (getComputedStyle(element).display === \"none\") {\n                      HIDE_SHOW_STRATEGIES.display(\"show\", element, arg);\n                  } else {\n                      HIDE_SHOW_STRATEGIES.display(\"hide\", element, arg);\n                  }\n              } else if (op === \"hide\") {\n                  const internalData = parser.runtime.getInternalData(element);\n                  if (internalData.originalDisplay == null) {\n                      internalData.originalDisplay = element.style.display;\n                  }\n                  element.style.display = \"none\";\n              } else {\n                  const internalData = parser.runtime.getInternalData(element);\n                  if (internalData.originalDisplay && internalData.originalDisplay !== 'none') {\n                      element.style.display = internalData.originalDisplay;\n                  } else {\n                      element.style.removeProperty('display');\n                  }\n              }\n          },\n          visibility: function (op, element, arg) {\n              if (arg) {\n                  element.style.visibility = arg;\n              } else if (op === \"toggle\") {\n                  if (getComputedStyle(element).visibility === \"hidden\") {\n                      HIDE_SHOW_STRATEGIES.visibility(\"show\", element, arg);\n                  } else {\n                      HIDE_SHOW_STRATEGIES.visibility(\"hide\", element, arg);\n                  }\n              } else if (op === \"hide\") {\n                  element.style.visibility = \"hidden\";\n              } else {\n                  element.style.visibility = \"visible\";\n              }\n          },\n          opacity: function (op, element, arg) {\n              if (arg) {\n                  element.style.opacity = arg;\n              } else if (op === \"toggle\") {\n                  if (getComputedStyle(element).opacity === \"0\") {\n                      HIDE_SHOW_STRATEGIES.opacity(\"show\", element, arg);\n                  } else {\n                      HIDE_SHOW_STRATEGIES.opacity(\"hide\", element, arg);\n                  }\n              } else if (op === \"hide\") {\n                  element.style.opacity = \"0\";\n              } else {\n                  element.style.opacity = \"1\";\n              }\n          },\n      };\n\n      var parseShowHideTarget = function (parser, runtime, tokens) {\n          var target;\n          var currentTokenValue = tokens.currentToken();\n          if (currentTokenValue.value === \"when\" || currentTokenValue.value === \"with\" || parser.commandBoundary(currentTokenValue)) {\n              target = parser.parseElement(\"implicitMeTarget\", tokens);\n          } else {\n              target = parser.parseElement(\"expression\", tokens);\n          }\n          return target;\n      };\n\n      var resolveStrategy = function (parser, tokens, name) {\n          var configDefault = config.defaultHideShowStrategy;\n          var strategies = HIDE_SHOW_STRATEGIES;\n          if (config.hideShowStrategies) {\n              strategies = Object.assign(strategies, config.hideShowStrategies); // merge in user provided strategies\n          }\n          name = name || configDefault || \"display\";\n          var value = strategies[name];\n          if (value == null) {\n              parser.raiseParseError(tokens, \"Unknown show/hide strategy : \" + name);\n          }\n          return value;\n      };\n\n      parser.addCommand(\"hide\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"hide\")) {\n              var targetExpr = parseShowHideTarget(parser, runtime, tokens);\n\n              var name = null;\n              if (tokens.matchToken(\"with\")) {\n                  name = tokens.requireTokenType(\"IDENTIFIER\", \"STYLE_REF\").value;\n                  if (name.indexOf(\"*\") === 0) {\n                      name = name.substr(1);\n                  }\n              }\n              var hideShowStrategy = resolveStrategy(parser, tokens, name);\n\n              return {\n                  target: targetExpr,\n                  args: [targetExpr],\n                  op: function (ctx, target) {\n                      runtime.nullCheck(target, targetExpr);\n                      runtime.implicitLoop(target, function (elt) {\n                          hideShowStrategy(\"hide\", elt);\n                      });\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n          }\n      });\n\n      parser.addCommand(\"show\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"show\")) {\n              var targetExpr = parseShowHideTarget(parser, runtime, tokens);\n\n              var name = null;\n              if (tokens.matchToken(\"with\")) {\n                  name = tokens.requireTokenType(\"IDENTIFIER\", \"STYLE_REF\").value;\n                  if (name.indexOf(\"*\") === 0) {\n                      name = name.substr(1);\n                  }\n              }\n              var arg = null;\n              if (tokens.matchOpToken(\":\")) {\n                  var tokenArr = tokens.consumeUntilWhitespace();\n                  tokens.matchTokenType(\"WHITESPACE\");\n                  arg = tokenArr\n                      .map(function (t) {\n                          return t.value;\n                      })\n                      .join(\"\");\n              }\n\n              if (tokens.matchToken(\"when\")) {\n                  var when = parser.requireElement(\"expression\", tokens);\n              }\n\n              var hideShowStrategy = resolveStrategy(parser, tokens, name);\n\n              return {\n                  target: targetExpr,\n                  when: when,\n                  args: [targetExpr],\n                  op: function (ctx, target) {\n                      runtime.nullCheck(target, targetExpr);\n                      runtime.implicitLoop(target, function (elt) {\n                          if (when) {\n                              ctx.result = elt;\n                              let whenResult = runtime.evaluateNoPromise(when, ctx);\n                              if (whenResult) {\n                                  hideShowStrategy(\"show\", elt, arg);\n                              } else {\n                                  hideShowStrategy(\"hide\", elt);\n                              }\n                              ctx.result = null;\n                          } else {\n                              hideShowStrategy(\"show\", elt, arg);\n                          }\n                      });\n                      return runtime.findNext(this, ctx);\n                  },\n              };\n          }\n      });\n\n      parser.addCommand(\"take\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"take\")) {\n              var classRef = parser.requireElement(\"classRef\", tokens);\n\n              if (tokens.matchToken(\"from\")) {\n                  var fromExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  var fromExpr = classRef;\n              }\n\n              if (tokens.matchToken(\"for\")) {\n                  var forExpr = parser.requireElement(\"expression\", tokens);\n              } else {\n                  var forExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              }\n\n              var takeCmd = {\n                  classRef: classRef,\n                  from: fromExpr,\n                  forElt: forExpr,\n                  args: [classRef, fromExpr, forExpr],\n                  op: function (context, eltColl, from, forElt) {\n                      runtime.nullCheck(from, fromExpr);\n                      runtime.nullCheck(forElt, forExpr);\n                      var clazz = eltColl.className;\n                      runtime.implicitLoop(from, function (target) {\n                          target.classList.remove(clazz);\n                      });\n                      runtime.implicitLoop(forElt, function (target) {\n                          target.classList.add(clazz);\n                      });\n                      return runtime.findNext(this, context);\n                  },\n              };\n              return takeCmd;\n          }\n      });\n\n      function putInto(runtime, context, prop, valueToPut) {\n          if (prop != null) {\n              var value = runtime.resolveSymbol(prop, context);\n          } else {\n              var value = context;\n          }\n          if (value instanceof Element || value instanceof HTMLDocument) {\n              while (value.firstChild) value.removeChild(value.firstChild);\n              value.append(parser.runtime.convertValue(valueToPut, \"Fragment\"));\n              runtime.processNode(value);\n          } else {\n              if (prop != null) {\n                  runtime.setSymbol(prop, context, null, valueToPut);\n              } else {\n                  throw \"Don't know how to put a value into \" + typeof context;\n              }\n          }\n      }\n\n      parser.addCommand(\"put\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"put\")) {\n              var value = parser.requireElement(\"expression\", tokens);\n\n              var operationToken = tokens.matchAnyToken(\"into\", \"before\", \"after\");\n\n              if (operationToken == null && tokens.matchToken(\"at\")) {\n                  tokens.matchToken(\"the\"); // optional \"the\"\n                  operationToken = tokens.matchAnyToken(\"start\", \"end\");\n                  tokens.requireToken(\"of\");\n              }\n\n              if (operationToken == null) {\n                  parser.raiseParseError(tokens, \"Expected one of 'into', 'before', 'at start of', 'at end of', 'after'\");\n              }\n              var target = parser.requireElement(\"expression\", tokens);\n\n              var operation = operationToken.value;\n\n              var arrayIndex = false;\n              var symbolWrite = false;\n              var rootExpr = null;\n              var prop = null;\n\n              if (target.type === \"arrayIndex\" && operation === \"into\") {\n                  arrayIndex = true;\n                  prop = target.prop;\n                  rootExpr = target.root;\n              }  else if (target.prop && target.root && operation === \"into\") {\n                  prop = target.prop.value;\n                  rootExpr = target.root;\n              } else if (target.type === \"symbol\" && operation === \"into\") {\n                  symbolWrite = true;\n                  prop = target.name;\n              } else if (target.type === \"attributeRef\" && operation === \"into\") {\n                  var attributeWrite = true;\n                  prop = target.name;\n                  rootExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              } else if (target.type === \"styleRef\" && operation === \"into\") {\n                  var styleWrite = true;\n                  prop = target.name;\n                  rootExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n              } else if (target.attribute && operation === \"into\") {\n                  var attributeWrite = target.attribute.type === \"attributeRef\";\n                  var styleWrite = target.attribute.type === \"styleRef\";\n                  prop = target.attribute.name;\n                  rootExpr = target.root;\n              } else {\n                  rootExpr = target;\n              }\n\n              var putCmd = {\n                  target: target,\n                  operation: operation,\n                  symbolWrite: symbolWrite,\n                  value: value,\n                  args: [rootExpr, prop, value],\n                  op: function (context, root, prop, valueToPut) {\n                      if (symbolWrite) {\n                          putInto(runtime, context, prop, valueToPut);\n                      } else {\n                          runtime.nullCheck(root, rootExpr);\n                          if (operation === \"into\") {\n                              if (attributeWrite) {\n                                  runtime.implicitLoop(root, function (elt) {\n                                      elt.setAttribute(prop, valueToPut);\n                                  });\n                              } else if (styleWrite) {\n                                  runtime.implicitLoop(root, function (elt) {\n                                      elt.style[prop] = valueToPut;\n                                  });\n                              } else if (arrayIndex) {\n                                  root[prop] = valueToPut;\n                              } else {\n                                  runtime.implicitLoop(root, function (elt) {\n                                      putInto(runtime, elt, prop, valueToPut);\n                                  });\n                              }\n                          } else {\n                              var op =\n                                  operation === \"before\"\n                                      ? Element.prototype.before\n                                      : operation === \"after\"\n                                      ? Element.prototype.after\n                                      : operation === \"start\"\n                                      ? Element.prototype.prepend\n                                      : operation === \"end\"\n                                      ? Element.prototype.append\n                                      : Element.prototype.append; // unreachable\n\n                              runtime.implicitLoop(root, function (elt) {\n                                  op.call(\n                                      elt,\n                                      valueToPut instanceof Node\n                                          ? valueToPut\n                                          : runtime.convertValue(valueToPut, \"Fragment\")\n                                  );\n                                  // process any new content\n                                  if (elt.parentElement) {\n                                      runtime.processNode(elt.parentElement);\n                                  } else {\n                                      runtime.processNode(elt);\n                                  }\n                              });\n                          }\n                      }\n                      return runtime.findNext(this, context);\n                  },\n              };\n              return putCmd;\n          }\n      });\n\n      function parsePseudopossessiveTarget(parser, runtime, tokens) {\n          var targets;\n          if (\n              tokens.matchToken(\"the\") ||\n              tokens.matchToken(\"element\") ||\n              tokens.matchToken(\"elements\") ||\n              tokens.currentToken().type === \"CLASS_REF\" ||\n              tokens.currentToken().type === \"ID_REF\" ||\n              (tokens.currentToken().op && tokens.currentToken().value === \"<\")\n          ) {\n              parser.possessivesDisabled = true;\n              try {\n                  targets = parser.parseElement(\"expression\", tokens);\n              } finally {\n                  delete parser.possessivesDisabled;\n              }\n              // optional possessive\n              if (tokens.matchOpToken(\"'\")) {\n                  tokens.requireToken(\"s\");\n              }\n          } else if (tokens.currentToken().type === \"IDENTIFIER\" && tokens.currentToken().value === \"its\") {\n              var identifier = tokens.matchToken(\"its\");\n              targets = {\n                  type: \"pseudopossessiveIts\",\n                  token: identifier,\n                  name: identifier.value,\n                  evaluate: function (context) {\n                      return runtime.resolveSymbol(\"it\", context);\n                  },\n              };\n          } else {\n              tokens.matchToken(\"my\") || tokens.matchToken(\"me\"); // consume optional 'my'\n              targets = parser.parseElement(\"implicitMeTarget\", tokens);\n          }\n          return targets;\n      }\n\n      parser.addCommand(\"transition\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"transition\")) {\n              var targetsExpr = parsePseudopossessiveTarget(parser, runtime, tokens);\n\n              var properties = [];\n              var from = [];\n              var to = [];\n              var currentToken = tokens.currentToken();\n              while (\n                  !parser.commandBoundary(currentToken) &&\n                  currentToken.value !== \"over\" &&\n                  currentToken.value !== \"using\"\n              ) {\n                  if (tokens.currentToken().type === \"STYLE_REF\") {\n                      let styleRef = tokens.consumeToken();\n                      let styleProp = styleRef.value.substr(1);\n                      properties.push({\n                          type: \"styleRefValue\",\n                          evaluate: function () {\n                              return styleProp;\n                          },\n                      });\n                  } else {\n                      properties.push(parser.requireElement(\"stringLike\", tokens));\n                  }\n\n                  if (tokens.matchToken(\"from\")) {\n                      from.push(parser.requireElement(\"expression\", tokens));\n                  } else {\n                      from.push(null);\n                  }\n                  tokens.requireToken(\"to\");\n                  if (tokens.matchToken(\"initial\")) {\n                      to.push({\n                          type: \"initial_literal\",\n                          evaluate : function(){\n                              return \"initial\";\n                          }\n                      });\n                  } else {\n                      to.push(parser.requireElement(\"expression\", tokens));\n                  }\n                  currentToken = tokens.currentToken();\n              }\n              if (tokens.matchToken(\"over\")) {\n                  var over = parser.requireElement(\"expression\", tokens);\n              } else if (tokens.matchToken(\"using\")) {\n                  var using = parser.requireElement(\"expression\", tokens);\n              }\n\n              var transition = {\n                  to: to,\n                  args: [targetsExpr, properties, from, to, using, over],\n                  op: function (context, targets, properties, from, to, using, over) {\n                      runtime.nullCheck(targets, targetsExpr);\n                      var promises = [];\n                      runtime.implicitLoop(targets, function (target) {\n                          var promise = new Promise(function (resolve, reject) {\n                              var initialTransition = target.style.transition;\n                              if (over) {\n                                  target.style.transition = \"all \" + over + \"ms ease-in\";\n                              } else if (using) {\n                                  target.style.transition = using;\n                              } else {\n                                  target.style.transition = config.defaultTransition;\n                              }\n                              var internalData = runtime.getInternalData(target);\n                              var computedStyles = getComputedStyle(target);\n\n                              var initialStyles = {};\n                              for (var i = 0; i < computedStyles.length; i++) {\n                                  var name = computedStyles[i];\n                                  var initialValue = computedStyles[name];\n                                  initialStyles[name] = initialValue;\n                              }\n\n                              // store intitial values\n                              if (!internalData.initalStyles) {\n                                  internalData.initalStyles = initialStyles;\n                              }\n\n                              for (var i = 0; i < properties.length; i++) {\n                                  var property = properties[i];\n                                  var fromVal = from[i];\n                                  if (fromVal === \"computed\" || fromVal == null) {\n                                      target.style[property] = initialStyles[property];\n                                  } else {\n                                      target.style[property] = fromVal;\n                                  }\n                              }\n                              //console.log(\"transition started\", transition);\n\n                              var transitionStarted = false;\n                              var resolved = false;\n\n                              target.addEventListener(\n                                  \"transitionend\",\n                                  function () {\n                                      if (!resolved) {\n                                          //console.log(\"transition ended\", transition);\n                                          target.style.transition = initialTransition;\n                                          resolved = true;\n                                          resolve(undefined);\n                                      }\n                                  },\n                                  { once: true }\n                              );\n\n                              target.addEventListener(\n                                  \"transitionstart\",\n                                  function () {\n                                      transitionStarted = true;\n                                  },\n                                  { once: true }\n                              );\n\n                              // it no transition has started in 100ms, continue\n                              setTimeout(function () {\n                                  if (!resolved && !transitionStarted) {\n                                      //console.log(\"transition ended\", transition);\n                                      target.style.transition = initialTransition;\n                                      resolved = true;\n                                      resolve(undefined);\n                                  }\n                              }, 100);\n\n                              setTimeout(function () {\n                                  var autoProps = [];\n                                  for (var i = 0; i < properties.length; i++) {\n                                      var property = properties[i];\n                                      var toVal = to[i];\n                                      if (toVal === \"initial\") {\n                                          var propertyValue = internalData.initalStyles[property];\n                                          target.style[property] = propertyValue;\n                                      } else {\n                                          target.style[property] = toVal;\n                                      }\n                                      //console.log(\"set\", property, \"to\", target.style[property], \"on\", target, \"value passed in : \", toVal);\n                                  }\n                              }, 0);\n                          });\n                          promises.push(promise);\n                      });\n                      return Promise.all(promises).then(function () {\n                          return runtime.findNext(transition, context);\n                      });\n                  },\n              };\n              return transition;\n          }\n      });\n\n      parser.addCommand(\"measure\", function (parser, runtime, tokens) {\n          if (!tokens.matchToken(\"measure\")) return;\n\n          var targetExpr = parsePseudopossessiveTarget(parser, runtime, tokens);\n\n          var propsToMeasure = [];\n          if (!parser.commandBoundary(tokens.currentToken()))\n              do {\n                  propsToMeasure.push(tokens.matchTokenType(\"IDENTIFIER\").value);\n              } while (tokens.matchOpToken(\",\"));\n\n          return {\n              properties: propsToMeasure,\n              args: [targetExpr],\n              op: function (ctx, target) {\n                  runtime.nullCheck(target, targetExpr);\n                  if (0 in target) target = target[0]; // not measuring multiple elts\n                  var rect = target.getBoundingClientRect();\n                  var scroll = {\n                      top: target.scrollTop,\n                      left: target.scrollLeft,\n                      topMax: target.scrollTopMax,\n                      leftMax: target.scrollLeftMax,\n                      height: target.scrollHeight,\n                      width: target.scrollWidth,\n                  };\n\n                  ctx.result = {\n                      x: rect.x,\n                      y: rect.y,\n                      left: rect.left,\n                      top: rect.top,\n                      right: rect.right,\n                      bottom: rect.bottom,\n                      width: rect.width,\n                      height: rect.height,\n                      bounds: rect,\n\n                      scrollLeft: scroll.left,\n                      scrollTop: scroll.top,\n                      scrollLeftMax: scroll.leftMax,\n                      scrollTopMax: scroll.topMax,\n                      scrollWidth: scroll.width,\n                      scrollHeight: scroll.height,\n                      scroll: scroll,\n                  };\n\n                  runtime.forEach(propsToMeasure, function (prop) {\n                      if (prop in ctx.result) ctx.locals[prop] = ctx.result[prop];\n                      else throw \"No such measurement as \" + prop;\n                  });\n\n                  return runtime.findNext(this, ctx);\n              },\n          };\n      });\n\n      parser.addLeafExpression(\"closestExpr\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"closest\")) {\n              if (tokens.matchToken(\"parent\")) {\n                  var parentSearch = true;\n              }\n\n              var css = null;\n              if (tokens.currentToken().type === \"ATTRIBUTE_REF\") {\n                  var attributeRef = parser.requireElement(\"attributeRefAccess\", tokens, null);\n                  css = \"[\" + attributeRef.attribute.name + \"]\";\n              }\n\n              if (css == null) {\n                  var expr = parser.requireElement(\"expression\", tokens);\n                  if (expr.css == null) {\n                      parser.raiseParseError(tokens, \"Expected a CSS expression\");\n                  } else {\n                      css = expr.css;\n                  }\n              }\n\n              if (tokens.matchToken(\"to\")) {\n                  var to = parser.parseElement(\"expression\", tokens);\n              } else {\n                  var to = parser.parseElement(\"implicitMeTarget\", tokens);\n              }\n\n              var closestExpr = {\n                  type: \"closestExpr\",\n                  parentSearch: parentSearch,\n                  expr: expr,\n                  css: css,\n                  to: to,\n                  args: [to],\n                  op: function (ctx, to) {\n                      if (to == null) {\n                          return null;\n                      } else {\n                          let result = [];\n                          runtime.implicitLoop(to, function(to){\n                              if (parentSearch) {\n                                  result.push(to.parentElement ? to.parentElement.closest(css) : null);\n                              } else {\n                                  result.push(to.closest(css));\n                              }\n                          })\n                          if (runtime.shouldAutoIterate(to)) {\n                              return result;\n                          } else {\n                              return result[0];\n                          }\n                      }\n                  },\n                  evaluate: function (context) {\n                      return runtime.unifiedEval(this, context);\n                  },\n              };\n\n              if (attributeRef) {\n                  attributeRef.root = closestExpr;\n                  attributeRef.args = [closestExpr];\n                  return attributeRef;\n              } else {\n                  return closestExpr;\n              }\n          }\n      });\n\n      parser.addCommand(\"go\", function (parser, runtime, tokens) {\n          if (tokens.matchToken(\"go\")) {\n              if (tokens.matchToken(\"back\")) {\n                  var back = true;\n              } else {\n                  tokens.matchToken(\"to\");\n                  if (tokens.matchToken(\"url\")) {\n                      var target = parser.requireElement(\"stringLike\", tokens);\n                      var url = true;\n                      if (tokens.matchToken(\"in\")) {\n                          tokens.requireToken(\"new\");\n                          tokens.requireToken(\"window\");\n                          var newWindow = true;\n                      }\n                  } else {\n                      tokens.matchToken(\"the\"); // optional the\n                      var verticalPosition = tokens.matchAnyToken(\"top\", \"middle\", \"bottom\");\n                      var horizontalPosition = tokens.matchAnyToken(\"left\", \"center\", \"right\");\n                      if (verticalPosition || horizontalPosition) {\n                          tokens.requireToken(\"of\");\n                      }\n                      var target = parser.requireElement(\"unaryExpression\", tokens);\n\n                      var plusOrMinus = tokens.matchAnyOpToken(\"+\", \"-\");\n                      if (plusOrMinus) {\n                          tokens.pushFollow(\"px\");\n                          try {\n                              var offset = parser.requireElement(\"expression\", tokens);\n                          } finally {\n                              tokens.popFollow();\n                          }\n                      }\n                      tokens.matchToken(\"px\"); // optional px\n\n                      var smoothness = tokens.matchAnyToken(\"smoothly\", \"instantly\");\n\n                      var scrollOptions:ScrollOptions & { block?:string, inline?:string} = {};\n                      if (verticalPosition) {\n                          if (verticalPosition.value === \"top\") {\n                              scrollOptions.block = \"start\";\n                          } else if (verticalPosition.value === \"bottom\") {\n                              scrollOptions.block = \"end\";\n                          } else if (verticalPosition.value === \"middle\") {\n                              scrollOptions.block = \"center\";\n                          }\n                      }\n\n                      if (horizontalPosition) {\n                          if (horizontalPosition.value === \"left\") {\n                              scrollOptions.inline = \"start\";\n                          } else if (horizontalPosition.value === \"center\") {\n                              scrollOptions.inline = \"center\";\n                          } else if (horizontalPosition.value === \"right\") {\n                              scrollOptions.inline = \"end\";\n                          }\n                      }\n\n                      if (smoothness) {\n                          if (smoothness.value === \"smoothly\") {\n                              scrollOptions.behavior = \"smooth\";\n                          } else if (smoothness.value === \"instantly\") {\n// @ts-ignore *C* is the following correct?\n                              scrollOptions.behavior = \"instant\";\n                          }\n                      }\n                  }\n              }\n\n              var goCmd = {\n                  target: target,\n                  args: [target, offset],\n                  op: function (ctx, to, offset) {\n                      if (back) {\n                          window.history.back();\n                      } else if (url) {\n                          if (to) {\n                              if (newWindow) {\n                                  window.open(to);\n                              } else {\n                                  window.location.href = to;\n                              }\n                          }\n                      } else {\n                          runtime.implicitLoop(to, function (target) {\n\n                              if (target === window) {\n                                  target = document.body;\n                              }\n\n                              if(plusOrMinus) {\n                                  // a top scroll w/ an offset of some sort\n                                  var boundingRect = target.getBoundingClientRect();\n                                  let scrollShim = document.createElement('div');\n\n                                  if (plusOrMinus.value === \"-\") {\n                                      var finalOffset = -offset;\n                                  } else {\n                                      var finalOffset = - -offset;\n                                  }\n\n                                  scrollShim.style.position = 'absolute';\n                                  scrollShim.style.top = (boundingRect.x + finalOffset) + \"px\";\n                                  scrollShim.style.left = (boundingRect.y + finalOffset) + \"px\";\n                                  scrollShim.style.height = (boundingRect.height + (2 * finalOffset)) + \"px\";\n                                  scrollShim.style.width = (boundingRect.width + (2 * finalOffset)) + \"px\";\n                                  scrollShim.style.zIndex = \"\" + Number.MIN_SAFE_INTEGER;\n                                  scrollShim.style.opacity = \"0\";\n\n                                  document.body.appendChild(scrollShim);\n                                  setTimeout(function () {\n                                      document.body.removeChild(scrollShim);\n                                  }, 100);\n\n                                  target = scrollShim;\n                              }\n\n                              target.scrollIntoView(scrollOptions);\n                          });\n                      }\n                      return runtime.findNext(goCmd, ctx);\n                  },\n              };\n              return goCmd;\n          }\n      });\n\n      config.conversions.dynamicResolvers.push(function (str, node) {\n          if (!(str === \"Values\" || str.indexOf(\"Values:\") === 0)) {\n              return;\n          }\n          var conversion = str.split(\":\")[1];\n          /** @type Object<string,string | string[]> */\n          var result = {};\n\n          var implicitLoop = parser.runtime.implicitLoop.bind(parser.runtime);\n\n          implicitLoop(node, function (/** @type HTMLInputElement */ node) {\n              // Try to get a value directly from this node\n              var input = getInputInfo(node);\n\n              if (input !== undefined) {\n                  result[input.name] = input.value;\n                  return;\n              }\n\n              // Otherwise, try to query all child elements of this node that *should* contain values.\n              if (node.querySelectorAll != undefined) {\n                  /** @type {NodeListOf<HTMLInputElement>} */\n                  var children = node.querySelectorAll(\"input,select,textarea\");\n                  children.forEach(appendValue);\n              }\n          });\n\n          if (conversion) {\n              if (conversion === \"JSON\") {\n                  return JSON.stringify(result);\n              } else if (conversion === \"Form\") {\n                  /** @ts-ignore */\n                  // TODO: does this work with multiple inputs of the same name?\n                  return new URLSearchParams(result).toString();\n              } else {\n                  throw \"Unknown conversion: \" + conversion;\n              }\n          } else {\n              return result;\n          }\n\n          /**\n           * @param {HTMLInputElement} node\n           */\n          function appendValue(node) {\n              var info = getInputInfo(node);\n\n              if (info == undefined) {\n                  return;\n              }\n\n              // If there is no value already stored in this space.\n              if (result[info.name] == undefined) {\n                  result[info.name] = info.value;\n                  return;\n              }\n\n              if (Array.isArray(result[info.name]) && Array.isArray(info.value)) {\n                  result[info.name] = [].concat(result[info.name], info.value);\n                  return;\n              }\n          }\n\n          /**\n           * @param {HTMLInputElement} node\n           * @returns {{name:string, value:string | string[]} | undefined}\n           */\n          function getInputInfo(node) {\n              try {\n                  /** @type {{name: string, value: string | string[]}}*/\n                  var result = {\n                      name: node.name,\n                      value: node.value,\n                  };\n\n                  if (result.name == undefined || result.value == undefined) {\n                      return undefined;\n                  }\n\n                  if (node.type == \"radio\" && node.checked == false) {\n                      return undefined;\n                  }\n\n                  if (node.type == \"checkbox\") {\n                      if (node.checked == false) {\n                          result.value = undefined;\n                      } else if (typeof result.value === \"string\") {\n                          result.value = [result.value];\n                      }\n                  }\n\n                  if (node.type == \"select-multiple\") {\n                      /** @type {NodeListOf<HTMLSelectElement>} */\n                      var selected = node.querySelectorAll(\"option[selected]\");\n\n                      result.value = [];\n                      for (var index = 0; index < selected.length; index++) {\n                          result.value.push(selected[index].value);\n                      }\n                  }\n                  return result;\n              } catch (e) {\n                  return undefined;\n              }\n          }\n      });\n\n      config.conversions[\"HTML\"] = function (value) {\n          var toHTML = /** @returns {string}*/ function (/** @type any*/ value) {\n              if (value instanceof Array) {\n                  return value\n                      .map(function (item) {\n                          return toHTML(item);\n                      })\n                      .join(\"\");\n              }\n\n              if (value instanceof HTMLElement) {\n                  return value.outerHTML;\n              }\n\n              if (value instanceof NodeList) {\n                  var result = \"\";\n                  for (var i = 0; i < value.length; i++) {\n                      var node = value[i];\n                      if (node instanceof HTMLElement) {\n                          result += node.outerHTML;\n                      }\n                  }\n                  return result;\n              }\n\n              if (value.toString) {\n                  return value.toString();\n              }\n\n              return \"\";\n          };\n\n          return toHTML(value);\n      };\n\n      config.conversions[\"Fragment\"] = function (val) {\n          var frag = document.createDocumentFragment();\n          parser.runtime.implicitLoop(val, function (val) {\n              if (val instanceof Node) frag.append(val);\n              else {\n                  var temp = document.createElement(\"template\");\n                  temp.innerHTML = val;\n                  frag.append(temp.content);\n              }\n          });\n          return frag;\n      };\n  }\n\n\n  // Public API\n\n  const runtime_ = new Runtime(), lexer_ = runtime_.lexer, parser_ = runtime_.parser\n\n  /**\n   *\n   * @param {string} src\n   * @param {Partial<Context>} [ctx]\n   */\n  function run(src, ctx = undefined) {\n      return runtime_.evaluate(src, ctx)\n  }\n\n  function browserInit() {\n      /** @type {HTMLScriptElement[]} */\n      var scripts = Array.from(globalScope.document.querySelectorAll(\"script[type='text/hyperscript'][src]\"))\n      Promise.all(\n          scripts.map(function (script:any) {\n              return fetch(script.src)\n                  .then(function (res) {\n                      return res.text();\n                  });\n          })\n      )\n      .then(script_values => script_values.forEach(sc => _hyperscript(sc)))\n      .then(() => ready(function () {\n          mergeMetaConfig();\n          runtime_.processNode(document.documentElement);\n          globalScope.document.addEventListener(\"htmx:load\", function (/** @type {CustomEvent} */ evt) {\n              runtime_.processNode(evt.detail.elt);\n          });\n      }));\n\n      function ready(fn) {\n          if (document.readyState !== \"loading\") {\n              setTimeout(fn);\n          } else {\n              document.addEventListener(\"DOMContentLoaded\", fn);\n          }\n      }\n\n      function getMetaConfig() {\n          /** @type {HTMLMetaElement} */\n          var element = document.querySelector('meta[name=\"htmx-config\"]');\n          if (element) {\n              return parseJSON(element['content']);\n          } else {\n              return null;\n          }\n      }\n\n      function mergeMetaConfig() {\n          var metaConfig = getMetaConfig();\n          if (metaConfig) {\n              Object.assign(config, metaConfig);\n          }\n      }\n  }\n\n  /**\n   * @typedef {Object} HyperscriptAPI\n   *\n   * @property {Object} config\n   * @property {string} config.attributes\n   * @property {string} config.defaultTransition\n   * @property {string} config.disableSelector\n   * @property {typeof conversions} config.conversions\n   *\n   * @property {Object} internals\n   * @property {Lexer} internals.lexer\n   * @property {typeof Lexer} internals.Lexer\n   * @property {Parser} internals.parser\n   * @property {typeof Parser} internals.Parser\n   * @property {Runtime} internals.runtime\n   * @property {typeof Runtime} internals.Runtime\n   *\n   * @property {typeof ElementCollection} ElementCollection\n   *\n   * @property {(keyword: string, definition: ParseRule) => void} addFeature\n   * @property {(keyword: string, definition: ParseRule) => void} addCommand\n   * @property {(keyword: string, definition: ParseRule) => void} addLeafExpression\n   * @property {(keyword: string, definition: ParseRule) => void} addIndirectExpression\n   *\n   * @property {(src: string, ctx?: Partial<Context>) => any} evaluate\n   * @property {(src: string) => ASTNode} parse\n   * @property {(node: Element) => void} processNode\n   *\n   * @property {() => void} browserInit\n   *\n   *\n   * @typedef {HyperscriptAPI & ((src: string, ctx?: Partial<Context>) => any)} Hyperscript\n   */\n\n  /**\n   * @type {Hyperscript}\n   */\n  const _hyperscript = Object.assign(\n      run,\n      {\n          config,\n\n          use(plugin) { plugin(_hyperscript) },\n\n          internals: {\n              lexer: lexer_, parser: parser_, runtime: runtime_,\n              Lexer, Tokens, Parser, Runtime,\n          },\n          ElementCollection,\n\n          addFeature:            parser_.addFeature.bind(parser_),\n          addCommand:            parser_.addCommand.bind(parser_),\n          addLeafExpression:     parser_.addLeafExpression.bind(parser_),\n          addIndirectExpression: parser_.addIndirectExpression.bind(parser_),\n\n          evaluate:    runtime_.evaluate.bind(runtime_),\n          parse:       runtime_.parse.bind(runtime_),\n          processNode: runtime_.processNode.bind(runtime_),\n\n          browserInit,\n      }\n  )\n\n  return _hyperscript\n})\n"],"names":["self","factory","_hyperscript","globalScope","conversions","dynamicResolvers","str","value","Number","toFixed","indexOf","num","split","parseInt","String","val","toString","Int","Float","parseFloat","Date","Array","from","JSON","stringify","Object","parse","assign","config","attributes","hideShowStrategies","undefined","defaultHideShowStrategy","defaultTransition","disableSelector","Lexer","isValidCSSClassChar","c","isAlpha","isNumeric","isValidCSSIDChar","isWhitespace","isNewline","positionString","token","line","column","isIdentifierChar","isReservedChar","isValidSingleQuoteStringStart","tokens","length","previousToken","type","op","tokenize","string","template","source","position","lastToken","templateBraceCount","inTemplate","currentChar","nextChar","nextCharAt","consumeComment","consumeCommentMultiline","push","consumeWhitespace","possiblePrecedingSymbol","consumeAttributeReference","consumeShortAttributeReference","consumeStyleReference","consumeIdentifier","consumeNumber","OP_TABLE","consumeOp","makeToken","consumeChar","Error","consumeString","consumeIdReference","consumeClassReference","Tokens","makeOpToken","start","end","classRef","attributeRef","styleRef","idRef","identifier","number","startChar","nextChar_1","charAt","whitespace","prototype","$","consumed","this","_lastConsumed","follows","defineProperty","get","shift","raiseError","error","Parser","raiseParseError","requireOpToken","matchOpToken","currentToken","matchAnyOpToken","i","arguments","opToken","match","matchAnyToken","matchToken","consumeToken","requireTokenType","type1","type2","type3","type4","matchTokenType","requireToken","peekToken","peek","consumeUntil","tokenList","lastWhitespace","consumeUntilWhitespace","hasMore","n","dontIgnoreWhitespace","lastMatch","pushFollow","popFollow","pop","clearFollows","tmp","restoreFollows","f","sourceFor","programSource","substring","startToken","endToken","lineFor","runtime","GRAMMAR","COMMANDS","FEATURES","LEAF_EXPRESSIONS","INDIRECT_EXPRESSIONS","possessivesDisabled","addGrammarElement","parser","featureElement","requireElement","featureDefinition","commandElement_1","commandElement","commandDefinition","parseElement","cmd","next","result","parseAnyOf","root","indirect","unless","args","context","conditional","execute","unifiedExec","parent","leaf","use","plugin","initElt","elementDefinition","message","types","expression","name","definition","addCommand","keyword","commandGrammarType","commandDefinitionWrapper","meta","command","addFeature","featureGrammarType","featureDefinitionWrapper","isFeature","addLeafExpression","addIndirectExpression","createParserContext","lines","contextLine","offset","repeat","parseHyperScript","setParent","elt","children","Set","add","commandStart","featureStart","commandBoundary","parseStringTemplate","returnArr","startingBrace","ensureTerminated","commandList","implicitReturn","returned","resolve","HALT","ctx","Runtime","lexer","_scriptAttrs","hyperscriptFeaturesMap","WeakMap","internalDataMap","hyperscriptUrl","document","currentScript","hyperscriptCoreGrammar","hyperscriptWebGrammar","matchesSelector","selector","matchesFunction","matches","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","call","makeEvent","eventName","detail","evt","Event","bubbles","cancelable","createEvent","initCustomEvent","triggerEvent","sender","event","dispatchEvent","isArrayLike","isArray","NodeList","HTMLCollection","isIterable","Symbol","iterator","shouldAutoIterate","shouldAutoIterateSymbol","forEach","func","value_1","__values","value_1_1","done","implicitLoop","value_2","value_2_1","wrapArrays","arr","arg","Promise","all","unwrapAsyncs","values","asyncWrapper","j","valueElement","_this","unifiedEval","e","handlingFinally","console","registerHyperTrace","errorHandler","handlingError","locals","errorSymbol","currentException","then","resolvedNext","catch","reason","finallyHandler","onHalt","reject","async","wrappedAsyncs","argument","element","evaluate","apply","getScriptAttributes","replace","getScript","scriptAttribute","hasAttribute","getAttribute","HTMLScriptElement","innerText","getHyperscriptFeatures","hyperscriptFeatures","set","addFeatures","owner","parentElement","makeContext","feature","hyperscriptTarget","Context","getScriptSelector","map","attribute","join","convertValue","converted","dynamicResolver","converter","src","hyperscript","evaluateNoPromise","HyperscriptModule","_super","mod","module","__extends","id","EventTarget","body","processNode","initElement","querySelectorAll","target","closest","internalData","getInternalData","initialized","script","hyperScript","setTimeout","stack","typeCheck","typeString","nullOk","slice","getElementScope","scopeName","behavior","getOrInitObject","isReservedWord","includes","isHyperscriptContext","resolveSymbol","me","you","fromMetaContext","fromContext","setSymbol","elementScope","findNext","resolveNext","flatGet","property","getter","root_1","root_1_1","componentValue","resolveProperty","resolveAttribute","resolveStyle","style","resolveComputedStyle","getComputedStyle","getPropertyValue","assignToNamespace","nameSpace","propertyName","newRoot","getHyperTrace","thrown","trace","caller","traceMap","Map","traceEntry","print","logger","maxLen","Math","max","displayName","traceElt","padEnd","escapeSelector","nullCheck","isEmpty","doesExist","value_3","value_3_1","getRootNode","node","Node","rv","Document","ShadowRoot","getEventQueueFor","onFeature","eventQueuesForElt","eventQueues","eventQueueForFeature","queue","executing","iterators","ElementCollection","css","relativeToElement","escape","_css","substr","contains","_b","_c","selectMatches","prop","newObj","parseJSON","jString","logError","msg","log","varargConstructor","Cls","bind","concat","_runtime","expr","stringToken","rawValue","innerTokens","returnStr","tokenArr","t","numberToken","elementId","templateValue","getElementById","value_4","css_1","TemplatedQueryElementCollection","templateParts","elements","filter","Element","el","dataset","hsQueryId","removeAttribute","queryTokens","queryValue","_i","outerVal","innerValue","styleProp","startsWith","key","keyExpressions","valueExpressions","keys","returnVal","fields","_namedArgList_","scope","eltPrefix","booleanLiteral","arg1","returnFunc","propertyAccess","_context","rootVal","childOfUrRoot","urRoot","attributeElt","apostrophe","targetElt","results","within","rootElt","conversion","functionCall","argExressions","rootRoot","hyperfunc","argVals","_ctx","andBefore","andAfter","firstIndex","secondIndex","arrayIndex","STRING_POSTFIXES","stringPosfix","postfix","timeFactor","time","factor","typeName","originalEvaluate","logValue","constructor","scanForwardQuery","wrap","compareDocumentPosition","DOCUMENT_POSITION_PRECEDING","scanBackwardsQuery","DOCUMENT_POSITION_FOLLOWING","scanForwardArray","array","first","scanBackwardsArray","reverse","sloppyContains","container","sloppyMatches","toMatch","forwardSearch","thing","withinElt","inSearch","inElt","wrapping","operator","rhs","rhsVal","floor","random","mathOp","initialMathOp","lhs","lhsVal","comparisonToken","hasRightValue","logicalOp","initialLogicalOp","features","features_1","features_1_1","install","parseEventArgs","parseSendCmd","cmdType","details","toExpr","sendCmd","to","every","events","startCount","endCount","unbounded","intersectionSpec","mutationSpec","startCountToken","endCountToken","elsewhere","inExpr","debounceTime","throttleTime","execCount","on","debounced","lastExec","queueLast","queueFirst","queueNone","eventQueueInfo","queued","err","hypertrace","targets","eventSpec","MutationObserver","mutationList","observer","observe","observer_1","IntersectionObserver","entries","entries_1","entries_1_1","entry","isIntersecting","addEventListener","listener","isConnected","removeEventListener","eventValue","initialCtx","inElement","clearTimeout","now","warn","nameVal","funcName","functionFeature","argumentVal","callingCommand","promise","theResolve","theReject","returnValue","setCmd","setFeature_1","immediately","initFeature","handler","path","formalParams","hs","innerArgs","installFeature","behaviorPath","behaviorNamespace","Function","jsSourceStart","jsLastToken","funcNames","expectFunctionDeclaration","jsSourceEnd","exposedFunctionNames","jsSource","jsBody","function","inputs","inp","input","actualResult","slot","tellCmd","index","originalYou","lookahead","resolved","eventInfo","once","events_1","events_1_1","timeValue","separator","parseReturnFunction","returnAValue","returnCmd","keepExecuting","bubbling","haltDefault","exit","stopPropagation","preventDefault","exprs","withExpr","logCmd","throwCmd","parseCallOrGet","callCmd","tagname","classes","re","exec","trim","createElement","cls","classList","lookAhead","pseudoCommand","realRoot","makeSetter","symbolWrite","attributeWrite","styleWrite","arrayWrite","valueToSet","setAttribute","setter","defaultCmd","obj","objectLiteral","trueBranch","falseBranch","ifCmd","exprValue","parseRepeatExpression","startedWithForToken","innerStartToken","identifierToken","whileExpr","isUntil","forever","times","indexIdentifier","loop","last","waitATick","repeatCmd","until","whileValue","iteratorInfo","keepLooping","loopVal","eventFired","nextValFromIterator","repeatInit","parsePickRange","includeStart","includeEnd","toEnd","targetExpr","implicitResultSymbol","innerHTML","RegExpIterator","RegExpIterable","flags","RegExp","parseConversionInfo","range_1","flags_1","flags_2","amountExpr","implicitIncrementOp","targetValue","amount","newValue","implicitDecrementOp","url","conversionInfo","fetchCmd","argExpressions","abortController","AbortController","abortListener","abort","signal","finished","timeout","fetch","resp","resultDetails","response","json","text","finally","onExpr","settleCommand","transitionStarted","r","cssDeclaration","classRefs","when","className","remove","attrRef","cssText","stringParts","opencurly","tok","part","idx","elementExpr","fromExpr","removeChild","visibility","hideShowStrategy","resolveStrategy","between","classRef2","toggleCmd","toggle","HIDE_SHOW_STRATEGIES","display","originalDisplay","removeProperty","opacity","parseShowHideTarget","currentTokenValue","configDefault","strategies","putInto","valueToPut","HTMLDocument","firstChild","append","parsePseudopossessiveTarget","forExpr","forElt","eltColl","clazz","operationToken","operation","rootExpr","putCmd","before","after","prepend","targetsExpr","properties","styleProp_1","over","using","transition","promises","initialTransition","computedStyles","initialStyles","initialValue","initalStyles","fromVal","toVal","propertyValue","propsToMeasure","rect","getBoundingClientRect","scroll","top","scrollTop","left","scrollLeft","topMax","scrollTopMax","leftMax","scrollLeftMax","height","scrollHeight","width","scrollWidth","x","y","right","bottom","bounds","parentSearch","closestExpr","result_1","back","newWindow","verticalPosition","horizontalPosition","plusOrMinus","smoothness","scrollOptions","block","inline","goCmd","window","history","open","location","href","boundingRect","scrollShim_1","finalOffset","zIndex","MIN_SAFE_INTEGER","appendChild","scrollIntoView","getInputInfo","appendValue","URLSearchParams","info","checked","selected","toHTML","item","HTMLElement","outerHTML","frag","createDocumentFragment","temp","content","runtime_","lexer_","parser_","run","browserInit","scripts","ready","fn","readyState","getMetaConfig","querySelector","mergeMetaConfig","metaConfig","res","script_values","sc","documentElement","internals","exports"],"mappings":"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"}